<chapter id="expressions">
    <title>Expressions</title>
    
    <para>An <emphasis>expression</emphasis> is produces a value when executed. 
    An algorithm expressed using functions and expressions, rather than sequences 
    of statements is often easier to understand and refactor. Therefore, Ceylon
    has a highly flexible expressions syntax. Expressions are formed from:</para>
    
    <itemizedlist>
        <listitem>
            <para>literal values and self references,</para>
        </listitem>
        <listitem>
            <para>evaluation and assignment of values,</para>
        </listitem>
        <listitem>
            <para>invocation of functions and instantiation of classes,</para> 
        </listitem>
        <listitem>
            <para>callable references and anonymous functions,</para>
        </listitem>
        <listitem>
            <para>comprehensions,</para>
        </listitem>
        <listitem>
            <para>metamodel references,</para>
        </listitem>
        <listitem>
            <para>enumeration of iterables and tuples, and</para>
        </listitem>
        <listitem>
            <para>operators.</para>
        </listitem>
    </itemizedlist>
    
    <para>Ceylon expressions are validated for typesafety at compile time. To 
    determine whether an expression is assignable to a program element such as 
    an attribute, local, or parameter, Ceylon considers the 
    <emphasis>type</emphasis> of the expression (the type of the objects that 
    are produced when the expression is evaluated). An expression is assignable 
    to a program element if the type of the expression is assignable to the 
    declared type of the program element.</para>
    
    <section id="objectinstancesidentity">
        <title>Object instances, identity, and reference passing</title>
        
        <para>An <emphasis>object</emphasis> is a unique identifier, together with a 
        reference to a class, and a persistent value for each reference of the class 
        (including inherited references). The object is said to be an 
        <emphasis>instance</emphasis> of the class.</para>
        
        <para>A <emphasis>value</emphasis> is a reference to an object (a copy of its 
        unique identifier). At a particular point in the execution of the program, 
        every reference of every object that exists, and every initialized reference 
        of every function, getter, setter, or initializer that is currently executing 
        has a value. Furthermore, every time an expression is executed, it produces a 
        value.</para>
        
        <para>Two values are said to be <emphasis>identical</emphasis> if they are
        references to the same object&mdash;if they hold the same unique identifier. 
        The program may determine if two values of type <literal>Identifiable</literal> 
        are identical using the <literal>&identical;</literal> operator. It may not 
        directly obtain the unique identifier (which is a purely abstract construct). 
        The program has no way of determining the identity of a value which is not of 
        type <literal>Identifiable</literal>.</para>
        
        <para>Invocation of a function or instantiation of a class results in execution 
        of the function body or class initializer with parameter values that are copies 
        of the value produced by executing the argument expressions of the invocation, 
        and a reference to the receiving instance that is a copy of the value produced 
        by executing the receiver expression. The value produced by the invocation 
        expression is a copy of the value produced by execution of the 
        <literal>return</literal> directive expression.</para>
        
        <programlisting>Person myself(Person me) { return me; }
Person p = ...;
assert (myself(p)&identical;p); //assertion never fails</programlisting>

        <programlisting>Semaphore s = Semaphore();
this.semaphore = s;
assert (semaphore&identical;s); //assertion never fails</programlisting>
        
        <para>A new object is produced by execution of a class instantiation expression.
        The Ceylon compiler guarantees that if execution of a class initializer terminates
        with no uncaught exception, then every reference of the object has been initialized
        with a well-defined persistent value. The value of a reference is initialized for 
        the first time by execution of a specifier or assignment expression. Every class 
        instantiation expression results in an object with a new unique identifier shared 
        by no other existing object. The object exists from the point at which execution 
        of its initializer terminates. <emphasis>Conceptually</emphasis>, the object exists 
        until execution of the program terminates.</para>
        
        <para>In practice, the object exists at least until the point at which it is not 
        reachable by recursively following references from any function, getter, setter, 
        or initializer currently being executed, or from an expression in a statement 
        currently being executed. At this point, its persistent values are no longer 
        accessible to expressions which subsequently execute and the object may be 
        destroyed by the virtual machine. There is no way for the program to determine
        that an object has been destroyed by the virtual machine (Ceylon does not support 
        finalizers).</para>
        
        <para>As a special exception to the rules defined above:</para>
        
        <itemizedlist>
        <!--listitem>
            <para>The compiler is permitted to emit bytecode that unexpectedly creates or
            avoids creating an actual instance of <literal>Gettable</literal> or 
            <literal>Settable</literal>, when an expression is evaluated, as long as this 
            does not affect the observable behavior of the program.</para>
        </listitem-->
        <listitem>
            <para>The compiler is permitted to emit bytecode that produces a new instance of 
            certain types in the module <literal>ceylon.language</literal> without execution 
            of the initializer of the class, whenever any expression is evaluated. These 
            types are: any of the the built-in numeric types, <literal>Character</literal>, 
            <literal>Range</literal>, <literal>Entry</literal>, <literal>String</literal>,
            and <literal>Tuple</literal>. 
            Furthermore, it is permitted to use such a newly-produced instance as the value 
            of the expression, as long as the newly-produced instance is equal to the value 
            expected according to the rules above, as determined using the <literal>==</literal> 
            operator.</para>
        </listitem>
        </itemizedlist>
        
        <para>Therefore, the types listed above directly extend <literal>Object</literal>
        instead of <literal>Basic</literal>, and are not <literal>Identifiable</literal>.</para>
        
        <para>The execution of a Ceylon program complies with the rules laid out by the Java 
        programming language's execution model (Chapter 17 of the Java Language Specification).
        Ceylon attributes and locals are considered <emphasis>variables</emphasis> in the 
        sense of the JLS. Evaluation is considered a <emphasis>use</emphasis> operation, 
        and assignment is considered an <emphasis>assign</emphasis> operation, again in 
        terms of the JLS.</para>
        
        <comment><para>TODO: what about on a JavaScript VM?</para></comment>
        
    </section>
    
    <section id="constantexpressions">
        <title>Constant expressions</title>

    <comment><para>TODO: We need a definition of a "constant expression".
    We might use it for:</para>
    <itemizedlist>
    <listitem>annotations available at compile time, and even perhaps</listitem>
    <listitem>initializer/specifier expressions in declaration section of class body.</listitem>
    </itemizedlist>
    <para>For example we could follow Java's very restrictive model, and say 
    that a constant expression must be anything formed from literals, metamodel 
    references, the <literal>..</literal> and <literal>-></literal> operators.
    Or we could be much less restrictive and just say that it is any expression 
    that could be used to initialize a toplevel attribute of the package.</para>
    <para>At the very least, we need to properly define the scope in which the 
    above things are actually evaluated.</para></comment>
    
    </section>
    
    <section id="literalvalues">
        <title>Literal values</title>
    
    <para>Ceylon supports literal values of the following types:</para>
    
    <itemizedlist>
        <listitem>
            <para><literal>Integer</literal> and <literal>Float</literal>,</para>
        </listitem>
        <listitem>
            <para><literal>Character</literal>, and</para>
        </listitem>
        <listitem>
            <para><literal>String</literal>.</para>
        </listitem>
    </itemizedlist>
    
    <para>The types <literal>Integer</literal>, <literal>Float</literal>, 
    <literal>Character</literal>, and <literal>String</literal> are defined in the 
    module <literal>ceylon.language</literal>.</para>
    
    <comment><para>Note: Ceylon does not need a special syntax for <literal>Boolean</literal> 
    literal values, since <literal>Boolean</literal> is just a class with the cases 
    <literal>true</literal> and <literal>false</literal>. Likewise, <literal>null</literal> 
    is just the singleton value of an anonymous class.</para></comment>
    
    <programlisting>Literal: IntegerLiteral | FloatLiteral | CharacterLiteral | StringLiteral | VerbatimStringLiteral</programlisting>
    
    <para>All literal values are instances of immutable types. The value of a literal 
    expression is an instance of the type. How this instance is produced is not specified 
    here.</para>
    
    <!--section id="datetime">
        <title><literal>Date</literal> and <literal>Time</literal> literals</title>
        
        <para>A <literal>Date</literal> literal has the form:</para>
        
        <programlisting>DateLiteral: 
"'" 
Digit{1,2} "/" Digit{1,2} "/" Digit{4} 
"'"</programlisting>
        
        <para>A <literal>Time</literal> literal has the form:</para>
        
        <programlisting>TimeLiteral: 
"'" 
Digit{1,2} ":" Digit{2} ( ":" Digit{2} ( ":" Digit{3} )? )? 
(" " "AM"|"PM")? 
(" " Character{3,4})? 
"'"</programlisting>
        
        <para>For example:</para>
        
        <programlisting>Date date = '25/03/2005';</programlisting>
        <programlisting>Time time = '12:00 AM PST';</programlisting>
        
        <para>A <literal>Datetime</literal> may be composed from a <literal>Date</literal> and 
        a <literal>Time</literal> using the <literal>@</literal> operator.</para>
        
        <programlisting>Datetime datetime = '25/03/2005' @ '12:00 AM PST';</programlisting>
        
        <comment><para>TODO: alternatively, we could follow RFC3339-style datetimes, for example:
        <literal>1996-12-19T16:39:57-08:00</literal>.</para></comment>
        
        <comment><para>TODO: should we allow wildcards and ranges, to get cron-style expressions 
        like <literal>'1/*/*' @ '00:00 GMT'</literal>?</para></comment>
        
        <para>The <literal>..</literal> operator lets us construct intervals:</para>
        
        <programlisting>Interval&lt;Date&gt; timeRange = '0:0:00' .. '12:59:59 PM';</programlisting>
        <programlisting>Interval&lt;Date&gt; dateRange = '1/1/2008' .. '31/12/2007';</programlisting>
        <programlisting>Interval&lt;Datetime&gt; datetimeRange = '1/1/2008' @ '0:0:00' .. '31/12/2007' @ '12:59:59 PM';</programlisting>
        
    </section-->
    
        <!--
        
        <para>The attributes <literal>hours</literal>, <literal>minutes</literal>, <literal>seconds</literal>,
        <literal>years</literal>, <literal>months</literal>, <literal>days</literal>, <literal>weeks</literal>
        of the <literal>Integer</literal> class let us construct durations.</para>
        
        <programlisting>Duration&lt;Time&gt; duration = 12.hours + 34.minutes;</programlisting>
        <programlisting>Duration&lt;Date&gt; duration = 1.year + 2.months + 3.days;</programlisting>
        
        <para>Durations may be composed using the arithmetic operators <literal>+</literal>, 
        <literal>-</literal>, <literal>*</literal> and <literal>/</literal>.</para>
        
        <programlisting>Duration&lt;Time&gt; duration = 1.seconds / 10 - 1.seconds / 1000;</programlisting> 
        
        <para>The methods <literal>before()</literal> and <literal>after()</literal> let us add and
        subtract durations to and from datetimes.</para>
        
        <programlisting>Time time = 10.seconds.before('12:00 AM');</programlisting>
        <programlisting>Date date = 1.week.after('2/9/1974');</programlisting>
        
        -->
        
    <section id="naturalnumber">
        <title>Integer number literals</title>
        
        <para>An integer literal <literal>n</literal> is an 
        expression of type <literal>Integer</literal>.</para>
        
        <programlisting>Integer five = 5;</programlisting>
        <programlisting>Integer mask = $1111_0000;</programlisting>
        <programlisting>Integer white = #FFFF;</programlisting>
                
    </section>
    
    <section id="floatnumber">
        <title>Floating point number literals</title>
        
        <para>A floating point literal is an expression of 
        type <literal>Float</literal>.</para>
        
        <programlisting>shared Float pi = 3.14159;</programlisting>
        
    </section>
    
    <section id="character">
        <title>Character literals</title>
        
        <para>A single character literal is an expression of type 
        <literal>Character</literal>.</para>
                
        <programlisting>if (exists ch=string[i], ch &equals; '+') { ... }</programlisting>
        
    </section>
    
    <section id="string">
        <title>Character string literals</title>
        
        <para>A character string literal is an expression of type
        <literal>String</literal>.</para>
        
        <programlisting>person.name = "Gavin King";</programlisting>
        
        <programlisting>print("Melbourne\tVic\tAustralia\nAtlanta\tGA\tUSA\nGuanajuato\tGto\tMexico\n");</programlisting>
        
        <para>A verbatim string is also an expression of type
        <literal>String</literal>.</para>
        
        <programlisting>String multiline = """A verbatim string can have \ or a " in it."""";</programlisting>
        
    </section>
    
    <!--section id="quoted">
        <title>Single quoted literals</title>
        
        <para>Single-quoted strings are used to express literal values for dates, 
        times, regexes and hexadecimal numbers, and even for more domain-specific 
        things like names, cron expressions, internet addresses, and phone numbers.
        This is an important facility since Ceylon is a language for expressing 
        structured data.</para>
        
        <programlisting>Regex regex = '^\w+@((\w+)\.)+$';</programlisting>
        <programlisting>ph = '+1 (404) 129 3456';</programlisting>
        <programlisting>Duration duration = '1h 30m';</programlisting>
        <programlisting>Datetime dt = Datetime('25/03/2005', '12:00 AM PST');</programlisting>
        <programlisting>Timer { schedule = '0 0 23 ? * MON-FRI'; onTimeout=purge; }.start();</programlisting>
        <programlisting>Text { color = 'FF3B66'; "Hello World!" }</programlisting>
        <programlisting>Link { url = 'http://jboss.org/ceylon'; "Powered by Ceylon" }</programlisting>
        <programlisting>Email { to = 'gavin@hibernate.org'; subject="Ceylon"; text = "Need some help with the compiler?"; }</programlisting>
        
        <para>A single quoted literal may only appear in the following positions:</para>
        
        <itemizedlist>
            <listitem>
                <para>as the right hand side of a specifier for a local or
                attribute with an explicitly declared type, or</para>
            </listitem>
            <listitem>
                <para>as an argument of an invocation or instantiation.</para>
            </listitem>
        </itemizedlist>
        
        <para>In either case:</para>
        
        <itemizedlist>
            <listitem>
                <para>the declared type of the local, attribute, or parameter 
                must be a class or interface annotated <literal>literal</literal>,
                and</para>
            </listitem>
            <listitem>
                <para>the single quoted literal must match the pattern specified
                by the <literal>format</literal> argument of the 
                <literal>literal</literal> annotation.</para>
            </listitem>
        </itemizedlist>
        
        <para>The type of the literal expression is the declared type of the
        local, attribute, or parameter. At runtime, an instance of this type
        is produced by calling the method specified by the <literal>parser</literal>
        argument of the <literal>literal</literal> annotation.</para>
        
        <programlisting>Color parseColor(String literal) { ... }

literal { 
    format = '[0-9A-F]{6}|red|blue|green|yellow|black|white'; 
    parser = parseColor;
}
shared interface Color { ... }</programlisting>
        
        <comment><para>TODO: Single quoted operator literals should come built-in.
        For example: <literal>'+'</literal> and <literal>'&lt;='</literal>.</para></comment>
        
        <comment><para>TODO: we should try to support interpolated expressions, 
        just like we do for string literals.</para></comment>
        
    </section-->

    </section>

    <section id="stringtemplates">
        <title>String templates</title>
        
        <para>A character <emphasis>string template</emphasis> contains interpolated 
        expressions, surrounded by character string fragments.</para>
        
        <programlisting>StringTemplate: StringStart (Expression StringMid)* Expression StringEnd</programlisting>
        
        <para>Each interpolated expression contained in the string template must have 
        a type assignable to <literal>Object</literal> defined in 
        <literal>ceylon.language</literal>.</para>
        
        <programlisting>print("Hello, ``person.firstName`` ``person.lastName``, the time is ``Time()``.");</programlisting>
        
        <programlisting>print("1 + 1 = ``1 + 1``");</programlisting>
        
        <para>A string template is an expression of type <literal>String</literal>.</para>
        
        <!--
        <para>An interpolated expression in a string template may invoke or evaluate:</para>
        
        <itemizedlist>
            <listitem>
                <para>any class member that is visible to the containing scope in 
                which the literal appears, and</para>
            </listitem>
            <listitem>
                <para>any non-<literal>variable</literal> local, block local attribute 
                getter or block local method declared earlier within the containing 
                scope.</para>
            </listitem>
        </itemizedlist>
        -->
        
    </section>
    
    <section id="selfreferences">
        <title>Self references and the current package reference</title>
        
        <para>The type of the following expressions depends upon the context in which 
        they appear.</para>
        
        <programlisting>SelfReference: "this" | "super" | "outer" | "package"</programlisting>
        
    <section>
        <title><literal>this</literal></title>
            
        <para>The keyword <literal>this</literal> refers to the current instance, 
        and is assignable to the type of the current class or interface (the class 
        or interface in which the expression appears).</para>
        
    </section>
   
    <section>
        <title><literal>outer</literal></title>
            
        <para>The keyword <literal>outer</literal> refers to the current instance
        of the class or interface which immediately contains the current class or 
        interface and is assignable to the type of this containing class or 
        interface.</para>
        
    </section>
                
    <section>
        <title><literal>super</literal></title>
            
        <para>The keyword <literal>super</literal> refers to the current instance 
        (the instance that is being invoked), and has the same members as the 
        immediate superclass of the class, except for <literal>formal</literal> 
        members. Any invocation of this reference is processed by the method or 
        attribute defined or inherited by the superclass, bypassing any method 
        declaration that refines the method on the current class or any subclass 
        of the current class. The <literal>super</literal> reference is not assignable 
        to any type. Nor may not be narrowed to any type using <literal>if (is ...)</literal>.
        There is no <literal>super</literal> reference in an interface member body.</para>
        
        <comment><para>TODO: the syntax for invoking a member of an inherited
        interface is still in flux.</para></comment>
        
    </section>
        
    <section>
        <title><literal>package</literal></title>
        
        <para>The keyword <literal>package</literal> is not an expression, and
        does not have a well-defined type. However, it may be used to qualify 
        and disambiguate a value reference or callable reference. A value
        reference or callable reference qualified by the keyword 
        <literal>package</literal> always refers to a toplevel member of the
        containing package, never to an imported declaration or nested 
        declaration.</para>
        
    </section>
    
    </section>
    
        <section id="anonymousfunctions">
            <title>Anonymous functions</title>
            
            <para>An anonymous function is a function with no name, defined within
            an expression. It comprises one or more parameter lists, followed by an 
            expression.</para>
            
            <programlisting>Function: ("function" | "void")? Params+ ("=>" Expression | Block)</programlisting>
            
            <para>The parameters are the parameters of the function. The lazy 
            specifier or block of code is the implementation of the function. if 
            the <literal>void</literal> keyword is specified, the function is a 
            <literal>void</literal> function. Otherwise it its return type is 
            inferred.</para>
            
            <para>The type of an anonymous function expression is the callable type 
            of the function.</para>
            
            <programlisting>(Value x, Value y) => x&lt;=&gt;y</programlisting>
            
            <programlisting>void (String name) => print(name)</programlisting>
            
            <programlisting>(String string) {
    value mid = string.size % 2;
    return [string[0..mid],string[mid+1...]];
}</programlisting>
            
        </section>
        
    <section id="compoundexpressions">
        <title>Compound expressions</title>
        
        <para>An <emphasis>atom</emphasis> is a literal or self reference, a
        string template, an iterable or tuple enumeration, or a parenthesized 
        expression.</para>
        
        <programlisting>Atom: Literal | StringTemplate | SelfReference | ParExpression | Iterable | Tuple</programlisting>
        
        <para>A <emphasis>primary</emphasis> is formed by recursively forming 
        qualified expression and invocation expression from from an atom or 
        base expression.</para>
        
        <programlisting>Primary: Atom | BaseExpression | QualifiedExpression | Invocation</programlisting>
        
        <para>More complex expressions are formed by combining expressions using 
        operators, including assignment operators, and anonymous functions.</para>    
        
        <programlisting>Expression: Primary | OperatorExpression | Function</programlisting>
        
        <para>Parentheses are used for grouping:</para>
        
        <programlisting>ParExpression: "(" Expression ")"</programlisting>
        
    <section id="receiverexpressions">
        <title>Base expressions and qualified expressions</title>
        
        <para>A <emphasis>base expression</emphasis> is an unqualified 
        identifier, with an optional list of type arguments:</para>
        
        <programlisting>BaseExpression: (MemberName | TypeName) TypeArguments</programlisting>
        
        <para>A base expression is either:</para>
        
        <itemizedlist>
            <listitem>
                <para>a reference to a toplevel function, toplevel value, or 
                toplevel class,</para>
            </listitem>
            <listitem>
                <para>a reference within the lexical scope of the referenced 
                function, value, or class, or</para>
            </listitem>
            <listitem>
                <para>a reference within the body of the referenced function,
                value, or class.</para>
            </listitem>
        </itemizedlist>
        
        <para>If a base expression is a reference to an attribute, method, or 
        member class of a class, the receiving instance is the current instance 
        of that class.</para>
        
        <para>A <emphasis>qualified expression</emphasis> is a <emphasis>receiver
        expression</emphasis>, followed by a <emphasis>member operator</emphasis>,
        followed by an identifier, with an optional list of type arguments.</para>
        
        <programlisting>QualifiedExpression: (Primary ".") (MemberName | TypeName) TypeArguments?</programlisting>
        
        <para>A qualified expression is a reference to a member of a type: an
        attribute, method, or member class.</para>
        
        <para>The receiver expression produces the instance upon which the member 
        is invoked or evaluated. The type of the receiver expression must have a 
        member with the specified name.</para>
        
        <para>When a qualified expression is executed, the receiver expresson is 
        evaluated and then held until the member is invoked or evaluated.</para>
        
    </section>
                
    <section id="attributeandlocalreferences">
            <title>Value references</title>
        
        <para>A <emphasis>value reference</emphasis> is a base expression or 
        qualified expression that references a value declaration.</para>
        
        <para>The type of a value expression for a value of declared type 
        <literal>X</literal> is simply <literal>X</literal>.</para>
        
        <para>A value declaration is never generic, so a value reference never
        has a type argument list.</para>
        
    </section>
    
    <section id="callablereferences">
        <title>Callable references</title>
        
        <para>A <emphasis>callable reference</emphasis> is a base expression or
        qualified expression that references something&mdash;a function or 
        class&mdash;that can be <emphasis>invoked</emphasis> or 
        <emphasis>instantiated</emphasis> by specifying a list of arguments.</para>
        
        <para>A callable reference may be invoked immediately, or it may be passed 
        to other code which may invoke the reference. A callable reference captures 
        the return type and parameter list types of the function or class it refers 
        to, allowing compile-time validation of argument types when the callable 
        reference is invoked.</para>
        
        <para>The type of a callable reference expression is the callable type of
        the referenced function or class.</para>
        
        <para>If a callable reference expression refers to a generic declaration, 
        either:</para>
        
        <itemizedlist>
            <listitem>
                <para>it must be immediately followed by an argument list, 
                allowing the compiler to infer the type arguments, or</para>
            </listitem>
            <listitem>
                <para>it must have an explicit type argument list.</para>
            </listitem>
        </itemizedlist>
                
    </section>
    
    </section>
    
    <section id="invocationexpressions">
        <title>Invocation expressions</title>
        
        <para>A callable object&mdash;any instance of <literal>Callable</literal>&mdash;is 
        <emphasis>invokable</emphasis>. An <emphasis>invocation</emphasis> consists of an 
        <emphasis>invoked expression</emphasis> of type <literal>Callable&lt;R,P&gt;</literal>, 
        together with an argument list and, optionally, an explicit type argument list.</para>
        
        <programlisting>Invocation: Primary Arguments</programlisting>
        
        <para>Any invocation expression where the invoked expression is a callable reference 
        expression is called a <emphasis>direct invocation expression</emphasis> of the 
        function or class.</para> 
        
        <para>In a direct invocation expression:</para>
        
        <itemizedlist>
            <listitem>
                <para>the compiler has one item of additional information about the schema of 
                the method or class that is not reified by the <literal>Callable</literal> 
                interface: the names of the parameters of the function or class, and</para>
            </listitem>
            <listitem>
                <para>type argument inference is possible, since the compiler has access to the 
                type parameters and constraints of the function or class.</para>
            </listitem>
        </itemizedlist>
        
        <para>An invocation expression must specify arguments for parameters of the callable 
        object, either by listing parameter values in order or, in the case of a direct 
        invocation, listing named parameter values.</para>
        
        <programlisting>Arguments: PositionalArguments | NamedArguments</programlisting>
        
        <para>The arguments must conform to the type of the parameter list:</para>
        
        <itemizedlist>
            <listitem>
                <para>For each required parameter, an argument must be given.</para>
            </listitem>
            <listitem>
                <para>For each defaulted parameter, an argument may optionally be 
                given.</para>
            </listitem>
            <listitem>
                <para>If the parameter list has a sequenced parameter, one or more 
                arguments may optionally be given.</para>
            </listitem>
            <listitem>
                <para>No additional arguments may be given.</para>
            </listitem>
            <listitem>
                <para>For a required or defaulted parameter of type <literal>T</literal>, 
                the type of the corresponding argument expression must be assignable to 
                <literal>T</literal>.</para>
            </listitem>
            <listitem>
                <para>For a sequenced parameter of type <literal>T*</literal>, the type 
                of every corresponding argument expression must be assignable to 
                <literal>T</literal>.</para>
            </listitem>
        </itemizedlist>
        
        <para>The type of an invocation expression is simply <literal>R</literal>
        where the invoked expression has type exactly 
        <literal>Callable&lt;R,P&gt;</literal>.</para>
        
        <section id="sequenceinstantiation">
            <title>Sequence instantiation</title>
            
            <para>An instantiation expression for the type <literal>Sequence</literal> may
            be written in an abbreviated form where the type name is eliminated.</para>
        
            <programlisting>SequenceInstantiation: "{" Sequence? "}"</programlisting>
            
            <para>The following expression:</para>
            
            <programlisting>{ "hello", "world" }</programlisting>
            
            <para>Is equivalent to:</para>
            
            <programlisting>Sequence { "hello", "world" }</programlisting>
            
            <para>The type of a sequence instantiation expression is:</para>
            
            <itemizedlist>
                <listitem>
                    <literal>Empty</literal> if there are no argument expressions, or
                </listitem>
                <listitem>
                    <literal>Sequence&lt;X|Y|Z...&gt;</literal> where <literal>X</literal>,
                    <literal>Y</literal>, <literal>Z</literal> are the types of the argument 
                    expressions, otherwise.
                </listitem>
            </itemizedlist>
        
        </section>
        
        <section id="positionalarguments">
            <title>Positional arguments</title>
        
        <para>When arguments are listed, the arguments list is enclosed in parentheses.</para>
            
        <programlisting>PositionalArguments: "(" PositionalArgument ("," PositionalArgument)* ("," Sequence)? | Sequence? ")"</programlisting>
        <programlisting>PositionalArgument: Expression | Function</programlisting>
        
        <para>Positional arguments must be listed in the same order as the corresponding
        parameters.</para>
        
        <itemizedlist>
            <listitem>
                <para>First, an argument of each required parameters must be specified, in the 
                order in which the required parameters were declared. There must be at least as 
                many arguments as required parameters.</para>
            </listitem>
            <listitem>
                <para>Next, arguments of the first arbitrary number of defaulted parameters may 
                be specified, in the order in which the defaulted parameters were declared. If 
                there are fewer arguments than defaulted parameters, the remaining defaulted 
                parameters are assigned their default values.</para>
            </listitem>
            <listitem>
                <para>Finally, if arguments to all defaulted parameters have been specified,
                and if the method declares a sequenced parameter, an arbitrary number of arguments 
                to the sequenced parameter may be specified. 
                </para>
            </listitem>
        </itemizedlist>
        
        <para>For example:</para>
        
        <programlisting>(getProduct(id), 1)</programlisting>
        <programlisting>((Float x, Float y) x+y)</programlisting>
        
        </section>
        
        <section id="namedarguments">
            <title>Named arguments</title>
            
        <para>When arguments are named, the argument list is enclosed in braces.</para>
        
        <programlisting>NamedArguments: "{" NamedArgument* Sequence? "}"</programlisting>
        
        <para>Named arguments may be listed in a different order to the corresponding
        parameters.</para>

        <para>Required and defaulted parameter arguments are specified by name. Arguments to
        a sequenced parameter are specified by listing them, without specifying a name, at the 
        end of the argument list.</para>

        <para>A named argument is either:</para> 
        
        <itemizedlist>
            <listitem>
                <para>a specification statement where the name of the value being specified is
                the parameter name&mdash;it specifies its value using <literal>=</literal>, 
                followed by an expression, and is terminated by a semicolon, or</para>
            </listitem>
            <listitem>
                <para>a local declaration with a getter or named argument list where the name 
                of the local is the parameter name&mdash;it specifies the type of the attribute 
                or <literal>value</literal>, and a block or code or named argument list used to 
                instantiate the return type, or</para>
            </listitem>
            <listitem>
                <para>a local anonymous class declaration where the name of the local is the
                parameter name&mdash;an <literal>object</literal> declaration, or</para>
            </listitem>
            <listitem>
                <para>only for callable parameters, a local method declaration with a block or
                named parameter list where the name of the method is the parameter name&mdash;it 
                specifies the return type or <literal>function</literal>, a parameter list and a 
                block of code or named argument list used to instantiate the return type.</para>
            </listitem>
        </itemizedlist>
        
        <programlisting>NamedArgument: SpecifiedNamedArgument | LocalNamedArgument | FunctionalNamedArgument | Object</programlisting>
        
        <programlisting>SpecifiedNamedArgument: MemberName Specifier ";"</programlisting>
        
        <programlisting>LocalNamedArgument: (UnionType | "value") MemberName (Block | NamedArguments)</programlisting>
        
        <programlisting>FunctionalNamedArgument: (UnionType | "function" | "void") MemberName Params+ (Block | NamedArguments)</programlisting>
        
        <para>For example:</para>
        
        <programlisting>{ 
    product = getProduct(id); 
    quantity = 1; 
}</programlisting>
        
        <programlisting>{
    description = "Total";
    Float amount { 
        variable Float total := 0.0;
        for (Item item in items) {
            sum += item.amount;
        }
        return total;
    }
}</programlisting>
        
        <programlisting>{
    Head head { title="Hello"; }
    Body body {
        Div { "Hello " name "!" }
    }
}</programlisting>

        <programlisting>{
    object iterator 
            satisfies Iterator&lt;Order&gt; {
        head = order;
        tail = null;
    }   
}</programlisting>

        <programlisting>{ 
    label = "Say Hello"; 
    void onClick() { 
        say("Hello"); 
    } 
}</programlisting>
        
        <programlisting>{ 
    Comparison by(Value x, Value y) { 
        return x&lt;=&gt;y; 
    } 
}</programlisting>

        <para>This is simpler using type inference:</para>

        <programlisting>{ 
    function by(Value x, Value y) { 
        return x&lt;=&gt;y; 
    } 
}</programlisting>

        <comment><para>TODO: Should the named argument list be allowed to contain arbitrary 
        statements? This is more regular, since you can do it in the body of a class, and 
        attribute/method refinement is the model that we are following here. And it could be 
        very useful when defining structured data.</para></comment>
        
        <!--comment><para>TODO: Especially, should we support <literal>if/else</literal> and
        <literal>for</literal> in a named argument list. This might be super-useful for
        templating, for example:</para>
        <programlisting>ul { 
    if (error) { 
        color = red;
        li { "oops, something bad happened!" }
    } 
    else { 
        color = yellow;
        for (r in results) {
            li { r.successMessage }
        }
    } 
}</programlisting>
        <para>But the truth is that this would actually be a generally useful part of the 
        expression syntax.</para>
        </comment-->
        
        <comment><para>TODO: Should we let you define a getter/setter pair for parameters 
        which are passed by reference?</para></comment>
        
        </section>

        <section id="sequencedarguments">
            <title>Sequenced and tuple arguments</title>
            
        <para>For a sequenced parameter of type <literal>T...</literal> in a direct 
        invocation expression, there may be either:</para> 
        
        <itemizedlist>
            <listitem>
                <para>multiple arguments separated by commas, or</para>
            </listitem>
            <listitem>
                <para>a single argument followed by an ellipsis.</para>
            </listitem>
        </itemizedlist>

        <para>In the first case, the argument expressions are evaluated and collected into 
        an instance of <literal>Iterable&lt;T&gt;</literal> when the invocation is executed.</para>
                
        <para>In the second case, the single argument expression must be of type 
        <literal>Iterable&lt;T&gt;</literal>, and must be followed by an ellipsis 
        <literal>...</literal>, to indicate that it is <emphasis>not</emphasis> necessary 
        to wrap the value in an <literal>Iterable</literal>.</para>
        
        <para>An argument to a tuple parameter is always a single expression followed by 
        an ellipsis.</para>
                        
        <programlisting>Sequence: Expression ("," Expression)* | Expression "..."</programlisting>
        
        <comment><para>Note: the ellipsis <literal>...</literal> is like the opposite of 
        a sequence instantiation: <literal>{ x... }</literal> means <literal>x</literal>
        and <literal>{ x, y }...</literal> means <literal>x, y</literal>.</para></comment>
        
        <para>For example:</para>
        
        <programlisting>(1, 1, 2, 3, 5, 8)</programlisting>
        <programlisting>(names...)</programlisting>
        <programlisting>(args...)</programlisting>
        
        <para>TODO: syntax for comprehensions.</para>
        
        <comment><para>TODO: Should we let you write <literal>{ x..., y... }</literal> to
        pass the concatenation of two sequences to a sequenced parameter? Or even things
        like <literal>{ x, y... }</literal> and <literal>{ x..., y }</literal>?</para></comment>
                
        <comment><para>TODO: Should we allow an argument to a sequenced parameter in a named
        argument list to be a local declaration, thus allowing the object to be referred to
        later?</para>
            <programlisting>Panel {
    label = "Hello";
    Input i = Input(),
    Button {
        label = "Hello";
        void action() {
            log.info(i.text);
        }
    }
}</programlisting>            
        </comment>
        
        </section>
                    
        <section id="defaultarguments">
            <title>Default arguments</title>
        
        <para>When no argument is assigned to a defaulted parameter by the caller, the 
        default argument defined by the parameter declaration is used. The default argument 
        expression is evaluated every time the method is invoked with no argument specified 
        for the defaulted parameter.</para>
        
        <para>This class:</para>
        
        <programlisting>shared class Counter(Integer initialCount=0) {
    
    variable Integer count := initialCount;
    
    ...
    
}</programlisting>
        
        <para>May be instantiated using any of the following:</para>
        
        <programlisting>Counter()</programlisting>
        <programlisting>Counter(1)</programlisting>
        <programlisting>Counter {}</programlisting>
        <programlisting>Counter { initialCount=10; }</programlisting>
                
            <para>This method:</para>
        
            <programlisting>shared class Counter() {
    
    variable Integer count := 0;
    
    shared void init(Integer initialCount=0) {
        count:=initialCount;
    }
    
    ...

}</programlisting>
            
            <para>May be invoked using any of the following:</para>
        
            <programlisting>counter.init()</programlisting>
            <programlisting>counter.init(1)</programlisting>
            <programlisting>counter.init {}</programlisting>
            <programlisting>counter.init { initialCount=10; }</programlisting>

        </section>
        
    </section>
    
    <section id="evaluationandassignment">
        <title>Evaluation, invocation, and assignment</title>
        
        <para>Evaluation of an expression may result in:</para>
        
        <itemizedlist>
            <listitem><para>invocation of a method or instantiation of a class,</para></listitem>
            <listitem><para>evaluation of an attribute or local, or</para></listitem>
            <listitem><para>assignment to a <literal>variable</literal> attribute or local.</para></listitem>
        </itemizedlist>
        
    <section id="evaluation">
        <title>Evaluation</title>
        
        <para>Evaluation of an attribute reference or local reference produces the current value 
        of the attribute or local.</para> 
        
        <programlisting>String name = person.name;</programlisting>
        
        <para>When a local evaluation is executed, the current value of the local is 
        immediately obtained. The resulting value is the current value of the local.</para>
                
        <para>When an attribute evaluation is executed:</para>
        
        <itemizedlist>
            <listitem>
                <para>first, the reference expression is executed to obtain the reference 
                object, then</para>
            </listitem>
            <listitem>
                <para>the actual member to be invoked is determined by considering the 
                runtime type of the receiving instance, and then</para>
            </listitem>
            <listitem>
                <para>if the member is a simple attribute, the current value of the 
                simple attribute is retrieved from the recieving instance, or</para>
            </listitem>
            <listitem>
                <para>otherwise, execution of the calling context pauses while the body 
                of the attribute getter is executed by the receiving instance, then,</para>
            </listitem>
            <listitem>
                <para>finally, when execution of the getter ends without a thrown 
                exception, execution of the calling context resumes.</para>
            </listitem>
        </itemizedlist>
        
        <para>The resulting value is the current value of the simple attribute or the 
        return value of the attribute getter, as specified by the <literal>return</literal> 
        directive.</para>
        
    </section>
    
    <section id="invocation">
        <title>Invocation</title>
        
        <para>Evaluation of an invocation expression of a callable reference invokes the 
        underlying callable reference. This is called <emphasis>invocation</emphasis> in
        the case of a method reference, and <emphasis>instantiation</emphasis> in the case
        of an initializer reference.</para>
        
        <programlisting>log.info("Hello world!");</programlisting>
        <programlisting>Map&lt;String, Person&gt; map = HashMap&lt;String, Person&gt;(entries);</programlisting>
        
        <para>When an evaluation of an invocation expression of a callable reference is 
        executed:</para>
        
        <itemizedlist>
            <listitem>
                <para>first, the invoked expression is executed to obtain the callable 
                object, then</para>
            </listitem>
            <listitem>
                <para>each argument is evaluated in turn in the calling context, then</para>
            </listitem>
            <listitem>
                <para>the actual member to be invoked is determined by considering the runtime
                type of the receiving instance and the static types of the arguments, and then</para>
            </listitem>
            <listitem>
                <para>execution of the calling context pauses while the body of the method or 
                initializer is executed by the receiving instance with the argument values, 
                then</para>
            </listitem>
            <listitem>
                <para>finally, when execution of the method or initializer ends without a thrown 
                exception, execution of the calling context resumes.</para>
            </listitem>
        </itemizedlist>
        
        <para>A method invocation evaluates to the return value of the method, as specified 
        by the <literal>return</literal> directive. The argument values are passed to the 
        parameters of the method, and the body of the method is executed.</para>
        
        <para>The actual value that invocation of a <literal>void</literal> method returns
        is not specified here. The type system and the definition of the <literal>is</literal> 
        operator ensures that a value of type <literal>Void</literal> can never be narrowed
        to a more specific type.</para>
        
        <para>A class instantiation evaluates to a new instance of the class. The argument 
        values are passed to the initializer parameters of the class, and the initializer
        is executed.</para>
             
    </section>
    
    <section id="assignment">
        <title>Assignment</title>
            
        <para>The assignment operator <literal>:=</literal> assigns a new value to an 
        attribute reference for a <literal>variable</literal> attribute or local.</para>
        
        <programlisting>person.name := "Gavin";</programlisting>
        
        <para>When an attribute or local is assigned:</para>
        
        <itemizedlist>
            <listitem>
                <para>first, the reference expression is executed to obtain the reference 
                object, then</para>
            </listitem>
            <listitem>
                <para>the actual member to be invoked is determined by considering the 
                runtime type of the receiving instance, and then</para>
            </listitem>
            <listitem>
                <para>if the member is a simple attribute or local, the value of the 
                simple attribute of local is set to the new value,</para>
            </listitem>
            <listitem>
                <para>otherwise, execution of the calling context pauses while the body 
                of the attribute setter is executed by the receiving instance with the 
                new value, then,</para>
            </listitem>
            <listitem>
                <para>finally, when execution of the setter ends without a thrown 
                exception, execution of the calling context resumes.</para>
            </listitem>
        </itemizedlist>
        
    </section>
    
    </section>
    
    <!--section id="metamodelreferences">
        <title>Metamodel references</title>
        
        <para>The metamodel object representing a type or program element may be obtained
        using a completely typesafe syntax.</para>
        
        <programlisting>Meta: TypeMeta | MethodMeta | AttributeMeta | FunctionMeta | ValueMeta</programlisting>
        
        <para>Metamodel references are compile-time typesafe.</para>
        
        <programlisting>Type&lt;List&lt;String&gt;&gt; stringListType = List&lt;String&gt;;</programlisting>
        
        <programlisting>Class&lt;Person,Name&gt; personClass = Person;</programlisting>
        
        <programlisting>Method&lt;Log, Void, String&gt; infoMethod = Log.info;</programlisting>
        
        <programlisting>Method&lt;String, Boolean, String&gt; stringSmaller = Comparable&lt;String&gt;.smallerThan;</programlisting>
        
        <programlisting>Attribute&lt;Person, Name&gt; nameAttribute = Person.name;</programlisting>
        
        <para>A metamodel reference that refers to a generic declaration must specify type
        arguments.</para>
        
        <comment><para>Note: this restriction results from the lack of existential types. 
        The expression <literal>Entry</literal> would have the existential type 
        <literal>ClassConstructor&lt;Entry&lt;Key,Item&gt;,Key,Item&gt; given Key satisfies Object given Item satisfies Object</literal>.
        The expression <literal>Comparable.smallerThan</literal> would be of existential type 
        <literal>MethodConstructor&lt;Value,Boolean,Value&gt; given Value satisfies Comparable&lt;Value&gt;</literal>.</para></comment>
        
        <comment><para>TODO: Do we anyway need some kind of metamodel objects for type 
        constructors like <literal>Entry</literal> or even <literal>Comparable.smallerThan</literal>. 
        These would not support typesafe operations, but would at least allow runtime 
        reflection.</para></comment>
        
        <comment><para>TODO: Are there metamodel objects for block local declarations? This
        includes block local declarations inside a class body, and block local declarations
        inside a method or attribute body.</para></comment>
        
        <comment><para>TODO: Should we have typesafe metamodel reference expressions for 
        parameters? For example: <literal>Parameter&lt;String&gt; wordsParam = Person.say#words;</literal></para></comment>
        
        <comment><para>TODO: Should we remodel member metamodel references as members of the 
        metatype? Then we can get rid of two of the following sections. The reason to not do 
        this is that member class metamodel references have the wrong case for an 
        attribute.</para></comment>
        
        <section id="interfaceandclassmetamodelreferences">
            <title>Interface and class metamodel references</title>
            
        <para>A <literal>Type</literal> object may be obtained by specifying the full
        type, including type arguments if the type is generic.</para>
        
        <programlisting>TypeMeta: Type</programlisting>
        
        <para>The metamodel expression, <literal>X</literal>, for a type, class or interface 
        is:</para>
        
        <itemizedlist>
            <listitem>
                <para>of type <literal>Interface&lt;X&gt;</literal> where 
                <literal>X</literal> is the interface, or</para>
            </listitem>
            <listitem>
                <para>assignable to <literal>Class&lt;X,P...&gt;</literal> where 
                <literal>X</literal> is the toplevel <literal>abstract</literal> class and 
                <literal>P...</literal> are the types of the parameter list of the class, 
                or</para>
            </listitem>
            <listitem>
                <para>assignable to <literal>OpenConcreteClass&lt;X,P...&gt;</literal> where 
                <literal>X</literal> is the toplevel concrete class and <literal>P...</literal> 
                are the types of the parameter list of the class, or</para>
            </listitem>
            <listitem>
                <para>assignable to <literal>OpenMemberClass&lt;X,Y,P...&gt;</literal> where 
                <literal>Y</literal> is the member class and <literal>P...</literal> 
                are the types of the parameter list of the class.</para>
            </listitem>
        </itemizedlist>
        
        <para>Note that for a toplevel class <literal>X</literal>, the expression <literal>X</literal>
        is both a metamodel reference and a callable reference. This is consistent, since
        <literal>Class&lt;X,P...&gt;</literal> is a subtype of <literal>Callable&lt;X,P...&gt;</literal>.</para>
        
        <para>Furthermore, the expression type is assignable to all metatypes of the 
        type&mdash;the types listed in the <literal>is</literal> clause of the type 
        definition. <emphasis>(Note that metatypes are a proposed feature for a future 
        version of the language.)</emphasis></para>
        
        </section>
        
        <section id="toplevelmethodmetamodelreferences">
            <title>Toplevel method metamodel references</title>
            
        <para>A <literal>Function</literal> object representing a toplevel method may be 
        obtained by specifying the method name, with type arguments if the toplevel method 
        is generic.</para>
        
        <programlisting>FunctionMeta: MemberName TypeArguments?</programlisting>
               
        <para>The metamodel expression, <literal>method</literal>, for a toplevel method 
        is:</para>
        
        <itemizedlist>
            <listitem>
                <para>assignable to <literal>OpenFunction&lt;R,P...&gt;</literal> where 
                <literal>R</literal> is the callable type of a method produced by 
                removing the first parameter list of the method, and <literal>P...</literal> 
                are the types of the first parameter lists of the method.</para>
            </listitem>
        </itemizedlist>
        
        <para>Note that for a toplevel method <literal>x()</literal>, the expression 
        <literal>x</literal> is both a metamodel reference and a callable reference. This 
        is consistent, since <literal>Function&lt;X,P...&gt;</literal> is a subtype of 
        <literal>Callable&lt;X,P...&gt;</literal>.</para>
           
        </section>
        
        <section id="membermethodmetamodelreferences">
            <title>Member method metamodel references</title>
            
        <para>A <literal>Method</literal> object representing a member method may be 
        obtained by specifying the type (with type arguments) and member name, together 
        with type arguments if the method is generic.</para>
        
        <programlisting>MethodMeta: Type "." MemberName TypeArguments?</programlisting>
               
        <para>The metamodel expression, <literal>X.member</literal>, for a member method 
        is:</para>
        
        <itemizedlist>
            <listitem>
                <para>assignable to <literal>OpenMethod&lt;X,R,P...&gt;</literal> where 
                <literal>X</literal> is the type that defines the method, and 
                <literal>R</literal> is the callable type of a method produced by 
                removing the first parameter list of the method, and 
                <literal>P...</literal> are the types of the first parameter list of 
                the method.</para>
            </listitem>
        </itemizedlist>
         
        </section>
        
        <section id="toplevelattributemetamodelreferences">
            <title>Toplevel attribute metamodel references</title>
            
        <para>A <literal>Value</literal> object representing a toplevel attribute may be 
        obtained by specifying the attribute name, with type arguments if the toplevel method 
        is generic.</para>
        
        <programlisting>ValueMeta: MemberName TypeArguments?</programlisting>
               
        <para>The metamodel expression, <literal>attribute</literal>, for a toplevel attribute 
        is:</para>
        
        <itemizedlist>
            <listitem>
                <para>of type <literal>OpenValue&lt;T&gt;</literal> where 
                <literal>T</literal> is the declared type of the attribute.</para>
            </listitem>
        </itemizedlist>
        
        <para>Note that for a toplevel attribute <literal>x</literal>, the expression <literal>x</literal>
        is both a metamodel reference and a value reference. This is consistent, since
        <literal>Value&lt;T&gt;</literal> is assignable to <literal>Gettable&lt;T&gt;</literal>.</para>
           
        </section>
        
        <section id="attributemetamodelreferences">
            <title>Member attribute metamodel references</title>
            
        <para>An <literal>Attribute</literal> object representing a member attribute may 
        be obtained by specifying the type (with type arguments) and member name.</para>
        
        <programlisting>AttributeMeta: Type "." MemberName</programlisting>

        <para>The metamodel expression, <literal>X.member</literal>, for a member 
        attribute is:</para>
        
        <itemizedlist>
            <listitem>
                <para>of type <literal>OpenAttribute&lt;X,T&gt;</literal> where 
                <literal>X</literal> is the type that defines the attribute, 
                and <literal>T</literal> is the declared type of the attribute,
                unless the attribute is declared <literal>variable</literal>, or</para>
            </listitem>
            <listitem>
                <para>of type <literal>OpenMutableAttribute&lt;X,T&gt;</literal> where 
                <literal>X</literal> is the type that defines the attribute, 
                and <literal>T</literal> is the declared type of the attribute,
                if the attribute is declared <literal>variable</literal>.</para>
            </listitem>
        </itemizedlist>
         
        </section>
        
        <section id="usingthemetamodel">
            <title>Using the metamodel</title>
            
        <para>The metamodel object for a type allows its members to be iterated:</para>
        
        <programlisting><![CDATA[for (Attribute<Value,String> attribute 
            in Value.members(Attribute<Value,String>)) {
    log.info(attribute.declaringType.name + "." + attribute.name 
                + "=" + attribute(obj));
}]]></programlisting>
                
        <para>The metamodel object for a class, attribute or method satisfies 
        <literal>Callable</literal> and is therefore invokable.</para>
        
        <programlisting>Class&lt;ArrayList&lt;String&gt;,String[]&gt; arrayListClass = ArrayList&lt;String&gt;;
        
List list = arrayListClass("foo", "bar", "baz);</programlisting>
        
        <programlisting>Attribute&lt;Person, String&gt; nameAttribute = Person.name;
        
String personName = nameAttribute(person);</programlisting>
        
        <programlisting>Method&lt;Person, String&gt; sayMethod = Person.say;
        
String result = sayMethod(person)();</programlisting>

        <programlisting>MutableAttribute&lt;Counter, Integer&gt; countAttribute = Counter.count;

countAttribute(this)++;</programlisting>        

        <para>The metamodel object for a class, attribute or method supports registration 
        of a listener, which intercepts invocations.</para>
        
        <programlisting>OpenMutableAttribute&lt;Counter, Integer&gt; countAttribute = Counter.count;

countAttribute.intercept() 
    onGet (Counter c, Integer proceed()) {
        log.debug("getting");
        return proceed();
    };
    
countAttribute.intercept() 
    onSet (Counter c, void proceed(Integer n), Integer arg) {
        log.debug("setting");
        proceed(arg);
    };</programlisting>

        <programlisting>OpenMethod&lt;Order,Item,Product,Integer&gt; createItemMethod = Order.createItem;
        
createItemMethod.intercept()
    onInvoke (Order o, Item proceed(Product p, Integer n),  
              Product product, Integer quantity) {
        log.debug("invoking in transaction");
        try (Transaction()) {
            return proceed(product,quantity);
        }
    };</programlisting>
    
        </section>
    
        <comment><para>TODO: According to this, we can "curry" in type arguments of
        the type. We need this. But if so, why can't we curry type arguments of the 
        member? It's not a problem from the grammar point of view.</para></comment>
        
    </section-->

    <section id="operators">
    <title>Operators</title>
    
    <para>Operators are syntactic shorthand for more complex expressions
    involving method invocation or attribute access. Each operator is defined 
    for a particular type. There is no support for user-defined operator 
    <emphasis>overloading</emphasis>. However, the semantics of an operator 
    may be customized by the implementation of the type that the operator
    applies to. This is called <emphasis>operator polymorphism</emphasis>.</para>
    
    <para>Some examples:</para>
    
    <programlisting>Float z = x * y + 1.0;</programlisting>
    
    <programlisting>even := n % 2 &equals; 0;</programlisting>
    
    <programlisting>++count;</programlisting>
    
    <programlisting>Integer j = i++;</programlisting>
    
    <programlisting>if ( x > 100 || x &lt; 0 ) { ... }</programlisting>
    
    <programlisting>User? gavin = users["Gavin"];</programlisting>
    
    <programlisting>List&lt;Item&gt; firstPage = list[0..20];</programlisting>
    
    <programlisting>for (Integer n in 1..10) { ... }</programlisting>
    
    <programlisting>if (char in `A`..`Z`) { ... }</programlisting>
    
    <programlisting>List&lt;Day&gt; nonworkDays = days[{0,7}];</programlisting>
    
    <programlisting>Integer lastIndex = getLastIndex() ? sequence.lastIndex;</programlisting>
    
    <programlisting>log.info("Hello " + $person + "!")</programlisting>
    
    <programlisting>List&lt;String&gt; names = {person1, person2, person3}[].name;</programlisting>
    
    <programlisting>String? name = person?.name;</programlisting>
    
    <programlisting>this.total += item.price;</programlisting>
        
    <programlisting>Float vol = length**3;</programlisting>
    
    <programlisting>map.define(person.name->person);</programlisting>
    
    <programlisting>order.lineItems[index] := LineItem { product = prod; quantity = 1; };</programlisting>
    
    <programlisting>if (!document.internal || user is Employee) { ... }</programlisting>
    
    <para>In all operator expressions, the arguments of the operator must be 
    evaluated from left to right when the expression is executed. In certain cases, 
    depending upon the definition of the operator, evaluation of the leftmost 
    argument expression results in a value that causes the final value of the 
    operator expression to be produced immediately without evaluation of the 
    remaining argument expressions. Optimizations performed by the Ceylon compiler 
    must not alter these behaviours.</para>
    
    <comment><para>TODO: Should we have operators for function composition, or 
    even partial application. Perhaps infix <literal>:</literal> could be 
    composition and postfix <literal>@</literal> could be partial application.</para></comment>
    
    <section id="operatorexpressions">
        <title>Operator expressions</title>
        
        <para>The type of an operator expression for an operator that is defined to
        produce the type <literal>T</literal> is:</para> 
                        
        <itemizedlist>
            <listitem>
                <para><literal>T</literal>, if <literal>T</literal> is assignable
                to <literal>Gettable&lt;Object&gt;</literal>, or, otherwise,</para>
            </listitem>
            <listitem>
                <para><literal>Gettable&lt;T&gt;</literal>.</para>
            </listitem>
        </itemizedlist>
        
    </section>
    
    <section id="operatorprecedence">
        <title>Operator precedence</title>
        
        <para>There are 16 distinct operator precedence levels, but these levels
        are arranged into layers in order to make them easier to predict.</para>
        
        <itemizedlist>
            <listitem><para>Operators in layer 1 produce, transform, and combine
            values.</para></listitem>
            <listitem><para>Operators in layer 2 compare or predicate values, producing
            a <literal>Boolean</literal> result.</para></listitem>
            <listitem><para>Operators in layer 3 are logical operators that operate
            upon <literal>Boolean</literal> arguments to produce a <literal>Boolean</literal>
            value.</para></listitem>
            <listitem><para>Operators in layer 4 perform assignment and conditional
            evaluation.</para></listitem>
        </itemizedlist>
        
        <para>Within each layer, postfix operators have a higher precedence than 
        prefix operators, and prefix operators have a higher precedence than 
        binary operators.</para>
        
        <para>There is a single exception to this principal: the binary 
        exponentiation operator <literal>**</literal> has a higher precedence than 
        the prefix operators <literal>+</literal> and <literal>-</literal>. The 
        reason for this is that the following expressions should be equivalent:</para>
        
        <programlisting>-x**2       //means -(x**2)</programlisting>
        <programlisting>0 - x**2    //means 0 - (x**2)</programlisting>
        
        <para>It's important to be aware that in Ceylon, compared to other C-like 
        languages, the logical not operator <literal>!</literal> has a very low
        precedence. The following expressions are equivalent:</para>
        
        <programlisting>!x.y*2 &equals; 0.0  //means !(x.y*2 &equals; 0.0)</programlisting>
        <programlisting>x.y*2 != 0.0</programlisting>
        
        <para>This table defines the relative precedence of the various operators, 
        from highest to lowest, along with associativity rules:</para>
        
        <table>
        <tgroup cols="4">
            <colspec colnum="1" colwidth="2.5*" align="center" colname="first"/>
            <colspec colnum="2" colwidth="2.0*" align="center"/>
            <colspec colnum="3" colwidth="1.0*" align="center"/>
            <colspec colnum="4" colwidth="0.7*" align="center" colname="last"/>
        <thead>
            <row>
                <entry>Operations</entry>
                <entry>Operators</entry>
                <entry>Type</entry>
                <entry>Associativity</entry>
            </row>
        </thead>
        <tbody>
        
            <row>
                <entry namest="first" nameend="last"><emphasis>Layer 1</emphasis></entry>
            </row>
    
            <row>
                <entry>Member invocation and selection, index, span,
                postfix increment, postfix decrement:</entry>
                <entry>
                <literal>.</literal>,
                <literal>*.</literal>, 
                <literal>?.</literal>, 
                <literal>()</literal>,
                <literal>{}</literal>,
                <literal>[]</literal>,
                <literal>[:]</literal>, 
                <literal>[..]</literal>, 
                <literal>[...]</literal>,
                <literal>++</literal>, 
                <literal>--</literal></entry>
                <entry>Binary / ternary / N-ary / unary postfix</entry>
                <entry>Left</entry>
            </row>
            <row>
                <entry>Prefix increment, prefix decrement:</entry>
                <entry>
                <literal>++</literal>, 
                <literal>--</literal>
                </entry>
                <entry>Unary prefix</entry>
                <entry>Right</entry>
            </row>
            <row>
                <entry>Exponentiation:</entry>
                <entry>
                <literal>^</literal>
                </entry>
                <entry>Binary</entry>
                <entry>Right</entry>
            </row>            
            <row>
                <entry>Negation:</entry>
                <entry>
                <literal>+</literal>,
                <literal>-</literal>
                </entry>
                <entry>Unary prefix</entry>
                <entry>Right</entry>
            </row>
            <row>
                <entry>Default:</entry> 
                <entry><literal>?</literal></entry>
                <entry>Binary</entry>
                <entry>Left</entry>
            </row>
            <row>
                <entry>Multiplication, division, remainder,
                Set intersection:</entry> 
                <entry>
                <literal>*</literal>, 
                <literal>/</literal>, 
                <literal>%</literal>,
                <literal>&amp;</literal>
                </entry>
                <entry>Binary</entry>
                <entry>Left</entry>
            </row>
            <row>
                <entry>Scale:</entry>
                <entry>
                <literal>**</literal>
                </entry>
                <entry>Binary</entry>
                <entry>Right</entry>
            </row>
            <row>
                <entry>Addition, subtraction, Set union,
                Set exclusive union, Set complement:</entry> 
                <entry>
                <literal>+</literal>, 
                <literal>-</literal>, 
                <literal>|</literal>, 
                <literal>^</literal>,
                <literal>~</literal>
                </entry>
                <entry>Binary</entry>
                <entry>Left</entry>
            </row>
            <row>
                <entry>Range and entry construction:</entry> 
                <entry>
                <literal>..</literal>,
                <literal>:</literal>,  
                <literal>-></literal>
                </entry>
                <entry>Binary</entry>
                <entry>None</entry>
            </row>

            <row>
                <entry namest="first" nameend="last"><emphasis>Layer 2</emphasis></entry>
            </row>
    
            <row>
                <entry>Existence, emptiness:</entry>
                <entry><literal>exists</literal>, <literal>nonempty</literal></entry> 
                <entry>Unary postfix</entry>
                <entry>None</entry>
            </row>
            <row>
                <entry>Comparison, containment,
                assignability, inheritance:</entry> 
                <entry>
                <literal>&lt;=&gt;</literal>,
                <literal>&lt;</literal>, 
                <literal>&gt;</literal>, 
                <literal>&lt;=</literal>, 
                <literal>&gt;=</literal>,
                <literal>in</literal>,
                <literal>is</literal>,
                <literal>satisfies</literal>
                </entry>
                <entry>Binary</entry>
                <entry>None</entry>
            </row>
            <row>
                <entry>Equality, identity:</entry>
                <entry>
                <literal>&equals;</literal>, 
                <literal>!=</literal>, 
                <literal>&identical;</literal>
                </entry>
                <entry>Binary</entry>
                <entry>None</entry>
            </row>
        
            <row>
                <entry namest="first" nameend="last"><emphasis>Layer 3</emphasis></entry>
            </row>
    
            <row>
                <entry>Logical not:</entry>
                <entry><literal>!</literal></entry>
                <entry>Unary prefix</entry>
                <entry>Right</entry>
            </row>
            <row>
                <entry>Logical and:</entry> 
                <entry>
                <literal>&amp;&amp;</literal>
                </entry>
                <entry>Binary</entry>
                <entry>Left</entry>
            </row>
            <row>
                <entry>Logical or:</entry>
                <entry>
                <literal>||</literal>
                </entry>
                <entry>Binary</entry>
                <entry>Left</entry>
            </row>
            
            <row>
                <entry namest="first" nameend="last"><emphasis>Layer 4</emphasis></entry>
            </row>
            
            <row>
                <entry>Conditionals:</entry>
                <entry><literal>then</literal>, 
                <literal>else</literal></entry>
                <entry>Binary</entry>
                <entry>Left</entry>
            </row>
    
            <row>
                <entry>Assignment:</entry> 
                <entry>
                <literal>=</literal>, 
                <literal>+=</literal>, 
                <literal>-=</literal>, 
                <literal>*=</literal>, 
                <literal>/=</literal>, 
                <literal>%=</literal>, 
                <literal>&amp;=</literal>, 
                <literal>|=</literal>, 
                <literal>^=</literal>, 
                <literal>~=</literal>, 
                <literal>&amp;&amp;=</literal>, 
                <literal>||=</literal>
                <!--literal>?=</literal-->
                </entry>
                <entry>Binary</entry>
                <entry>Right</entry>
            </row>
            
        </tbody>
        </tgroup>
        </table>

        <comment><para>Note: if we decide to add <literal>&lt;&lt;</literal> and 
        <literal>&gt;&gt;</literal> later, we could give them the same precedence
        as <literal>**</literal>.</para></comment>
    
    </section>
    
    <section id="operatordefinition">
        <title>Operator definition</title>
        
    <para>The following tables define the semantics of the Ceylon operators. 
    There are four basic operators which do not have a definition in terms of 
    other operators or invocations:</para>
    
    <itemizedlist>
        <listitem>
            <para>the <emphasis>member selection</emphasis> operator
            <literal>.</literal> separates the receiver expression and member 
            name in a callable reference expression or attribute reference 
            expression,</para>
        </listitem>
        <listitem>
            <para>the <emphasis>argument specification</emphasis> operators
            <literal>()</literal> and <literal>{}</literal> specify the 
            argument list of an invocation,</para>
        </listitem>
        <listitem>
            <para>the <emphasis>assignment</emphasis> operator
            <literal>:=</literal> assigns a new value to an instance of
            <literal>Settable</literal> and returns the new value after 
            assignment,</para>
        </listitem>
        <!-- 
        <listitem>
            <para>the <emphasis>identity</emphasis> operator
            <literal>&identical;</literal> evaluates to <literal>true</literal> 
            if its argument expressions evaluate to references to the same 
            object, and <literal>false</literal> otherwise, and</para>
        </listitem>
        -->
        <listitem>
            <para>the <emphasis>assignability</emphasis> operator
            <literal>is</literal> evaluates to <literal>true</literal> if 
            its argument expression evaluates to an instance of a class
            assignable to the specified type, and <literal>false</literal> 
            otherwise.</para>
        </listitem>
        <!-- 
        <listitem>
            <para>the <emphasis>existence</emphasis> operator
            <literal>exists</literal> evaluates to <literal>true</literal> if 
            its argument expression evaluates to an instance of 
            <literal>Object</literal>, and <literal>false</literal> 
            otherwise.</para>
        </listitem>
        -->
    </itemizedlist>
        
    <para>All other operators are defined in terms of other operators and/or
    invocations.</para>
    
    <para>In the tables, the following pseudo-code is used, which is not legal
    Ceylon syntax:</para>
    
    <para>First,</para>
    
    <programlisting>if (b) then x else y   //pseudocode</programlisting>
    
    <para>means the value of <literal>result</literal> after execution of the
    following:</para>
    
    <programlisting>X result; if (b) { result=x; } else { result=y; }</programlisting>
    
    <para>Second,</para>
    
    <programlisting>let t=x in y   //pseudocode</programlisting>
    
    <para>means the value of <literal>result</literal> after execution of the
    following:</para>
    
    <programlisting>X t = x; Y result=y;</programlisting>
    
    <para>The tables define semantics only. The compiler is permitted to emit equivalent 
    bytecode that produces the same value as the pseudo-code that defines the operator, 
    without actually executing any invocation, for the following operators:</para>
    
    <itemizedlist>
        <listitem>
            <para>all arithmetic operators,</para>
        </listitem>
        <listitem>
            <para>all <literal>Set</literal> operators,</para>
        </listitem>
        <listitem>
            <para>the comparison and equality operators <literal>&equals;</literal>,
            <literal>!=</literal>, <literal>&lt;=&gt;</literal>, <literal>&lt;</literal>,
            <literal>&gt;</literal>, <literal>&lt;=</literal>, <literal>&gt;=</literal>
            when the argument expression types are built-in numeric types,</para>
        </listitem>
        <listitem>
            <para>the <literal>Range</literal> and <literal>Entry</literal> construction 
            operators <literal>..</literal> and <literal>-></literal>,</para>
        </listitem>
        <listitem>
            <para>the sequence concatenation operator <literal>+</literal>,</para>
        </listitem>
        <listitem>
            <para>the identity equality operator <literal>&identical;</literal>, and</para>
        </listitem>
        <listitem>
            <para>all assignment and compound assignment operators.</para>
        </listitem>
    </itemizedlist>
    
    <para>Therefore, listeners registered for the method invocations and class 
    instantiations that define these operators may not be called when the operator 
    expressions are executed.</para>
    
    </section>
    
    <section id="basic">
    <title>Basic invocation and assignment operators</title>
    
        <para>These operators support method invocation and attribute evaluation and
        assignment.</para>
    
    <table>
    <tgroup cols="6">
        <colspec colnum="1" colwidth="4.5*" align="center" colname="first"/>
        <colspec colnum="2" colwidth="3.0*" align="center"/>
        <colspec colnum="3" colwidth="7.0*" align="center"/>
        <colspec colnum="4" colwidth="4.0*" align="center"/>
        <colspec colnum="5" colwidth="4.0*" align="center"/>
        <colspec colnum="6" colwidth="4.0*" align="center" colname="last"/>
    <thead>
        <row>
            <entry>Example</entry>
            <entry>Name</entry>
            <entry>Definition</entry>
            <entry>LHS type</entry>
            <entry>RHS type</entry>
            <entry>Return type</entry>
        </row>
    </thead>
    <tbody>
    
        <row><entry namest="first" nameend="last"><emphasis>Invocation</emphasis></entry></row>
        
        <row>
            <entry><literal>lhs.member</literal></entry>
            <entry>member</entry>
            <entry></entry>
            <entry><literal>X</literal></entry>
            <entry><literal>Member &lt;X,T&gt;</literal></entry>
            <entry><literal>T</literal></entry>
        </row>
        
        <row>
            <entry><literal>lhs(x,y,z)</literal> or 
            <literal>lhs{a=x;b=y;}</literal></entry>
            <entry>invoke</entry>
            <entry></entry>
            <entry><literal>Callable &lt;T,P...&gt;</literal></entry>
            <entry><literal>P...</literal></entry>
            <entry><literal>T</literal></entry>
        </row>
                
        <row><entry namest="first" nameend="last"><emphasis>Assignment</emphasis></entry></row>
    
        <row>
            <entry><literal>lhs := rhs</literal></entry>
            <entry>assign</entry>
            <entry><literal></literal></entry>
            <entry><literal>Settable&lt;X&gt;</literal></entry>
            <entry><literal>X</literal></entry>
            <entry><literal>X</literal></entry>
        </row>
        
        <!--
        <row><entry namest="first" nameend="last"><emphasis>Format</emphasis></entry></row>
        
        <row>
            <entry><literal>$rhs</literal></entry>
            <entry>format</entry>
            <entry><literal>rhs.formatted</literal></entry>
            <entry></entry>
            <entry><literal>Format</literal></entry>
            <entry><literal>String</literal></entry>
        </row>
        -->
    
        <row><entry namest="first" nameend="last"><emphasis>Compound invocation assignment</emphasis></entry></row>
        
        <row>
            <entry><literal>lhs.=member</literal></entry>
            <entry>follow</entry>
            <entry><literal>lhs:=lhs.member</literal></entry>
            <entry><literal>X</literal></entry>
            <entry><literal>Attribute &lt;X,X&gt;</literal></entry>
            <entry><literal>X</literal></entry>
        </row>

        <row>
            <entry><literal>lhs.=member(x,y,z)</literal></entry>
            <entry>apply</entry>
            <entry><literal>lhs:=lhs.member(x,y,z)</literal></entry>
            <entry><literal>X</literal></entry>
            <entry><literal>Method &lt;X,X,P..&gt;</literal>,
            together with arguments <literal>P...</literal></entry>
            <entry><literal>X</literal></entry>
        </row>

     </tbody>
    </tgroup>
    </table>
        
        <comment><para>TODO: are we really going to add the <literal>.=</literal> operator?</para></comment>
        
        <!--
        <para>Member specification uses one of three different member specification operators:
        <literal>.</literal>, <literal>.?</literal> or <literal>.*</literal>.</para>
        
        <para>The member specification operator depends upon the type of the receiver expression. 
        If <literal>X</literal> is the type that declares the member, the invocation operator must 
        be:</para>
            
        <itemizedlist>
            <listitem>
                <para><literal>.</literal> if the expression is of type <literal>X</literal>,</para>
            </listitem>
            <listitem>
                <para><literal>.?</literal> if the expression is of type <literal>X?</literal>,
                or</para>
            </listitem>
            <listitem>
                <para><literal>.*</literal> if the expression is of type <literal>Iterable&lt;X&gt;</literal>.</para>
            </listitem>
        </itemizedlist>
                
        <para>The type of an invocation (argument specification) expression depends upon the type of 
        the receiver expression:</para>
            
        <itemizedlist>
            <listitem>
                <para><literal>T</literal> if the receiver expression is of type 
                <literal>Callable&lt;T&gt;</literal>,</para>
            </listitem>
            <listitem>
                <para><literal>T?</literal> if the expression is of type 
                <literal>Callable&lt;T&gt;?</literal>,
                or</para>
            </listitem>
            <listitem>
                <para><literal>Sequence&lt;T&gt;</literal> if the expression is of type 
                <literal>Iterable&lt;Callable&lt;T&gt;&gt;</literal>.</para>
            </listitem>
        </itemizedlist>
        
        <para>The arguments specified in the argument specification must be assignable to the
        parameters of the method reference.</para>
        -->
        
    </section>
        
    <section id="equalitycomparison">
    <title>Equality and comparison operators</title>
    
        <para>These operators compare values for equality, order, magnitude, or membership,
        producing boolean values.</para>
    
    <table>
    <tgroup cols="6">
        <colspec colnum="1" colwidth="4.5*" align="center" colname="first"/>
        <colspec colnum="2" colwidth="3.0*" align="center"/>
        <colspec colnum="3" colwidth="7.0*" align="center"/>
        <colspec colnum="4" colwidth="4.0*" align="center"/>
        <colspec colnum="5" colwidth="4.0*" align="center"/>
        <colspec colnum="6" colwidth="4.0*" align="center" colname="last"/>
    <thead>
        <row>
            <entry>Example</entry>
            <entry>Name</entry>
            <entry>Definition</entry>
            <entry>LHS type</entry>
            <entry>RHS type</entry>
            <entry>Return type</entry>
        </row>
    </thead>
    <tbody>
    
        <row><entry namest="first" nameend="last"><emphasis>Equality and identity</emphasis></entry></row>
        
        <row>
            <entry><literal>lhs &identical; rhs</literal></entry>
            <entry>identical</entry>
            <entry><literal>identical(lhs,rhs)</literal></entry>
            <entry><literal>IdentifiableObject</literal></entry>
            <entry><literal>IdentifiableObject</literal></entry>
            <entry><literal>Boolean</literal></entry>
        </row>
        <row>
            <entry><literal>lhs &equals; rhs</literal></entry>
            <entry>equal</entry>
            <entry><literal>lhs.equals(rhs)</literal></entry>
            <entry><literal>Object</literal></entry>
            <entry><literal>Object</literal></entry>
            <entry><literal>Boolean</literal></entry>
        </row>
        <row>
            <entry><literal>lhs != rhs</literal></entry>
            <entry>not equal</entry>
            <entry><literal>!lhs.equals(rhs)</literal></entry>
            <entry><literal>Object</literal></entry>
            <entry><literal>Object</literal></entry>
            <entry><literal>Boolean</literal></entry>
        </row>
        
        <row><entry namest="first" nameend="last"><emphasis>Comparison</emphasis></entry></row>
        
        <row>
            <entry><literal>lhs &lt;=&gt; rhs</literal></entry>
            <entry>compare</entry>
            <entry><literal>lhs.compare(rhs)</literal></entry>
            <entry><literal>Comparable &lt;T&gt;</literal></entry>
            <entry><literal>T</literal></entry>
            <entry><literal>Comparison</literal></entry>
        </row>
        <row>
            <entry><literal>lhs &lt; rhs</literal></entry>
            <entry>smaller</entry>
            <entry><literal>lhs.compare(rhs)==smaller</literal></entry>
            <entry><literal>Comparable &lt;T&gt;</literal></entry>
            <entry><literal>T</literal></entry>
            <entry><literal>Boolean</literal></entry>
        </row>
        <row>
            <entry><literal>lhs &gt; rhs</literal></entry>
            <entry>larger</entry>
            <entry><literal>lhs.compare(rhs)==larger</literal></entry>
            <entry><literal>Comparable &lt;T&gt;</literal></entry>
            <entry><literal>T</literal></entry>
            <entry><literal>Boolean</literal></entry>
        </row>
        <row>
            <entry><literal>lhs &lt;= rhs</literal></entry>
            <entry>small as</entry>
            <entry><literal>lhs.compare(rhs)!=larger</literal></entry>
            <entry><literal>Comparable &lt;T&gt;</literal></entry>
            <entry><literal>T</literal></entry>
            <entry><literal>Boolean</literal></entry>
        </row>
        <row>
            <entry><literal>lhs &gt;= rhs</literal></entry>
            <entry>large as</entry>
            <entry><literal>lhs.compare(rhs)!=smaller</literal></entry>
            <entry><literal>Comparable &lt;T&gt;</literal></entry>
            <entry><literal>T</literal></entry>
            <entry><literal>Boolean</literal></entry>
        </row>
        
        <row><entry namest="first" nameend="last"><emphasis>Containment</emphasis></entry></row>
        
        <row>
            <entry><literal>lhs in rhs</literal></entry>
            <entry>in</entry>
            <entry><literal>let x=lhs in rhs.contains(x)</literal></entry>
            <entry><literal>Object</literal></entry>
            <entry><literal>Category</literal></entry>
            <entry><literal>Boolean</literal></entry>
        </row>
        
        <row><entry namest="first" nameend="last"><emphasis>Assignability</emphasis></entry></row>
        
        <row>
            <entry><literal>is Type rhs</literal></entry>
            <entry>is</entry>
            <entry></entry>
            <entry>any literal type <literal>T</literal></entry>
            <entry>any type which is not a subtype of 
            <literal>T</literal>, whose intersection with 
            <literal>T</literal> is not <literal>Bottom</literal></entry>
            <entry><literal>Boolean</literal></entry>
        </row>
        
        <row><entry namest="first" nameend="last"><emphasis>Inheritance</emphasis></entry></row>
        
        <!--
        <row>
            <entry><literal>lhs extends rhs</literal></entry>
            <entry>extends</entry>
            <entry></entry>
            <entry><literal>Type&lt;Void&gt;</literal></entry>
            <entry><literal>Class &lt;Void&gt;</literal></entry>
            <entry><literal>Boolean</literal></entry>
        </row>
        -->
        
        <row>
            <entry><literal>satisfies Type rhs</literal></entry>
            <entry>satisfies</entry>
            <entry></entry>
            <entry>literal <literal>Type&lt;Void&gt;</literal></entry>
            <entry><literal>Type&lt;Void&gt;</literal></entry>
            <entry><literal>Boolean</literal></entry>
        </row>
        
    </tbody>
    </tgroup>
    </table>
    
        <comment><para>TODO: Should we have allow the operators <literal>&lt;=</literal> 
        and <literal>&gt;=</literal> to handle partial orders? A particular usecase is
        <literal>Set</literal> comparison.</para></comment>
        
    </section>
                
    <section id="logical">
    <title>Logical operators</title>
    
        <para>These are the usual logical operations for boolean values.</para>
    
    <table>
    <tgroup cols="6">
        <colspec colnum="1" colwidth="4.5*" align="center" colname="first"/>
        <colspec colnum="2" colwidth="3.0*" align="center"/>
        <colspec colnum="3" colwidth="7.0*" align="center"/>
        <colspec colnum="4" colwidth="4.0*" align="center"/>
        <colspec colnum="5" colwidth="4.0*" align="center"/>
        <colspec colnum="6" colwidth="4.0*" align="center" colname="last"/>
    <thead>
        <row>
            <entry>Example</entry>
            <entry>Name</entry>
            <entry>Definition</entry>
            <entry>LHS type</entry>
            <entry>RHS type</entry>
            <entry>Return type</entry>
        </row>
    </thead>
    <tbody>
    
        <row><entry namest="first" nameend="last"><emphasis>Logical operators</emphasis></entry></row>
        
        <row>
            <entry><literal>!rhs</literal></entry>
            <entry>not</entry>
            <entry><literal>if (rhs) false else true</literal></entry>
            <entry></entry>
            <entry><literal>Boolean</literal></entry>
            <entry><literal>Boolean</literal></entry>
        </row>
        <row>
            <entry><literal>lhs || rhs</literal></entry>
            <entry>conditional or</entry>
            <entry><literal>if (lhs) true else rhs</literal></entry>
            <entry><literal>Boolean</literal></entry>
            <entry><literal>Boolean</literal></entry>
            <entry><literal>Boolean</literal></entry>
        </row>
        <row>
            <entry><literal>lhs &amp;&amp; rhs</literal></entry>
            <entry>conditional and</entry>
            <entry><literal>if (lhs) rhs else false</literal></entry>
            <entry><literal>Boolean</literal></entry>
            <entry><literal>Boolean</literal></entry>
            <entry><literal>Boolean</literal></entry>
        </row>

        <row><entry namest="first" nameend="last"><emphasis>Logical assignment</emphasis></entry></row>
        
        <row>
            <entry><literal>lhs ||= rhs</literal></entry>
            <entry>conditional or</entry>
            <entry><literal>if (lhs) true else lhs:=rhs</literal></entry>
            <entry><literal>Settable &lt;Boolean&gt;</literal></entry>
            <entry><literal>Boolean</literal></entry>
            <entry><literal>Boolean</literal></entry>
        </row>

        <row>
            <entry><literal>lhs &amp;&amp;= rhs</literal></entry>
            <entry>conditional and</entry>
            <entry><literal>if (lhs) lhs:=rhs else false</literal></entry>
            <entry><literal>Settable &lt;Boolean&gt;</literal></entry>
            <entry><literal>Boolean</literal></entry>
            <entry><literal>Boolean</literal></entry>
        </row>
        
    </tbody>
    </tgroup>
    </table>
    
    </section>
    
    <section id="nullvalues">
    <title>Operators for handling null values</title>
    
        <para>These operators make it easy to work with optional expressions.</para>
    
    <table>
    <tgroup cols="6">
        <colspec colnum="1" colwidth="4.5*" align="center" colname="first"/>
        <colspec colnum="2" colwidth="3.0*" align="center"/>
        <colspec colnum="3" colwidth="7.0*" align="center"/>
        <colspec colnum="4" colwidth="4.0*" align="center"/>
        <colspec colnum="5" colwidth="4.0*" align="center"/>
        <colspec colnum="6" colwidth="4.0*" align="center" colname="last"/>
    <thead>
        <row>
            <entry>Example</entry>
            <entry>Name</entry>
            <entry>Definition</entry>
            <entry>LHS type</entry>
            <entry>RHS type</entry>
            <entry>Return type</entry>
        </row>
    </thead>
    <tbody>
    
        <row><entry namest="first" nameend="last"><emphasis>Existence</emphasis></entry></row>
        
        <row>
            <entry><!--<<literal>lhs?</literal> or --><literal>exists lhs</literal></entry>
            <entry>exists</entry>
            <entry><literal>if (exists lhs) true else false</literal></entry>
            <entry>any type to which <literal>null</literal> is
            assignable, whose intersection with <literal>Object</literal>
            is not <literal>Bottom</literal></entry>
            <entry></entry>
            <entry><literal>Boolean</literal></entry>
        </row>
        <row>
            <entry><literal><!--??-->nonempty lhs</literal></entry>
            <entry>nonempty</entry>
            <entry><literal>if (nonempty lhs) true else false</literal></entry>
            <entry>any subtype of <literal>Nothing|FixedSized&lt;Void&gt;</literal>
            whose intersection with <literal>None&lt;Bottom&gt;</literal> 
            is not <literal>Bottom</literal>, and whose intersection with 
            <literal>Some&lt;Bottom&gt;</literal> is not 
            <literal>Bottom</literal></entry>
            <entry></entry>
            <entry><literal>Boolean</literal></entry>
        </row>
        
        <row><entry namest="first" nameend="last"><emphasis>Default</emphasis></entry></row>
        
        <row>
            <entry><literal>lhs ? rhs</literal></entry>
            <entry>default</entry>
            <entry><literal>if (exists lhs) lhs else rhs</literal></entry>
            <entry><literal>U</literal> such that <literal>null is U</literal></entry>
            <entry><literal>V</literal></entry>
            <entry><literal>U&amp;Object|V</literal></entry>
        </row>
       
        <!--
        <row><entry namest="first" nameend="last"><emphasis>Default assignment</emphasis></entry></row>
        
        <row>
            <entry><literal>lhs ?= rhs</literal></entry>
            <entry>default assignment</entry>
            <entry><literal>if (exists lhs) lhs else lhs:=rhs</literal></entry>
            <entry><literal>Settable&lt;T?&gt;</literal></entry>
            <entry><literal>T</literal> or <literal>T?</literal></entry>
            <entry><literal>T</literal> or <literal>T?</literal></entry>
        </row>
        -->
        
        <row><entry namest="first" nameend="last"><emphasis>Nullsafe invocation</emphasis></entry></row>
        
        <row>
            <entry><literal>lhs?.member</literal></entry>
            <entry>nullsafe attribute</entry>
            <entry><literal>if (exists lhs) lhs.member else null</literal></entry>
            <entry><literal>X?</literal></entry>
            <entry><literal>Attribute &lt;X,T&gt;</literal></entry>
            <entry><literal>T?</literal></entry>
        </row>
        
        <row>
            <entry><literal>lhs?.member</literal></entry>
            <entry>nullsafe method</entry>
            <entry></entry>
            <entry><literal>X?</literal></entry>
            <entry><literal>Method &lt;X,T,P...&gt;</literal></entry>
            <entry><literal>Callable &lt;T?,P...&gt;</literal></entry>
        </row>
        
        <!--row>
            <entry><literal>lhs(x,y,z)</literal> or 
            <literal>lhs{a=x;b=y;}</literal></entry>
            <entry>nullsafe invoke</entry>
            <entry><literal>if (exists lhs) lhs(x,y,z) else null</literal></entry>
            <entry><literal>Callable &lt;T,P...&gt;?</literal></entry>
            <entry><literal>P...</literal></entry>
            <entry><literal>T?</literal></entry>
        </row-->
        
    </tbody>
    </tgroup>
    </table>
    
    </section>

    <section id="listmap">
    <title>Correspondence and sequence operators</title>
    
        <para>These operators provide a simplified syntax for accessing values 
        of a <literal>Correspondence</literal>, and for joining and obtaining
        subranges of <literal>Sequence</literal>s.</para>
    
    <table>
    <tgroup cols="6">
        <colspec colnum="1" colwidth="4.5*" align="center" colname="first"/>
        <colspec colnum="2" colwidth="3.0*" align="center"/>
        <colspec colnum="3" colwidth="7.0*" align="center"/>
        <colspec colnum="4" colwidth="4.0*" align="center"/>
        <colspec colnum="5" colwidth="4.0*" align="center"/>
        <colspec colnum="6" colwidth="4.0*" align="center" colname="last"/>
    <thead>
        <row>
            <entry>Example</entry>
            <entry>Name</entry>
            <entry>Definition</entry>
            <entry>LHS type</entry>
            <entry>RHS type</entry>
            <entry>Return type</entry>
        </row>
    </thead>
    <tbody>
    
        <row><entry namest="first" nameend="last"><emphasis>Keyed item access</emphasis></entry></row>
        
        <row>
            <entry><literal>lhs[index]</literal></entry>
            <entry>lookup</entry>
            <entry><literal>lhs.item(index)</literal></entry>
            <entry><literal>Correspondence&lt;X,Y&gt;</literal></entry>
            <entry><literal>X</literal></entry>
            <entry><literal>Gettable &lt;Y?&gt;</literal></entry>
        </row>
        <row>
            <entry><literal>lhs[index]</literal></entry>
            <entry>lookup</entry>
            <entry><literal>lhs.item(index)</literal></entry>
            <entry><literal>OpenCorrespondence &lt;X,Y&gt;</literal></entry>
            <entry><literal>X</literal></entry>
            <entry><literal>Settable &lt;Y?&gt;</literal></entry>
        </row>
        <!--
        <row>
            <entry><literal>lhs[index]</literal></entry>
            <entry>bounded lookup</entry>
            <entry><literal>lhs.item(index)</literal></entry>
            <entry><literal>Y[n]</literal></entry>
            <entry><literal>Bound&lt;#n&gt;</literal></entry>
            <entry><literal>Gettable &lt;Y&gt;</literal></entry>
        </row>
        <row>
            <entry><literal>lhs[index]</literal></entry>
            <entry>bounded lookup</entry>
            <entry><literal>lhs.item(index)</literal></entry>
            <entry><literal>OpenBoundedSequence &lt;Y,n&gt;</literal></entry>
            <entry><literal>Bound&lt;#n&gt;</literal></entry>
            <entry><literal>Settable &lt;Y&gt;</literal></entry>
        </row>
        -->
        <row>
            <entry><literal>lhs?[index]</literal></entry>
            <entry>nullsafe lookup</entry>
            <entry><literal>if (exists lhs) lhs[index] else null</literal></entry>
            <entry><literal>Correspondence&lt;X,Y&gt;?</literal></entry>
            <entry><literal>X</literal></entry>
            <entry><literal>Y?</literal></entry>
        </row>
        
        <!--
        <row>
            <entry><literal>lhs[indices]</literal></entry>
            <entry>sequenced lookup</entry>
            <entry><literal>lhs.items(index)</literal></entry>
            <entry><literal>Correspondence&lt;X,Y&gt;</literal></entry>
            <entry><literal>X[]</literal></entry>
            <entry><literal>Y[]</literal></entry>
        </row>
        <row>
            <entry><literal>lhs[indices]</literal></entry>
            <entry>iterated lookup</entry>
            <entry><literal>lhs.items(index)</literal></entry>
            <entry><literal>Correspondence&lt;X,Y&gt;</literal></entry>
            <entry><literal>Iterable &lt;X&gt;</literal></entry>
            <entry><literal>Iterable &lt;Y&gt;</literal></entry>
        </row>
        -->
        
        <row><entry namest="first" nameend="last"><emphasis>Spans</emphasis></entry></row>
        
        <row>
            <entry><literal>lhs[from..to]</literal></entry>
            <entry>span</entry>
            <entry><literal>lhs.span(from,to)</literal></entry>
            <entry><literal>Ranged&lt;X,Y&gt;</literal></entry>
            <entry>Two <literal>X</literal> values</entry>
            <entry><literal>Y</literal></entry>
        </row>
        <row>
            <entry><literal>lhs[from...]</literal></entry>
            <entry>upper span</entry>
            <entry><literal>lhs.span(from)</literal></entry>
            <entry><literal>Ranged&lt;X,Y&gt;</literal></entry>
            <entry><literal>X</literal></entry>
            <entry><literal>Y</literal></entry>
        </row>
        <!--
        <row>
            <entry><literal>lhs[...y]</literal></entry>
            <entry>lower range</entry>
            <entry><literal>lhs.range(0,y)</literal></entry>
            <entry><literal>List&lt;X&gt;</literal></entry>
            <entry><literal>Integer</literal></entry>
            <entry><literal>List&lt;X&gt;</literal></entry>
        </row>
        -->
        
        <!--
        <row><entry namest="first" nameend="last"><emphasis>Sequence concatenation</emphasis></entry></row>
        
        <row>
            <entry><literal>lhs + rhs</literal></entry>
            <entry>join</entry>
            <entry><literal>join(lhs, rhs)</literal></entry>
            <entry><literal>X[]</literal></entry>
            <entry><literal>X[]</literal></entry>
            <entry><literal>X[]</literal></entry>
        </row>
        -->
        
        <row><entry namest="first" nameend="last"><emphasis>Spread invocation</emphasis></entry></row>

        <row>
            <entry><literal>lhs[].member</literal></entry>
            <entry>spread attribute</entry>
            <entry><literal>{ for (X x in lhs) x.member }</literal></entry>
            <entry><literal>X[]</literal></entry>
            <entry><literal>Attribute&lt;X,T&gt;</literal></entry>
            <entry><literal>T[]</literal></entry>
        </row>
        
        <row>
            <entry><literal>lhs[].member</literal></entry>
            <entry>spread method</entry>
            <entry></entry>
            <entry><literal>X[]</literal></entry>
            <entry><literal>Method &lt;X,T,P...&gt;</literal></entry>
            <entry><literal>Callable &lt;T[],P...&gt;</literal></entry>
        </row>
        
        <!--row>
            <entry><literal>lhs(x,y,z)</literal> or 
            <literal>lhs{a=x;b=y;}</literal></entry>
            <entry>spread invoke</entry>
            <entry><literal>{ for (C c in lhs) c(x,y,z) }</literal></entry>
            <entry><literal>Callable &lt;T,P...&gt;[]</literal></entry>
            <entry><literal>P...</literal></entry>
            <entry><literal>T[]</literal></entry>
        </row-->
        <!--  
        
        <row><entry namest="first" nameend="last"><emphasis>Shift</emphasis></entry></row>
        
        <row>
            <entry><literal>lhs &lt;&lt; rhs</literal></entry>
            <entry>left shift</entry>
            <entry><literal>lhs.shiftLeft(rhs)</literal></entry>
            <entry><literal>List&lt;X&gt;</literal></entry>
            <entry><literal>Integer</literal></entry>
            <entry><literal>List&lt;X&gt;</literal></entry>
        </row>
        <row>
            <entry><literal>lhs >> rhs</literal></entry>
            <entry>right shift</entry>
            <entry><literal>lhs.shiftRight(rhs)</literal></entry>
            <entry><literal>List&lt;X&gt;</literal></entry>
            <entry><literal>Integer</literal></entry>
            <entry><literal>List&lt;X&gt;</literal></entry>
        </row>
        
        -->
        
        <!--
        <row>
            <entry><literal>lhs * rhs</literal></entry>
            <entry>cartesian product</entry>
            <entry><literal>lhs.product(rhs)</literal></entry>
            <entry><literal>Set&lt;X&gt;</literal></entry>
            <entry><literal>Set&lt;Y&gt;</literal></entry>
            <entry><literal>Set&lt;Pair&lt;X,Y&gt;&gt;</literal></entry>
        </row>
        -->
        
    </tbody>
    </tgroup>
    </table>
    
    <comment><para>TODO: Should <literal>x[i..j]</literal> return the elements
    from <literal>i</literal> to <literal>j-1</literal>, like in most other
    languages?</para></comment>
    
    <!--
    <comment><para>TODO: I'm increasingly warming to the idea of a non-destructive 
    add ("with") operator <literal>@</literal> and <literal>@=</literal>. This is
    an operation that is very efficient for some kinds of data structures (linked lists, 
    etc).</para></comment>
    -->
    
    </section>
    
    <section id="constructors">
    <title>Operators for creating objects</title>
    
        <para>These operators simplify the syntax for creating certain commonly 
        used built-in types.</para>
    
    <table>
    <tgroup cols="6">
        <colspec colnum="1" colwidth="4.5*" align="center" colname="first"/>
        <colspec colnum="2" colwidth="3.0*" align="center"/>
        <colspec colnum="3" colwidth="7.0*" align="center"/>
        <colspec colnum="4" colwidth="4.0*" align="center"/>
        <colspec colnum="5" colwidth="4.0*" align="center"/>
        <colspec colnum="6" colwidth="4.0*" align="center" colname="last"/>
    <thead>
        <row>
            <entry>Example</entry>
            <entry>Name</entry>
            <entry>Definition</entry>
            <entry>LHS type</entry>
            <entry>RHS type</entry>
            <entry>Return type</entry>
        </row>
    </thead>
    <tbody>
    
        <row><entry namest="first" nameend="last"><emphasis>Range and entry constructors</emphasis></entry></row>

        <row>
            <entry><literal>lhs .. rhs</literal></entry>
            <entry>range</entry>
            <entry><literal>Range(lhs, rhs)</literal></entry>
            <entry><literal>T given T satisfies Ordinal &amp; Comparable&lt;T&gt;</literal></entry>
            <entry><literal>T</literal></entry>
            <entry><literal>Range&lt;T&gt;</literal></entry>
        </row>
        
        <row>
            <entry><literal>lhs -> rhs</literal></entry>
            <entry>entry</entry>
            <entry><literal>Entry(lhs, rhs)</literal></entry>
            <entry><literal>U given U satisfies Object</literal></entry>
            <entry><literal>V given V satisfies Object</literal></entry>
            <entry><literal>Entry&lt;U,V&gt;</literal></entry>
        </row>
        
        <!--
        
        <row><entry namest="first" nameend="last"><emphasis>Datetime and interval constructors</emphasis></entry></row>

        <row>
            <entry><literal>lhs @ rhs</literal></entry>
            <entry>datetime</entry>
            <entry><literal>Datetime(lhs, rhs)</literal></entry>
            <entry><literal>Date</literal></entry>
            <entry><literal>Time</literal></entry>
            <entry><literal>Datetime</literal></entry>
        </row>
        
        <row>
            <entry><literal>lhs .. rhs</literal></entry>
            <entry>interval</entry>
            <entry><literal>Interval(lhs, rhs)</literal></entry>
            <entry><literal>T given T satisfies Instant</literal></entry>
            <entry><literal>Instant&lt;T&gt;</literal></entry>
            <entry><literal>Interval&lt;T&gt;</literal></entry>
        </row>
        
        -->
        
    </tbody>
    </tgroup>
    </table>
    
    </section>
    
    <section id="conditionals">
    <title>Conditional operators</title>
    
        <para>Two special operators allow emulation of the famous ternary
        operator of C-like languages.</para>
    
    <table>
    <tgroup cols="6">
        <colspec colnum="1" colwidth="4.5*" align="center" colname="first"/>
        <colspec colnum="2" colwidth="3.0*" align="center"/>
        <colspec colnum="3" colwidth="7.0*" align="center"/>
        <colspec colnum="4" colwidth="4.0*" align="center"/>
        <colspec colnum="5" colwidth="4.0*" align="center"/>
        <colspec colnum="6" colwidth="4.0*" align="center" colname="last"/>
    <thead>
        <row>
            <entry>Example</entry>
            <entry>Name</entry>
            <entry>Definition</entry>
            <entry>LHS type</entry>
            <entry>RHS type</entry>
            <entry>Return type</entry>
        </row>
    </thead>
    <tbody>
    
        <row><entry namest="first" nameend="last"><emphasis>Conditionals</emphasis></entry></row>

        <row>
            <entry><literal>lhs then rhs</literal></entry>
            <entry>then</entry>
            <entry><literal>if (lhs) then rhs else null</literal></entry>
            <entry><literal>Boolean</literal></entry>
            <entry><literal>T given T satisfies Object</literal></entry>
            <entry><literal>T?</literal></entry>
        </row>
        
        <row>
            <entry><literal>lhs else rhs</literal></entry>
            <entry>else</entry>
            <entry><literal>if (exists lhs) then lhs else rhs</literal></entry>
            <entry><literal>U</literal> such that <literal>null is U</literal></entry>
            <entry><literal>V</literal></entry>
            <entry><literal>U&amp;Object|V</literal></entry>
        </row>
        
    </tbody>
    </tgroup>
    </table>
    
    </section>
    
    <section id="arithmetic">
    <title>Arithmetic operators</title>
    
        <para>These are the usual mathematical operations for all kinds of
        numeric values.</para>
    
    <table>
    <tgroup cols="6">
        <colspec colnum="1" colwidth="4.5*" align="center" colname="first"/>
        <colspec colnum="2" colwidth="3.0*" align="center"/>
        <colspec colnum="3" colwidth="7.0*" align="center"/>
        <colspec colnum="4" colwidth="4.0*" align="center"/>
        <colspec colnum="5" colwidth="4.0*" align="center"/>
        <colspec colnum="6" colwidth="4.0*" align="center" colname="last"/>
    <thead>
        <row>
            <entry>Example</entry>
            <entry>Name</entry>
            <entry>Definition</entry>
            <entry>LHS type</entry>
            <entry>RHS type</entry>
            <entry>Return type</entry>
        </row>
    </thead>
    <tbody>
    
        <row><entry namest="first" nameend="last"><emphasis>Increment, decrement</emphasis></entry></row>
        
        <!-- Prefix increment, decrement -->
        
        <row>
            <entry><literal>++rhs</literal></entry>
            <entry>successor</entry>
            <entry><literal>rhs:=rhs.successor</literal></entry>
            <entry></entry>
            <entry><literal>Settable &lt;Ordinal&lt;T&gt;&gt;</literal></entry>
            <entry><literal>T</literal></entry>
        </row>
        <row>
            <entry><literal>--rhs</literal></entry>
            <entry>predecessor</entry>
            <entry><literal>rhs:=rhs.predecessor</literal></entry>
            <entry></entry>
            <entry><literal>Settable &lt;Ordinal&lt;T&gt;&gt;</literal></entry>
            <entry><literal>T</literal></entry>
        </row>
        
        <!-- Postfix increment, decrement -->
        
        <row>
            <entry><literal>lhs++</literal></entry>
            <entry>increment</entry>
            <entry><literal>(++lhs).predecessor</literal></entry>
            <entry><literal>Settable &lt;Ordinal&lt;T&gt;&gt;</literal></entry>
            <entry></entry>
            <entry><literal>T</literal></entry>
        </row>
        <row>
            <entry><literal>lhs--</literal></entry>
            <entry>decrement</entry>
            <entry><literal>(--lhs).successor</literal></entry>
            <entry><literal>Settable &lt;Ordinal&lt;T&gt;&gt;</literal></entry>
            <entry></entry>
            <entry><literal>T</literal></entry>
        </row>
        
        <row><entry namest="first" nameend="last"><emphasis>Numeric operators</emphasis></entry></row>
        
        <!-- Unary positive and negative -->
        
        <row>
            <entry><literal>+rhs</literal></entry>
            <entry></entry>
            <entry><literal>rhs.positiveValue</literal></entry>
            <entry></entry>
            <entry><literal>Invertable &lt;I&gt;</literal></entry>
            <entry><literal>I</literal></entry>
        </row>
        
        <row>
            <entry><literal>-rhs</literal></entry>
            <entry>negation</entry>
            <entry><literal>rhs.negativeValue</literal></entry>
            <entry></entry>
            <entry><literal>Invertable &lt;I&gt;</literal></entry>
            <entry><literal>I</literal></entry>
        </row>
        
        <!-- Numeric -->
        
        <row>
            <entry><literal>lhs + rhs</literal></entry>
            <entry>sum</entry>
            <entry><literal>lhs.castTo&lt;N&gt;() .plus(rhs.castTo&lt;N&gt;())</literal></entry>
            <entry><literal>X satisfies Castable&lt;N&gt; &amp; Summable&lt;X&gt;</literal></entry>
            <entry><literal>Y satisfies Castable&lt;N&gt; &amp; Summable&lt;Y&gt;</literal></entry>
            <entry><literal>N of X|Y</literal></entry>
        </row>
        <row>
            <entry><literal>lhs - rhs</literal></entry>
            <entry>difference</entry>
            <entry><literal>lhs.castTo&lt;N&gt;() .minus(rhs.castTo&lt;N&gt;())</literal></entry>
            <entry><literal>X satisfies Castable&lt;N&gt; &amp; Subtractable&lt;X,I&gt;</literal></entry>
            <entry><literal>Y satisfies Castable&lt;N&gt; &amp; Subtractable&lt;Y,J&gt;</literal></entry>
            <entry><literal>N of I|J</literal></entry>
        </row>
        <row>
            <entry><literal>lhs * rhs</literal></entry>
            <entry>product</entry>
            <entry><literal>lhs.castTo&lt;N&gt;() .times(rhs.castTo&lt;N&gt;())</literal></entry>
            <entry><literal>X satisfies Castable&lt;N&gt; &amp; Numeric&lt;X&gt;</literal></entry>
            <entry><literal>Y satisfies Castable&lt;N&gt; &amp; Numeric&lt;Y&gt;</literal></entry>
            <entry><literal>N of X|Y</literal></entry>
        </row>
        <row>
            <entry><literal>lhs / rhs</literal></entry>
            <entry>quotient</entry>
            <entry><literal>lhs.castTo&lt;N&gt;() .divided(rhs.castTo&lt;N&gt;())</literal></entry>
            <entry><literal>X satisfies Castable&lt;N&gt; &amp; Numeric&lt;X&gt;</literal></entry>
            <entry><literal>Y satisfies Castable&lt;N&gt; &amp; Numeric&lt;Y&gt;</literal></entry>
            <entry><literal>N of X|Y</literal></entry>
        </row>
        <row>
            <entry><literal>lhs % rhs</literal></entry>
            <entry>remainder</entry>
            <entry><literal>lhs.castTo&lt;N&gt;() .remainder(rhs.castTo&lt;N&gt;())</literal></entry>
            <entry><literal>X satisfies Castable&lt;N&gt; &amp; Integral&lt;X&gt;</literal></entry>
            <entry><literal>Y satisfies Castable&lt;N&gt; &amp; Integral&lt;Y&gt;</literal></entry>
            <entry><literal>N of X|Y</literal></entry>
        </row>
        <row>
            <entry><literal>lhs ** rhs</literal></entry>
            <entry>power</entry>
            <entry><literal>lhs .power(rhs.castTo&lt;Y&gt;())</literal></entry>
            <entry><literal>Exponentiable&lt;X,Y&gt;</literal></entry>
            <entry><literal>Castable&lt;Y&gt;</literal></entry>
            <entry><literal>X</literal></entry>
        </row>
        
        <row><entry namest="first" nameend="last"><emphasis>Numeric assignment</emphasis></entry></row>
        
        <row>
            <entry><literal>lhs += rhs</literal></entry>
            <entry>add</entry>
            <entry><literal>lhs:=lhs .plus(rhs.castTo&lt;N&gt;())</literal></entry>
            <entry><literal>Settable &lt;Summable&lt;N&gt;&gt;</literal></entry>
            <entry><literal>Castable&lt;N&gt;</literal></entry>
            <entry><literal>N</literal></entry>
        </row>
        <row>
            <entry><literal>lhs -= rhs</literal></entry>
            <entry>subtract</entry>
            <entry><literal>lhs:=lhs .minus(rhs.castTo&lt;N&gt;())</literal></entry>
            <entry><literal>Settable &lt;Subtractable&lt;N,N&gt;&gt;</literal></entry>
            <entry><literal>Castable&lt;N&gt;</literal></entry>
            <entry><literal>N</literal></entry>
        </row>
        <row>
            <entry><literal>lhs *= rhs</literal></entry>
            <entry>multiply</entry>
            <entry><literal>lhs:=lhs .times(rhs.castTo&lt;N&gt;())</literal></entry>
            <entry><literal>Settable &lt;Numeric&lt;N&gt;&gt;</literal></entry>
            <entry><literal>Castable&lt;N&gt;</literal></entry>
            <entry><literal>N</literal></entry>
        </row>
        <row>
            <entry><literal>lhs /= rhs</literal></entry>
            <entry>divide</entry>
            <entry><literal>lhs:=lhs .divided(rhs.castTo&lt;N&gt;())</literal></entry>
            <entry><literal>Settable &lt;Numeric&lt;N&gt;&gt;</literal></entry>
            <entry><literal>Castable&lt;N&gt;</literal></entry>
            <entry><literal>N</literal></entry>
        </row>
        <row>
            <entry><literal>lhs %= rhs</literal></entry>
            <entry>remainder</entry>
            <entry><literal>lhs:=lhs .remainder(rhs.castTo&lt;N&gt;())</literal></entry>
            <entry><literal>Settable &lt;Integral&lt;N&gt;&gt;</literal></entry>
            <entry><literal>Castable&lt;N&gt;</literal></entry>
            <entry><literal>N</literal></entry>
        </row>
                
    </tbody>
    </tgroup>
    </table>
    
        <!--
        <para>Built-in converters allow for type promotion of numeric values used in 
        expressions. Converters exist for the following numeric types:</para>
        
        <itemizedlist>
            <listitem>
                <para><literal>Integer</literal> to <literal>Integer</literal>,
                <literal>Float</literal>, <literal>Whole</literal> and 
                <literal>Decimal</literal></para>
            </listitem>
            <listitem>
                <para><literal>Integer</literal> to <literal>Float</literal>,
                <literal>Whole</literal> and <literal>Decimal</literal></para>
            </listitem>
            <listitem>
                <para><literal>Float</literal> to <literal>Decimal</literal></para>
            </listitem>
            <listitem>
                <para><literal>Whole</literal> to <literal>Decimal</literal></para>
            </listitem>
        </itemizedlist>
        
        <para>This means that <literal>x + y</literal> is defined for any combination 
        of numeric types <literal>X</literal> and <literal>Y</literal>, except for 
        the combination <literal>Float</literal> and <literal>Whole</literal>, and that
        <literal>x + y</literal> always produces the same value, with the same type, as
        <literal>y + x</literal>.</para>
        -->
        
        <para>Ceylon's numeric type system is designed to accommodate the following
        considerations:</para>
        
        <itemizedlist>
            <listitem>
                <para>The system is extensible and new numeric types may be defined
                by libraries. Numeric types defined by libraries should work the 
                same as built-in numeric types.</para>
            </listitem>
            <listitem>
                <para>Two values of different numeric types should be combinable
                using operators without the need for explicit type conversions, 
                but</para>
            </listitem>
            <listitem>
                <para>implicit type conversions should never lose information
                and</para>
            </listitem>
            <listitem>
                <para>binary operators must be symmetric.</para>
            </listitem>
            <listitem>
                <para>Furthermore, there should be no special cases in the language 
                definition or type checker to accommodate numeric types.</para>
            </listitem>
            <listitem>
                <para>However, it must be possible for the compiler to optimize 
                certain of the built-in numeric types to take advantage of the VM's 
                native support for numeric types.</para>
            </listitem>
            <listitem>
                <para>It is not necessary to encode information about the limits
                of the machine's representation of a numeric value into the type
                system. A single <literal>Integer</literal> class is sufficient
                to represent 32, 64, or 128 bit integer values. A single 
                <literal>Float</literal> class is sufficient to represent single
                and double precision floating point values. It is simply not
                possible for the compiler to detect numeric overflow or loss of
                significant precision.</para>
            </listitem>
        </itemizedlist>
        
    </section>
    
    <section id="sets">
    <title>Set operators</title>
    
        <!--
        <para>The C-style bitwise operators are generalized to apply to other types that 
        are formed from boolean-valued "slots". The interface <literal>Slots</literal> 
        defines the necessary abstraction.</para>
        
        <itemizedlist>
            <listitem>
                <para>The class <literal>Byte</literal> represents a fixed length bit string. 
                In this case, the operators are the standard bitwise operators from other 
                C-like languages.</para>
            </listitem>
            <listitem>
                <para>A <literal>Boolean</literal> can be seen as a bit string of length 
                one, so these operators also apply to <literal>Boolean</literal> values.</para>
            </listitem>
            <listitem>
                <para>A <literal>Set&lt;T&gt;</literal>, together with the <literal>in</literal> 
                operator, may also be viewed in terms of slots, so the operators apply to 
                <literal>Set</literal>s, where <literal>|</literal>, <literal>&amp;</literal>
                and binary <literal>~</literal> are interpreted as set union, intersection 
                and complement operators.</para>
            </listitem>
        </itemizedlist>
        
        <para>Note that in Ceylon these operators have a higher precedence than they have 
        in C or Java. Note also that the built-in numeric types are not bit strings, so 
        explicit conversion to <literal>Bits&lt;#n&gt;</literal> is required before these 
        operators may be applied to a numeric value.</para>
        -->
    
    <para>These operators provide traditional mathematical operations for sets.</para>
    
    <table>
    <tgroup cols="6">
        <colspec colnum="1" colwidth="4.5*" align="center" colname="first"/>
        <colspec colnum="2" colwidth="3.0*" align="center"/>
        <colspec colnum="3" colwidth="7.0*" align="center"/>
        <colspec colnum="4" colwidth="4.0*" align="center"/>
        <colspec colnum="5" colwidth="4.0*" align="center"/>
        <colspec colnum="6" colwidth="4.0*" align="center" colname="last"/>
    <thead>
        <row>
            <entry>Example</entry>
            <entry>Name</entry>
            <entry>Definition</entry>
            <entry>LHS type</entry>
            <entry>RHS type</entry>
            <entry>Return type</entry>
        </row>
    </thead>
    <tbody>
    
        <row><entry namest="first" nameend="last"><emphasis>Set operators</emphasis></entry></row>
        
        <!--
        <row>
            <entry><literal>~rhs</literal></entry>
            <entry>complement</entry>
            <entry><literal>rhs.complement</literal></entry>
            <entry></entry>
            <entry><literal>FixedSlots&lt;B&gt;</literal></entry>
            <entry><literal>B</literal></entry>
        </row>
        -->
        <row>
            <entry><literal>lhs | rhs</literal></entry>
            <entry>union</entry>
            <entry><literal>lhs.union(rhs)</literal></entry>
            <entry><literal>Set&lt;X&gt;</literal></entry>
            <entry><literal>Set&lt;Y&gt;</literal></entry>
            <entry><literal>Set&lt;X|Y&gt;</literal></entry>
        </row>
        <row>
            <entry><literal>lhs &amp; rhs</literal></entry>
            <entry>intersection</entry>
            <entry><literal>lhs.intersection(rhs)</literal></entry>
            <entry><literal>Set&lt;X&gt;</literal></entry>
            <entry><literal>Set&lt;Y&gt;</literal></entry>
            <entry><literal>Set&lt;X&amp;Y&gt;</literal></entry>
        </row>
        <row>
            <entry><literal>lhs ^ rhs</literal></entry>
            <entry>exclusive union</entry>
            <entry><literal>lhs.exclusiveUnion(rhs)</literal></entry>
            <entry><literal>Set&lt;X&gt;</literal></entry>
            <entry><literal>Set&lt;Y&gt;</literal></entry>
            <entry><literal>Set&lt;X|Y&gt;</literal></entry>
        </row>
        <row>
            <entry><literal>lhs ~ rhs</literal></entry>
            <entry>complement</entry>
            <entry><literal>lhs.complement(rhs)</literal></entry>
            <entry><literal>Set&lt;X&gt;</literal></entry>
            <entry><literal>Set&lt;Object&gt;</literal></entry>
            <entry><literal>Set&lt;X&gt;</literal></entry>
        </row>

        
        <row><entry namest="first" nameend="last"><emphasis>Set assignment</emphasis></entry></row>
        
        <row>
            <entry><literal>lhs |= rhs</literal></entry>
            <entry>union</entry>
            <entry><literal>lhs:=lhs|rhs</literal></entry>
            <entry><literal>Settable &lt;Set&lt;X&gt;&gt;</literal></entry>
            <entry><literal>Set&lt;X&gt;</literal></entry>
            <entry><literal>Set&lt;X&gt;</literal></entry>
        </row>
        <row>
            <entry><literal>lhs &amp;= rhs</literal></entry>
            <entry>intersection</entry>
            <entry><literal>lhs:=lhs&amp;rhs</literal></entry>
            <entry><literal>Settable &lt;Set&lt;X&gt;&gt;</literal></entry>
            <entry><literal>Set&lt;Object&gt;</literal></entry>
            <entry><literal>Set&lt;X&gt;</literal></entry>
        </row>
        <row>
            <entry><literal>lhs ^= rhs</literal></entry>
            <entry>exclusive union</entry>
            <entry><literal>lhs:=lhs^rhs</literal></entry>
            <entry><literal>Settable &lt;Set&lt;X&gt;&gt;</literal></entry>
            <entry><literal>Set&lt;X&gt;</literal></entry>
            <entry><literal>Set&lt;X&gt;</literal></entry>
        </row>
        <row>
            <entry><literal>lhs ~= rhs</literal></entry>
            <entry>complement</entry>
            <entry><literal>lhs:=lhs~rhs</literal></entry>
            <entry><literal>Settable &lt;Set&lt;X&gt;&gt;</literal></entry>
            <entry><literal>Set&lt;Object&gt;</literal></entry>
            <entry><literal>Set&lt;X&gt;</literal></entry>
        </row>
        
    </tbody>
    </tgroup>
    </table>
    
        <comment><para>TODO: how can we support the traditional C-style bitwise operators? 
        Abstracting over sets and binary strings is difficult without type constructor 
        parameterization.</para></comment>
    
    </section>
    
    </section>
    
</chapter>
