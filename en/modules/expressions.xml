<chapter id="expressions">
    <title>Expressions</title>
    
    <para>An <emphasis>expression</emphasis> produces a value when executed. An 
    algorithm expressed using functions and expressions, rather than sequences 
    of statements is often easier to understand and refactor. Therefore, Ceylon
    has a highly flexible expressions syntax. Expressions are formed from:</para>
    
    <itemizedlist>
        <listitem>
            <para>literal values and self references,</para>
        </listitem>
        <listitem>
            <para>evaluation and assignment of values,</para>
        </listitem>
        <listitem>
            <para>invocation of functions and instantiation of classes,</para> 
        </listitem>
        <listitem>
            <para>callable references and anonymous functions,</para>
        </listitem>
        <listitem>
            <para>comprehensions,</para>
        </listitem>
        <listitem>
            <para>metamodel references,</para>
        </listitem>
        <listitem>
            <para>enumeration of iterables and tuples, and</para>
        </listitem>
        <listitem>
            <para>operators.</para>
        </listitem>
    </itemizedlist>
    
    <para>Ceylon expressions are validated for typesafety at compile time. To 
    determine whether an expression is assignable to a program element such as 
    an attribute, local, or parameter, Ceylon considers the 
    <emphasis>type</emphasis> of the expression (the type of the objects that 
    are produced when the expression is evaluated). An expression is assignable 
    to a program element if the type of the expression is assignable to the 
    declared type of the program element.</para>
    
    <para>Within a <literal>dynamic</literal> block, an expression may have no 
    type, in the sense that its type can not be determined using static analysis
    of the code.</para>
    
    <section id="literalvalues">
        <title>Literal values</title>
    
    <para>Ceylon supports literal values of the following types:</para>
    
    <itemizedlist>
        <listitem>
            <para><literal>Integer</literal> and <literal>Float</literal>,</para>
        </listitem>
        <listitem>
            <para><literal>Character</literal>, and</para>
        </listitem>
        <listitem>
            <para><literal>String</literal>.</para>
        </listitem>
    </itemizedlist>
    
    <para>The types <literal>Integer</literal>, <literal>Float</literal>, 
    <literal>Character</literal>, and <literal>String</literal> are defined in the 
    module <literal>ceylon.language</literal>.</para>
    
    <comment><para>Note: Ceylon does not need a special syntax for <literal>Boolean</literal> 
    literal values, since <literal>Boolean</literal> is just a class with the cases 
    <literal>true</literal> and <literal>false</literal>. Likewise, <literal>null</literal> 
    is just the singleton value of an anonymous class.</para></comment>
    
    <screen>Literal: IntegerLiteral | FloatLiteral | CharacterLiteral | StringLiteral | VerbatimStringLiteral</screen>
    
    <para>All literal values are instances of immutable types. The value of a literal 
    expression is an instance of the type. How this instance is produced is not specified 
    here.</para>
    
    <!--section id="datetime">
        <title><literal>Date</literal> and <literal>Time</literal> literals</title>
        
        <para>A <literal>Date</literal> literal has the form:</para>
        
        <programlisting>DateLiteral: 
"'" 
Digit{1,2} "/" Digit{1,2} "/" Digit{4} 
"'"</programlisting>
        
        <para>A <literal>Time</literal> literal has the form:</para>
        
        <programlisting>TimeLiteral: 
"'" 
Digit{1,2} ":" Digit{2} ( ":" Digit{2} ( ":" Digit{3} )? )? 
(" " "AM"|"PM")? 
(" " Character{3,4})? 
"'"</programlisting>
        
        <para>For example:</para>
        
        <programlisting>Date date = '25/03/2005';</programlisting>
        <programlisting>Time time = '12:00 AM PST';</programlisting>
        
        <para>A <literal>Datetime</literal> may be composed from a <literal>Date</literal> and 
        a <literal>Time</literal> using the <literal>@</literal> operator.</para>
        
        <programlisting>Datetime datetime = '25/03/2005' @ '12:00 AM PST';</programlisting>
        
        <comment><para>TODO: alternatively, we could follow RFC3339-style datetimes, for example:
        <literal>1996-12-19T16:39:57-08:00</literal>.</para></comment>
        
        <comment><para>TODO: should we allow wildcards and ranges, to get cron-style expressions 
        like <literal>'1/*/*' @ '00:00 GMT'</literal>?</para></comment>
        
        <para>The <literal>..</literal> operator lets us construct intervals:</para>
        
        <programlisting>Interval&lt;Date&gt; timeRange = '0:0:00' .. '12:59:59 PM';</programlisting>
        <programlisting>Interval&lt;Date&gt; dateRange = '1/1/2008' .. '31/12/2007';</programlisting>
        <programlisting>Interval&lt;Datetime&gt; datetimeRange = '1/1/2008' @ '0:0:00' .. '31/12/2007' @ '12:59:59 PM';</programlisting>
        
    </section-->
    
        <!--
        
        <para>The attributes <literal>hours</literal>, <literal>minutes</literal>, <literal>seconds</literal>,
        <literal>years</literal>, <literal>months</literal>, <literal>days</literal>, <literal>weeks</literal>
        of the <literal>Integer</literal> class let us construct durations.</para>
        
        <programlisting>Duration&lt;Time&gt; duration = 12.hours + 34.minutes;</programlisting>
        <programlisting>Duration&lt;Date&gt; duration = 1.year + 2.months + 3.days;</programlisting>
        
        <para>Durations may be composed using the arithmetic operators <literal>+</literal>, 
        <literal>-</literal>, <literal>*</literal> and <literal>/</literal>.</para>
        
        <programlisting>Duration&lt;Time&gt; duration = 1.seconds / 10 - 1.seconds / 1000;</programlisting> 
        
        <para>The methods <literal>before()</literal> and <literal>after()</literal> let us add and
        subtract durations to and from datetimes.</para>
        
        <programlisting>Time time = 10.seconds.before('12:00 AM');</programlisting>
        <programlisting>Date date = 1.week.after('2/9/1974');</programlisting>
        
        -->
        
    <section id="naturalnumber">
        <title>Integer number literals</title>
        
        <para>An integer literal <literal>n</literal> is an 
        expression of type <literal>Integer</literal>.</para>
        
        <programlisting>Integer five = 5;</programlisting>
        <programlisting>Integer mask = $1111_0000;</programlisting>
        <programlisting>Integer white = #FFFF;</programlisting>
                
    </section>
    
    <section id="floatnumber">
        <title>Floating point number literals</title>
        
        <para>A floating point literal is an expression of 
        type <literal>Float</literal>.</para>
        
        <programlisting>shared Float pi = 3.14159;</programlisting>
        
    </section>
    
    <section id="character">
        <title>Character literals</title>
        
        <para>A single character literal is an expression of type 
        <literal>Character</literal>.</para>
                
        <programlisting>if (exists ch=string[i], ch &equals; '+') { ... }</programlisting>
        
    </section>
    
    <section id="string">
        <title>Character string literals</title>
        
        <para>A character string literal is an expression of type
        <literal>String</literal>.</para>
        
        <programlisting>person.name = "Gavin King";</programlisting>
        
        <programlisting>print("Melbourne\tVic\tAustralia\nAtlanta\tGA\tUSA\nGuanajuato\tGto\tMexico\n");</programlisting>
        
        <para>A verbatim string is also an expression of type
        <literal>String</literal>.</para>
        
        <programlisting>String multiline = """A verbatim string can have \ or a " in it."""";</programlisting>
        
    </section>
    
    <!--section id="quoted">
        <title>Single quoted literals</title>
        
        <para>Single-quoted strings are used to express literal values for dates, 
        times, regexes and hexadecimal numbers, and even for more domain-specific 
        things like names, cron expressions, internet addresses, and phone numbers.
        This is an important facility since Ceylon is a language for expressing 
        structured data.</para>
        
        <programlisting>Regex regex = '^\w+@((\w+)\.)+$';</programlisting>
        <programlisting>ph = '+1 (404) 129 3456';</programlisting>
        <programlisting>Duration duration = '1h 30m';</programlisting>
        <programlisting>Datetime dt = Datetime('25/03/2005', '12:00 AM PST');</programlisting>
        <programlisting>Timer { schedule = '0 0 23 ? * MON-FRI'; onTimeout=purge; }.start();</programlisting>
        <programlisting>Text { color = 'FF3B66'; "Hello World!" }</programlisting>
        <programlisting>Link { url = 'http://jboss.org/ceylon'; "Powered by Ceylon" }</programlisting>
        <programlisting>Email { to = 'gavin@hibernate.org'; subject="Ceylon"; text = "Need some help with the compiler?"; }</programlisting>
        
        <para>A single quoted literal may only appear in the following positions:</para>
        
        <itemizedlist>
            <listitem>
                <para>as the right hand side of a specifier for a local or
                attribute with an explicitly declared type, or</para>
            </listitem>
            <listitem>
                <para>as an argument of an invocation or instantiation.</para>
            </listitem>
        </itemizedlist>
        
        <para>In either case:</para>
        
        <itemizedlist>
            <listitem>
                <para>the declared type of the local, attribute, or parameter 
                must be a class or interface annotated <literal>literal</literal>,
                and</para>
            </listitem>
            <listitem>
                <para>the single quoted literal must match the pattern specified
                by the <literal>format</literal> argument of the 
                <literal>literal</literal> annotation.</para>
            </listitem>
        </itemizedlist>
        
        <para>The type of the literal expression is the declared type of the
        local, attribute, or parameter. At runtime, an instance of this type
        is produced by calling the method specified by the <literal>parser</literal>
        argument of the <literal>literal</literal> annotation.</para>
        
        <programlisting>Color parseColor(String literal) { ... }

literal { 
    format = '[0-9A-F]{6}|red|blue|green|yellow|black|white'; 
    parser = parseColor;
}
shared interface Color { ... }</programlisting>
        
        <comment><para>TODO: Single quoted operator literals should come built-in.
        For example: <literal>'+'</literal> and <literal>'&lt;='</literal>.</para></comment>
        
        <comment><para>TODO: we should try to support interpolated expressions, 
        just like we do for string literals.</para></comment>
        
    </section-->

    </section>
    
    <section id="constantexpressions">
        <title>Constant expressions</title>

    <comment><para>TODO: We need a definition of a "constant expression".
    We might use it for:</para>
    <itemizedlist>
    <listitem>annotations available at compile time, and even perhaps</listitem>
    <listitem>initializer/specifier expressions in declaration section of class body.</listitem>
    </itemizedlist>
    <para>For example we could follow Java's very restrictive model, and say 
    that a constant expression must be anything formed from literals, metamodel 
    references, the <literal>..</literal> and <literal>-></literal> operators.
    Or we could be much less restrictive and just say that it is any expression 
    that could be used to initialize a toplevel attribute of the package.</para>
    <para>At the very least, we need to properly define the scope in which the 
    above things are actually evaluated.</para></comment>
    
    </section>
    
    <section id="stringtemplates">
        <title>String templates</title>
        
        <para>A character <emphasis>string template</emphasis> contains interpolated 
        expressions, surrounded by character string fragments.</para>
        
        <screen>StringTemplate: StringStart (ValueExpression StringMid)* ValueExpression StringEnd</screen>
        
        <para>Each interpolated expression contained in the string template must have 
        a type assignable to <literal>Object</literal> defined in 
        <literal>ceylon.language</literal>.</para>
        
        <programlisting>print("Hello, ``person.firstName`` ``person.lastName``, the time is ``Time()``.");</programlisting>
        
        <programlisting>print("1 + 1 = ``1 + 1``");</programlisting>
        
        <para>A string template is an expression of type <literal>String</literal>.</para>
        
        <!--
        <para>An interpolated expression in a string template may invoke or evaluate:</para>
        
        <itemizedlist>
            <listitem>
                <para>any class member that is visible to the containing scope in 
                which the literal appears, and</para>
            </listitem>
            <listitem>
                <para>any non-<literal>variable</literal> local, block local attribute 
                getter or block local method declared earlier within the containing 
                scope.</para>
            </listitem>
        </itemizedlist>
        -->
        
    </section>
    
    <section id="selfreferences">
        <title>Self references and the current package reference</title>
        
        <para>The type of the following expressions depends upon the context in which 
        they appear.</para>
        
        <screen>SelfReference: "this" | "super" | "outer" | "package"</screen>
        
    <section>
        <title><literal>this</literal></title>
            
        <para>The keyword <literal>this</literal> refers to the current instance, 
        and is assignable to the type of the current class or interface (the class 
        or interface in which the expression appears).</para>
        
    </section>
   
    <section>
        <title><literal>outer</literal></title>
            
        <para>The keyword <literal>outer</literal> refers to the current instance
        of the class or interface which immediately contains the current class or 
        interface and is assignable to the type of this containing class or 
        interface.</para>
        
    </section>
                
    <section>
        <title><literal>super</literal></title>
            
        <para>The keyword <literal>super</literal> refers to the current instance 
        (the instance that is being invoked), and has the same members as the 
        immediate superclass of the class, except for <literal>formal</literal> 
        members. Any invocation of this reference is processed by the method or 
        attribute defined or inherited by the superclass, bypassing any method 
        declaration that refines the method on the current class or any subclass 
        of the current class. The <literal>super</literal> reference is not assignable 
        to any type. Nor may not be narrowed to any type using <literal>if (is ...)</literal>.
        There is no <literal>super</literal> reference in an interface member body.</para>
        
        <comment><para>TODO: the syntax for invoking a member of an inherited
        interface is still in flux.</para></comment>
        
    </section>
        
    <section>
        <title><literal>package</literal></title>
        
        <para>The keyword <literal>package</literal> is not an expression, and
        does not have a well-defined type. However, it may be used to qualify 
        and disambiguate a value reference or callable reference. A value
        reference or callable reference qualified by the keyword 
        <literal>package</literal> always refers to a toplevel member of the
        containing package, never to an imported declaration or nested 
        declaration.</para>
        
    </section>
    
    </section>
    
        <section id="anonymousfunctions">
            <title>Anonymous functions</title>
            
            <para>An anonymous function is a function with no name, defined within
            an expression. It comprises one or more parameter lists, followed by an 
            expression.</para>
            
            <screen>FunctionExpression: ("function" | "void")? Parameters+ ("=>" Expression | Block)</screen>
            
            <para>The parameters are the parameters of the function. The lazy 
            specifier or block of code is the implementation of the function. if 
            the <literal>void</literal> keyword is specified, the function is a 
            <literal>void</literal> function. Otherwise it its return type is 
            inferred.</para>
            
            <para>The type of an anonymous function expression is the callable 
            type of the function.</para>
            
            <programlisting>(Value x, Value y) => x&lt;=&gt;y</programlisting>
            
            <programlisting>void (String name) => print(name)</programlisting>
            
            <programlisting>(String string) {
    value mid = string.size % 2;
    return [string[0..mid],string[mid+1...]];
}</programlisting>
            
            <comment><para>Note: there is almost no semantic difference between the
            following function declarations:</para>
            <programlisting>Float f(Float x)(Float y) => x*y;</programlisting>
            <programlisting>Float(Y) f(Float x) => (Float y) => x*y;</programlisting>
            <para>The first form is strongly preferred.</para></comment>
            
        </section>
        
    <section id="compoundexpressions">
        <title>Compound expressions</title>
        
        <para>An <emphasis>atom</emphasis> is a literal or self reference, a
        string template, an iterable or tuple enumeration, or a parenthesized 
        expression.</para>
        
        <screen>Atom: Literal | StringTemplate | SelfReference | GroupedExpression | Iterable | Tuple</screen>
        
        <para>A <emphasis>primary</emphasis> is formed by recursively forming 
        qualified expression and invocation expression from from an atom or 
        base expression.</para>
        
        <screen>Primary: Atom | BaseExpression | QualifiedExpression | Invocation</screen>
        
        <para>More complex expressions are formed by combining expressions using 
        operators, including assignment operators, and anonymous functions.</para>    
        
        <screen>ValueExpression: Primary | OperatorExpression</screen>
        
        <screen>Expression: ValueExpression | FunctionExpression</screen>
        
        <para>Parentheses are used for grouping:</para>
        
        <screen>GroupedExpression: "(" Expression ")"</screen>
        
        <para>A compound expression occurring in a <literal>dynamic</literal> 
        block, and involving a qualified or unqualified reference with no type,
        may also have no type.</para>
        
        <para>In particular, if an operand expression has no type, and the type 
        of the operator expression depends upon the type of the operand, and the 
        operator expression occurs within a <literal>dynamic</literal> block, 
        then the whole operator expression has no type.</para>
        
    <section id="receiverexpressions">
        <title>Base expressions and qualified expressions</title>
        
        <para>A <emphasis>base expression</emphasis> is an unqualified 
        identifier, with an optional list of type arguments:</para>
        
        <screen>BaseExpression: (MemberName | TypeName) TypeArguments</screen>
        
        <para>A base expression is either:</para>
        
        <itemizedlist>
            <listitem>
                <para>a reference to a toplevel function, toplevel value, or 
                toplevel class,</para>
            </listitem>
            <listitem>
                <para>a reference within the lexical scope of the referenced 
                function, value, or class, or</para>
            </listitem>
            <listitem>
                <para>a reference within the body of the referenced function,
                value, or class.</para>
            </listitem>
        </itemizedlist>
        
        <para>If a base expression is a reference to an attribute, method, or 
        member class of a class, the receiving instance is the current instance 
        of that class.</para>
        
        <para>A <emphasis>qualified expression</emphasis> is a <emphasis>receiver
        expression</emphasis>, followed by a <emphasis>member operator</emphasis>,
        followed by an identifier, with an optional list of type arguments.</para>
        
        <screen>QualifiedExpression: (Primary ".") (MemberName | TypeName) TypeArguments?</screen>
        
        <para>A qualified expression is a reference to a member of a type: an
        attribute, method, or member class.</para>
        
        <para>The receiver expression produces the instance upon which the member 
        is invoked or evaluated. The type of the receiver expression must have a 
        member with the specified name.</para>
        
        <para>When a qualified expression is executed, the receiver expresson is 
        evaluated and then held until the member is invoked or evaluated.</para>
        
        <para>If a base expression or qualified expression does not reference any 
        statically typed declaration, and occurs within a <literal>dynamic</literal> 
        block, then it is considered a value reference.</para>
        
    </section>
                
    <section id="attributeandlocalreferences">
            <title>Value references</title>
        
        <para>A <emphasis>value reference</emphasis> is a base expression or 
        qualified expression that references a value declaration.</para>
        
        <para>The type of a value expression for a value of declared type
        <literal>X</literal> is simply <literal>X</literal>.</para>
        
        <para>A value reference which occurs within a <literal>dynamic</literal> 
        block and which does not reference any statically typed declaration
        has no type.</para>
        
        <para>A value declaration is never generic, so a value reference never
        has a type argument list.</para>
        
    </section>
    
    <section id="callablereferences">
        <title>Callable references</title>
        
        <para>A <emphasis>callable reference</emphasis> is a base expression or
        qualified expression that references something&mdash;a function or 
        class&mdash;that can be <emphasis>invoked</emphasis> or 
        <emphasis>instantiated</emphasis> by specifying a list of arguments.</para>
        
        <para>A callable reference may be invoked immediately, or it may be passed 
        to other code which may invoke the reference. A callable reference captures 
        the return type and parameter list types of the function or class it refers 
        to, allowing compile-time validation of argument types when the callable 
        reference is invoked.</para>
        
        <para>The type of a callable reference expression is the callable type of
        the referenced function or class.</para>
        
        <para>If a callable reference expression refers to a generic declaration, 
        either:</para>
        
        <itemizedlist>
            <listitem>
                <para>it must be immediately followed by an argument list, 
                allowing the compiler to infer the type arguments, or</para>
            </listitem>
            <listitem>
                <para>it must have an explicit type argument list.</para>
            </listitem>
        </itemizedlist>
                
    </section>
    
    </section>
    
    <section id="invocationexpressions">
        <title>Invocation expressions</title>
        
        <para>A callable expression&mdash;any expression of type 
        <literal>Callable</literal>&mdash;is <emphasis>invokable</emphasis>. An 
        <emphasis>invocation</emphasis> consists of an <emphasis>invoked expression</emphasis>, 
        together with an argument list and, optionally, an explicit type argument list.</para>
        
        <screen>Invocation: Primary Arguments</screen>
        
        <para>The invoked expression must be of type <literal>Callable&lt;R,P&gt;</literal>.</para>
        
        <para>If the invoked expression has no type, and occurs within a <literal>dynamic</literal> 
        block, then the whole callable expression has no type, and the argument list is not 
        type-checked at compile time.</para>
        
        <para>Any invocation expression where the invoked expression is a callable reference 
        expression is called a <emphasis>direct invocation expression</emphasis> of the 
        function or class.</para> 
        
        <para>In a direct invocation expression:</para>
        
        <itemizedlist>
            <listitem>
                <para>the compiler has one item of additional information about the schema of 
                the method or class that is not reified by the <literal>Callable</literal> 
                interface: the names of the parameters of the function or class, and</para>
            </listitem>
            <listitem>
                <para>type argument inference is possible, since the compiler has access to the 
                type parameters and constraints of the function or class.</para>
            </listitem>
        </itemizedlist>
        
        <para>An invocation expression must specify arguments for parameters of the callable 
        object, either as a positional argument list, or a named argument list.</para>
        
        <screen>Arguments: PositionalArguments | NamedArguments</screen>
        
        <para>The arguments must conform to the type of the parameter list:</para>
        
        <itemizedlist>
            <listitem>
                <para>For each required parameter, an argument must be given.</para>
            </listitem>
            <listitem>
                <para>For each defaulted parameter, an argument may optionally be 
                given.</para>
            </listitem>
            <listitem>
                <para>If the parameter list has a variadic parameter, one or more 
                arguments may optionally be given.</para>
            </listitem>
            <listitem>
                <para>No additional arguments may be given.</para>
            </listitem>
            <listitem>
                <para>For a required or defaulted parameter of type <literal>T</literal>, 
                the type of the corresponding argument expression must be assignable to 
                <literal>T</literal>.</para>
            </listitem>
            <listitem>
                <para>For a variadic parameter of type <literal>T*</literal>, the type 
                of every corresponding argument expression must be assignable to 
                <literal>T</literal>.</para>
            </listitem>
        </itemizedlist>
        
        <para>The type of an invocation expression is simply <literal>R</literal>
        where the invoked expression has type exactly 
        <literal>Callable&lt;R,P&gt;</literal>.</para>
        
        <comment><para>TODO: should we support an infix-operator-style syntax for 
        method invocation like <literal>string split ",;"</literal>.</para></comment>
        
        <section id="tupletypeofarglist">
            <title>The type of a list of arguments</title>
            
            <para>A list of arguments may be formed from:</para>
            
            <itemizedlist>
                <listitem>
                    <para>any number of <emphasis>listed arguments</emphasis>,
                    optionally followed by either</para>
                </listitem>
                <listitem>
                    <para>a <emphasis>spread argument</emphasis>, or</para>
                </listitem>
                <listitem>
                    <para>a <emphasis>comprehension</emphasis>.</para>
                </listitem>
            </itemizedlist>
            
            <screen>ArgumentList: ((ListedArgument ",")* (ListedArgument | SpreadArgument | Comprehension))?</screen>
            
            <para>Every such list of arguments has a type, which captures the types
            of the individual arguments in the list. This type is always a subtype 
            of <literal>Anything[]</literal>. The type of an empty argument list with 
            no arguments is <literal>[]</literal>.</para>
            
        </section>
        
         <section id="defaultarguments">
            <title>Default arguments</title>
        
        <para>When no argument is assigned to a defaulted parameter by the caller, 
        the default argument defined by the parameter declaration is used. The default 
        argument expression is evaluated every time the method is invoked with no 
        argument specified for the defaulted parameter.</para>
        
        <para>This class:</para>
        
        <programlisting>shared class Counter(Integer initialCount=0) { ... }</programlisting>
        
        <para>May be instantiated using any of the following invocations:</para>
        
        <programlisting>Counter()</programlisting>
        <programlisting>Counter(1)</programlisting>
        <programlisting>Counter {}</programlisting>
        <programlisting>Counter { initialCount=10; }</programlisting>
        
        </section>
        
        <section id="listedargs">
            <title>Listed arguments</title>
            
            <para>A listed argument is an expression.</para>
            
            <screen>ListedArgument: Expression</screen>
            
            <para>If a listed argument is an expression of type <literal>T</literal>, 
            and an argument list has type <literal>P</literal>, an invariant subtype of 
            <literal>Sequential&lt;Y&gt;</literal>, then the type of a new argument list 
            formed by prepending the expression to the first parameter list is 
            <literal>Tuple&lt;T|Y,T,P&gt;</literal>.</para>
            
        </section>
        
        <section id="spreadargs">
            <title>Spread arguments</title>
            
            <para>A spread argument is an expression prefixed by the 
            <emphasis>spread operator</emphasis> <literal>*</literal>.</para>
            
            <screen>SpreadArgument: "* "Expression</screen>
            
            <para>The expression type <literal>T</literal> must be an invariant subtype of 
            <literal>{X*}</literal> for some type <literal>X</literal>. We form the
            <emphasis>sequential type of a spread argument</emphasis> as follows:</para>
            
            <itemizedlist>
                <listitem>
                    <para>if the expression type <literal>T</literal> is an invariant 
                    subtype of <literal>X[]</literal>, for some type <literal>X</literal> 
                    then the sequential type of the spread argument is 
                    <literal>T</literal>, or, if not,</para>
                </listitem>
                <listitem>
                    <para>if the expression type <literal>T</literal> is an invariant 
                    subtype of <literal>{X+}</literal>, for some type <literal>X</literal> 
                    then the sequential type of the spread argument is 
                    <literal>{X+]</literal>, or, otherwise,</para>
                </listitem>
                <listitem>
                    <para>the expression type <literal>T</literal> is an invariant 
                    subtype of <literal>{X*}</literal>, for some type <literal>X</literal>
                    and the sequential type of the spread argument is 
                    <literal>X[]</literal>,</para>
                </listitem>
            </itemizedlist>
            
            <para>When a spread argument with an expression type not assignable to 
            <literal>Anything[]</literal> is evaluated, the elements of the iterable
            automatically are packaged into a sequence.</para>
            
            <comment><para>Note: the spread operator is not truly an operator, and so 
            a spread argument is not an expresson. It is more correct to view the spread
            operator as part of the syntax of an argument list.</para></comment>
            
            <para>The type of an argument list containing only a spread argument of 
            sequential type <literal>S</literal> is simply <literal>S</literal>.</para>
            
        </section>
        
        <section id="comprehensions">
            <title>Comprehensions</title>
            
            <para>Every comprehension begins with a <literal>for</literal> clause, 
            and ends with an expression. There may be any number of intervening 
            <literal>for</literal> or <literal>if</literal> clauses.</para>
            
            <screen>Comprehension: ForComprehensionClause</screen>
            <screen>ForComprehensionClause: "for" ForIterator ComprehensionClause</screen>
            <screen>IfComprehensionClause: "if" ConditionList ComprehensionClause</screen>
            <screen>ComprehensionClause: ForComprehensionClause | IfComprehensionClause | Expression</screen>
            
            <para>A child comprehension clause may refer to iteration variables 
            and condition variables declared by outer clauses of the comprehension.</para>
            
            <para>The type of an argument list containing only a comprehension is 
            <literal>[T*]</literal> where <literal>T</literal> is the type of the
            expression which terminates the comprehension, or <literal>[T+]</literal>
            if there are no <literal>if</literal> clauses, and if every 
            <literal>for</literal> clause has an iterated expression of nonempty
            type.</para>
            
            <comment><para>TODO: properly define how expressions with no type occurring in a
            <literal>dynamic</literal> block affect comprehensions.</para></comment>
            
        </section>
        
        <section id="sequenceinstantiation">
            <title>Iterable and tuple enumeration</title>
            
            <para>An <emphasis>enumeration expression</emphasis> is an abbreviation for
            tuple and iterable object instantiation. Iterable enumerations are delimited
            using braces. Tuple enumerations are delimeted by brackets.</para>
            
            <screen>Iterable: "{" ArgumentList "}"</screen>
            <screen>Tuple: "[" ArgumentList "]"</screen>
            
            <para>The type of an iterable enumeration expression is:</para>
            
            <itemizedlist>
                <listitem>
                    <literal>Empty</literal> if there are no argument expressions, or
                </listitem>
                <listitem>
                    <literal>Iterable&lt;U,Nothing&gt;</literal> where <literal>U</literal>,
                    the argument expression list is an invariant suptype of <literal>U[]</literal>.
                </listitem>
            </itemizedlist>
            
            <para>The type of a tuple enumeration expression is the type of the argument 
            list.</para>
            
            <programlisting>{String+} = { "hello", "world" };</programlisting>
            <programlisting>[] none = [];</programlisting>
            <programlisting>[Float,Float] xy = [x, y];</programlisting>
            <programlisting>[Float,Float, String*] xy = [x, y, *labels];</programlisting>
            
            <comment><para>TODO: properly define how expressions with no type occurring in a
            <literal>dynamic</literal> block affect type inference for enumeration expressions.</para></comment>
            
            <comment><para>TODO: the compiler currently supports instantiation of a "dynamic"
            object, that is, an object with no runtime type, using the syntax 
            <literal>value { x=1.0; y=2.0; }</literal>. Bless this here.</para></comment>
            
        </section>
        
        <section id="positionalarguments">
            <title>Positional argument lists</title>
        
        <para>When invocation arguments are listed positionally, the argument list is 
        enclosed in parentheses.</para>
            
        <screen>PositionalArguments: "(" ArgumentList ")"</screen>
        
        <para>The type of the positional argument list is the type of the argument 
        list.</para>
        
        <para>If an invocation is formed from a callable expression of type exactly
        <literal>Callable&lt;R,P&gt;</literal> and a positional argument list of type
        <literal>A</literal>, then <literal>A</literal> must be a subtype of 
        <literal>P</literal>.</para>
        
        <!--para>Positional arguments must be listed in the same order as the corresponding
        parameters.</para>
        
        <itemizedlist>
            <listitem>
                <para>First, an argument of each required parameters must be specified, in the 
                order in which the required parameters were declared. There must be at least as 
                many arguments as required parameters.</para>
            </listitem>
            <listitem>
                <para>Next, arguments of the first arbitrary number of defaulted parameters may 
                be specified, in the order in which the defaulted parameters were declared. If 
                there are fewer arguments than defaulted parameters, the remaining defaulted 
                parameters are assigned their default values.</para>
            </listitem>
            <listitem>
                <para>Finally, if arguments to all defaulted parameters have been specified,
                and if the method declares a variadic parameter, an arbitrary number of arguments 
                to the variadic parameter may be specified. 
                </para>
            </listitem>
        </itemizedlist>
        
        <para>For example:</para>
        
        <programlisting>(getProduct(id), 1)</programlisting>
        <programlisting>((Float x, Float y) => x+y)</programlisting-->
        
        </section>
        
        <section id="namedarguments">
            <title>Named argument lists</title>
            
        <para>When invocation arguments are listed by name, the argument list is enclosed 
        in braces.</para>
        
        <screen>NamedArguments: "{" NamedArgument* ArgumentList "}"</screen>
        
        <para>Named arguments may be listed in a different order to the corresponding
        parameters.</para>
        
        <para>Each named argument in a named argument list is either:</para> 
        
        <itemizedlist>
            <listitem>
                <para>an <emphasis>anonymous argument</emphasis>&mdash;an expression, with
                no parameter name explicitly specified,</para>
            </listitem>
            <listitem>
                <para>a <emphasis>specified argument</emphasis>&mdash;a specification 
                statememt where name of the value of function being specified is interpreted
                as the name of a parameter,</para>
            </listitem>
            <listitem>
                <para>an inline value declaration, whose name is the name of a parameter,</para>
            </listitem>
            <listitem>
                <para>an inline function declaration, whose name is the name of a parameter, 
                or</para>
            </listitem>
            <listitem>
                <para>an inline anonymous class declaration whose name is the name of a 
                parameter.</para>
            </listitem>
        </itemizedlist>
        
        <screen>NamedArgument: AnonymousArgument | SpecifiedArgument | ValueArgument | FunctionArgument | ObjectArgument</screen>
        
        <screen>AnonymousArgument: Expression</screen>
        
        <screen>SpecifiedArgument: Specification</screen>
        
        <screen>ValueArgument: AttributeHeader (Block | (Specifier | LazySpecifier) ";")</screen>
        
        <screen>FunctionArgument: MethodHeader (Block | LazySpecifier ";")</screen>
        
        <screen>ObjectArgument: ObjectHeader ClassBody</screen>
        
        <comment><para>Note: there is an ambiguity here between assignment expressions 
        and specified arguments. This ambiguity is resolved in favor of interpreting the
        argument as a specified argument. Therefore an anonymous argument in a named 
        argument list may not be an assignment expression.</para></comment>
        
        <para>A named argument may not declare type parameters.</para>
        
        <para>For example:</para>
        
        <programlisting>{ 
    product = getProduct(id); 
    quantity = 1; 
}</programlisting>
        
        <programlisting>{
    description = "Total";
    Float amount { 
        variable Float total = 0.0;
        for (Item item in items) {
            sum += item.amount;
        }
        return total;
    }
}</programlisting>
        
        <programlisting>{
    Head { title="Hello"; };
    Body {
        Div { "Hello " name "!" };
    };
}</programlisting>

        <programlisting>{
    object iterator 
            satisfies Iterator&lt;Order&gt; {
        variable value done = false;
        shared actual Order next() {
            if (done) {
                return finished;
            }
            else {
                done=true;
                return order; 
            }
        }
    }   
}</programlisting>

        <programlisting>{ 
    label = "Say Hello"; 
    void onClick() { 
        say("Hello!"); 
    } 
}</programlisting>
        
        <programlisting>{ 
    function by(Value x, Value y) => x&lt;=&gt;y;
}</programlisting>
        
        <para>Additionally, a named argument list has an ordinary list of arguments, 
        which may be empty. These are interpeted as a single argument to a parameter
        of type <literal>Iterable</literal>.</para>
        
        <programlisting>{ initialCapacity=2; "hello", "world" }</programlisting>
        <programlisting>{ initialCapacity=people.size; loadFactor=0.8; for (p in people) p.name->p }</programlisting>

        <para>Given a parameter list, and a named argument list, we may attempt to 
        construct an <emphasis>equivalent positional argument list</emphasis> as 
        follows.</para>
        
        <para>Taking each argument in the named argument list in term, on the order 
        they occur lexically:</para>
        
        <itemizedlist>
            <listitem>
                <para>if the argument is anonymous, assign it to the first unassigned
                parameter of the parameter list,</para>
            </listitem>
            <listitem>
                <para>if the argument is named, assign it to the parameter with that
                name in the parameter list, or</para>
            </listitem>
        </itemizedlist>
        
        <para>If for any argument, there is no unassigned parameter, no parameter with
        the given name, or the parameter with the given name has already been assigned
        an argument, construction of the positional argument list fails, and the 
        invocation is not well-typed.</para>
        
        <para>Next, if the parameter list has an unassigned parameter of type exactly
        <literal>Iterable&lt;T,N&gt;</literal> for some types <literal>T</literal> and
        <literal>N</literal>, then an iterable enumeration expression is formed from 
        the ordinary list of arguments, and assigned to that parameter.</para>
        
        <para>If there is no such parameter, and the the ordinary list of arguments is
        nonempty, then construction of the positional argument list fails, and the 
        invocation is not well-typed.</para>
        
        <para>Finally, we assign each unassigned defaulted parameter its default 
        argument.</para>
        
        <para>The resulting equivalent positional argument list is formed by ordering
        the arguments according to the position of their corresponding parameters in
        the parameter list, and then replacing any inline value, function, or object
        declarations with a reference to the declaration.</para>

        <para>If an invocation is formed from a callable expression of type exactly
        <literal>Callable&lt;R,P&gt;</literal> and a named argument list with an
        equivalent positional argument list of type <literal>A</literal>, then 
        <literal>A</literal> must be a subtype of <literal>P</literal>.</para>
        
        <!--comment><para>TODO: Should the named argument list be allowed to contain arbitrary 
        statements? This is more regular, since you can do it in the body of a class, and 
        attribute/method refinement is the model that we are following here. And it could be 
        very useful when defining structured data.</para></comment-->
        
        <!--comment><para>TODO: Especially, should we support <literal>if/else</literal> and
        <literal>for</literal> in a named argument list. This might be super-useful for
        templating, for example:</para>
        <programlisting>ul { 
    if (error) { 
        color = red;
        li { "oops, something bad happened!" }
    } 
    else { 
        color = yellow;
        for (r in results) {
            li { r.successMessage }
        }
    } 
}</programlisting>
        <para>But the truth is that this would actually be a generally useful part of the 
        expression syntax.</para>
        </comment-->
        
        </section>

        <!--section id="sequencedarguments">
            <title>Sequenced and tuple arguments</title>
            
        <para>For a sequenced parameter of type <literal>T...</literal> in a direct 
        invocation expression, there may be either:</para> 
        
        <itemizedlist>
            <listitem>
                <para>multiple arguments separated by commas, or</para>
            </listitem>
            <listitem>
                <para>a single argument followed by an ellipsis.</para>
            </listitem>
        </itemizedlist>

        <para>In the first case, the argument expressions are evaluated and collected into 
        an instance of <literal>Iterable&lt;T&gt;</literal> when the invocation is executed.</para>
                
        <para>In the second case, the single argument expression must be of type 
        <literal>Iterable&lt;T&gt;</literal>, and must be followed by an ellipsis 
        <literal>...</literal>, to indicate that it is <emphasis>not</emphasis> necessary 
        to wrap the value in an <literal>Iterable</literal>.</para>
        
        <para>An argument to a tuple parameter is always a single expression followed by 
        an ellipsis.</para>
                        
        <screen>Sequence: Expression ("," Expression)* | Expression "..."</screen>
        
        <comment><para>Note: the ellipsis <literal>...</literal> is like the opposite of 
        a sequence instantiation: <literal>{ x... }</literal> means <literal>x</literal>
        and <literal>{ x, y }...</literal> means <literal>x, y</literal>.</para></comment>
        
        <para>For example:</para>
        
        <programlisting>(1, 1, 2, 3, 5, 8)</programlisting>
        <programlisting>(names...)</programlisting>
        <programlisting>(args...)</programlisting>
        
        <para>TODO: syntax for comprehensions.</para>
        
        <comment><para>TODO: Should we let you write <literal>{ x..., y... }</literal> to
        pass the concatenation of two sequences to a sequenced parameter? Or even things
        like <literal>{ x, y... }</literal> and <literal>{ x..., y }</literal>?</para></comment>
                
        <comment><para>TODO: Should we allow an argument to a sequenced parameter in a named
        argument list to be a local declaration, thus allowing the object to be referred to
        later?</para>
            <programlisting>Panel {
    label = "Hello";
    Input i = Input(),
    Button {
        label = "Hello";
        void action() {
            log.info(i.text);
        }
    }
}</programlisting>            
        </comment>
        
        </section-->
                    
    </section>
        
    <!--section id="metamodelreferences">
        <title>Metamodel references</title>
        
        <para>The metamodel object representing a type or program element may be obtained
        using a completely typesafe syntax.</para>
        
        <screen>Meta: TypeMeta | MethodMeta | AttributeMeta | FunctionMeta | ValueMeta</screen>
        
        <para>Metamodel references are compile-time typesafe.</para>
        
        <programlisting>Type&lt;List&lt;String&gt;&gt; stringListType = List&lt;String&gt;;</programlisting>
        
        <programlisting>Class&lt;Person,Name&gt; personClass = Person;</programlisting>
        
        <programlisting>Method&lt;Log, Void, String&gt; infoMethod = Log.info;</programlisting>
        
        <programlisting>Method&lt;String, Boolean, String&gt; stringSmaller = Comparable&lt;String&gt;.smallerThan;</programlisting>
        
        <programlisting>Attribute&lt;Person, Name&gt; nameAttribute = Person.name;</programlisting>
        
        <para>A metamodel reference that refers to a generic declaration must specify type
        arguments.</para>
        
        <comment><para>Note: this restriction results from the lack of existential types. 
        The expression <literal>Entry</literal> would have the existential type 
        <literal>ClassConstructor&lt;Entry&lt;Key,Item&gt;,Key,Item&gt; given Key satisfies Object given Item satisfies Object</literal>.
        The expression <literal>Comparable.smallerThan</literal> would be of existential type 
        <literal>MethodConstructor&lt;Value,Boolean,Value&gt; given Value satisfies Comparable&lt;Value&gt;</literal>.</para></comment>
        
        <comment><para>TODO: Do we anyway need some kind of metamodel objects for type 
        constructors like <literal>Entry</literal> or even <literal>Comparable.smallerThan</literal>. 
        These would not support typesafe operations, but would at least allow runtime 
        reflection.</para></comment>
        
        <comment><para>TODO: Are there metamodel objects for block local declarations? This
        includes block local declarations inside a class body, and block local declarations
        inside a method or attribute body.</para></comment>
        
        <comment><para>TODO: Should we have typesafe metamodel reference expressions for 
        parameters? For example: <literal>Parameter&lt;String&gt; wordsParam = Person.say#words;</literal></para></comment>
        
        <comment><para>TODO: Should we remodel member metamodel references as members of the 
        metatype? Then we can get rid of two of the following sections. The reason to not do 
        this is that member class metamodel references have the wrong case for an 
        attribute.</para></comment>
        
        <section id="interfaceandclassmetamodelreferences">
            <title>Interface and class metamodel references</title>
            
        <para>A <literal>Type</literal> object may be obtained by specifying the full
        type, including type arguments if the type is generic.</para>
        
        <screen>TypeMeta: Type</screen>
        
        <para>The metamodel expression, <literal>X</literal>, for a type, class or interface 
        is:</para>
        
        <itemizedlist>
            <listitem>
                <para>of type <literal>Interface&lt;X&gt;</literal> where 
                <literal>X</literal> is the interface, or</para>
            </listitem>
            <listitem>
                <para>assignable to <literal>Class&lt;X,P...&gt;</literal> where 
                <literal>X</literal> is the toplevel <literal>abstract</literal> class and 
                <literal>P...</literal> are the types of the parameter list of the class, 
                or</para>
            </listitem>
            <listitem>
                <para>assignable to <literal>OpenConcreteClass&lt;X,P...&gt;</literal> where 
                <literal>X</literal> is the toplevel concrete class and <literal>P...</literal> 
                are the types of the parameter list of the class, or</para>
            </listitem>
            <listitem>
                <para>assignable to <literal>OpenMemberClass&lt;X,Y,P...&gt;</literal> where 
                <literal>Y</literal> is the member class and <literal>P...</literal> 
                are the types of the parameter list of the class.</para>
            </listitem>
        </itemizedlist>
        
        <para>Note that for a toplevel class <literal>X</literal>, the expression <literal>X</literal>
        is both a metamodel reference and a callable reference. This is consistent, since
        <literal>Class&lt;X,P...&gt;</literal> is a subtype of <literal>Callable&lt;X,P...&gt;</literal>.</para>
        
        <para>Furthermore, the expression type is assignable to all metatypes of the 
        type&mdash;the types listed in the <literal>is</literal> clause of the type 
        definition. <emphasis>(Note that metatypes are a proposed feature for a future 
        version of the language.)</emphasis></para>
        
        </section>
        
        <section id="toplevelmethodmetamodelreferences">
            <title>Toplevel method metamodel references</title>
            
        <para>A <literal>Function</literal> object representing a toplevel method may be 
        obtained by specifying the method name, with type arguments if the toplevel method 
        is generic.</para>
        
        <screen>FunctionMeta: MemberName TypeArguments?</screen>
               
        <para>The metamodel expression, <literal>method</literal>, for a toplevel method 
        is:</para>
        
        <itemizedlist>
            <listitem>
                <para>assignable to <literal>OpenFunction&lt;R,P...&gt;</literal> where 
                <literal>R</literal> is the callable type of a method produced by 
                removing the first parameter list of the method, and <literal>P...</literal> 
                are the types of the first parameter lists of the method.</para>
            </listitem>
        </itemizedlist>
        
        <para>Note that for a toplevel method <literal>x()</literal>, the expression 
        <literal>x</literal> is both a metamodel reference and a callable reference. This 
        is consistent, since <literal>Function&lt;X,P...&gt;</literal> is a subtype of 
        <literal>Callable&lt;X,P...&gt;</literal>.</para>
           
        </section>
        
        <section id="membermethodmetamodelreferences">
            <title>Member method metamodel references</title>
            
        <para>A <literal>Method</literal> object representing a member method may be 
        obtained by specifying the type (with type arguments) and member name, together 
        with type arguments if the method is generic.</para>
        
        <screen>MethodMeta: Type "." MemberName TypeArguments?</screen>
               
        <para>The metamodel expression, <literal>X.member</literal>, for a member method 
        is:</para>
        
        <itemizedlist>
            <listitem>
                <para>assignable to <literal>OpenMethod&lt;X,R,P...&gt;</literal> where 
                <literal>X</literal> is the type that defines the method, and 
                <literal>R</literal> is the callable type of a method produced by 
                removing the first parameter list of the method, and 
                <literal>P...</literal> are the types of the first parameter list of 
                the method.</para>
            </listitem>
        </itemizedlist>
         
        </section>
        
        <section id="toplevelattributemetamodelreferences">
            <title>Toplevel attribute metamodel references</title>
            
        <para>A <literal>Value</literal> object representing a toplevel attribute may be 
        obtained by specifying the attribute name, with type arguments if the toplevel method 
        is generic.</para>
        
        <screen>ValueMeta: MemberName TypeArguments?</screen>
               
        <para>The metamodel expression, <literal>attribute</literal>, for a toplevel attribute 
        is:</para>
        
        <itemizedlist>
            <listitem>
                <para>of type <literal>OpenValue&lt;T&gt;</literal> where 
                <literal>T</literal> is the declared type of the attribute.</para>
            </listitem>
        </itemizedlist>
        
        <para>Note that for a toplevel attribute <literal>x</literal>, the expression <literal>x</literal>
        is both a metamodel reference and a value reference. This is consistent, since
        <literal>Value&lt;T&gt;</literal> is assignable to <literal>Gettable&lt;T&gt;</literal>.</para>
           
        </section>
        
        <section id="attributemetamodelreferences">
            <title>Member attribute metamodel references</title>
            
        <para>An <literal>Attribute</literal> object representing a member attribute may 
        be obtained by specifying the type (with type arguments) and member name.</para>
        
        <screen>AttributeMeta: Type "." MemberName</screen>

        <para>The metamodel expression, <literal>X.member</literal>, for a member 
        attribute is:</para>
        
        <itemizedlist>
            <listitem>
                <para>of type <literal>OpenAttribute&lt;X,T&gt;</literal> where 
                <literal>X</literal> is the type that defines the attribute, 
                and <literal>T</literal> is the declared type of the attribute,
                unless the attribute is declared <literal>variable</literal>, or</para>
            </listitem>
            <listitem>
                <para>of type <literal>OpenMutableAttribute&lt;X,T&gt;</literal> where 
                <literal>X</literal> is the type that defines the attribute, 
                and <literal>T</literal> is the declared type of the attribute,
                if the attribute is declared <literal>variable</literal>.</para>
            </listitem>
        </itemizedlist>
         
        </section>
        
        <section id="usingthemetamodel">
            <title>Using the metamodel</title>
            
        <para>The metamodel object for a type allows its members to be iterated:</para>
        
        <programlisting><![CDATA[for (Attribute<Value,String> attribute 
            in Value.members(Attribute<Value,String>)) {
    log.info(attribute.declaringType.name + "." + attribute.name 
                + "=" + attribute(obj));
}]]></programlisting>
                
        <para>The metamodel object for a class, attribute or method satisfies 
        <literal>Callable</literal> and is therefore invokable.</para>
        
        <programlisting>Class&lt;ArrayList&lt;String&gt;,String[]&gt; arrayListClass = ArrayList&lt;String&gt;;
        
List list = arrayListClass("foo", "bar", "baz);</programlisting>
        
        <programlisting>Attribute&lt;Person, String&gt; nameAttribute = Person.name;
        
String personName = nameAttribute(person);</programlisting>
        
        <programlisting>Method&lt;Person, String&gt; sayMethod = Person.say;
        
String result = sayMethod(person)();</programlisting>

        <programlisting>MutableAttribute&lt;Counter, Integer&gt; countAttribute = Counter.count;

countAttribute(this)++;</programlisting>        

        <para>The metamodel object for a class, attribute or method supports registration 
        of a listener, which intercepts invocations.</para>
        
        <programlisting>OpenMutableAttribute&lt;Counter, Integer&gt; countAttribute = Counter.count;

countAttribute.intercept() 
    onGet (Counter c, Integer proceed()) {
        log.debug("getting");
        return proceed();
    };
    
countAttribute.intercept() 
    onSet (Counter c, void proceed(Integer n), Integer arg) {
        log.debug("setting");
        proceed(arg);
    };</programlisting>

        <programlisting>OpenMethod&lt;Order,Item,Product,Integer&gt; createItemMethod = Order.createItem;
        
createItemMethod.intercept()
    onInvoke (Order o, Item proceed(Product p, Integer n),  
              Product product, Integer quantity) {
        log.debug("invoking in transaction");
        try (Transaction()) {
            return proceed(product,quantity);
        }
    };</programlisting>
    
        </section>
    
        <comment><para>TODO: According to this, we can "curry" in type arguments of
        the type. We need this. But if so, why can't we curry type arguments of the 
        member? It's not a problem from the grammar point of view.</para></comment>
        
    </section-->
    
    <section id="miscexpressions">
        <title>Conditional expressions and anonymous class expressions</title>
        
        <para>A <emphasis>conditional expression</emphasis> resembles a control 
        structure but is part of the expression syntax, and evaluates to a value.</para> 
        
        <para>An <emphasis>inline class</emphasis> is an anonymous class defined 
        within an expression.</para>
        
        <section>
            <title>Inline conditional expressions</title>
         
            <comment>
            <para>We plan to support inline <literal>if/then/else</literal> conditional 
            expressions, for example:</para>
            <programlisting>Integer port = if (exists setting = process.propertyValue("port")) 
                        then parseInteger(setting) else 8080;</programlisting>
            <para>Note that this is more powerful than the <literal>then</literal> and
            <literal>else</literal> operators because it allows all kinds of conditions,
            not only boolean conditions.</para>
            <para>Should we also support:</para>
            <itemizedlist>
                <listitem>
                    <para>inline <literal>switch/case/else</literal> conditional 
                    expressions, or even</para>
                </listitem>
                <listitem>
                    <para>inline <literal>try/catch</literal> exceptional conditions?</para>
                </listitem>
            </itemizedlist>
            </comment>
        
        </section>
        
        <section>
            <title>Inline anonymous class expressions</title>
            
            <comment>
            <para>Should we support inline <literal>object</literal> declarations, for 
            example:</para>
            <programlisting>iterator => object satisfies Iterable&lt;Nothing&gt; { next() => finished; }</programlisting>
            <para>Or, alternatively, a kind of named argument ""instantiation" syntax for
            interfaces and abstract classes:</para>
            <programlisting>iterator => Iterable { next() => finished; }</programlisting>
            <para>The first option is more flexible, but also more verbose. The second is
            streamlined for the common case and might even be able to do type argument
            inference as shown here.</para> 
            
            <para>If we go with the first option, should we support inline <literal>class</literal> 
            declarations? This would be like an inline <literal>object</literal> and an 
            anonymous function rolled into one. We could even support <literal>class</literal>
            arguments in named argument lists.</para>
            </comment>
        
        </section>
        
   </section>

    <section id="operators">
    <title>Operators</title>
    
    <para>Operators are syntactic shorthand for more complex expressions involving 
    invocation, evaluation, or instantiation. There is no support for user-defined 
    <emphasis>operator overloading</emphasis>:</para> 
    
    <itemizedlist>
        <listitem>
            <para>new operator symbols may not be defined outside of the operators
            specified below, and</para>
        </listitem>
        <listitem>
            <para>the definition of the operators specified below may not be changed 
            or overloaded.</para>
        </listitem>
    </itemizedlist>
    
    <para>However, many of the operators below are defined in terms of 
    <literal>default</literal> or <literal>formal</literal> methods or attributes.
    So, within well-defined limits a concrete implementation may customize the  
    behavior of an operator. This approach is called 
    <emphasis>operator polymorphism</emphasis>.</para>
    
    <para>Some examples:</para>
    
    <programlisting>Float z = x * y + 1.0;</programlisting>
    
    <programlisting>even = n % 2 &equals; 0;</programlisting>
    
    <programlisting>++count;</programlisting>
    
    <programlisting>Integer j = i++;</programlisting>
    
    <programlisting>if ( x > 100 || x &lt; 0 ) { ... }</programlisting>
    
    <programlisting>User user = users[userId] else guest;</programlisting>
    
    <programlisting>List&lt;Item&gt; firstPage = results[0..20];</programlisting>
    
    <programlisting>for (n in 0:length) { ... }</programlisting>
    
    <programlisting>if (char in 'A'..'Z') { ... }</programlisting>
    
    <programlisting>String[] names = people*.name;</programlisting>
    
    <programlisting>this.total += item.price * item.quantity;</programlisting>
        
    <programlisting>Float vol = length^3;</programlisting>
    
    <programlisting>Vector scaled = scale ** vector;</programlisting>
    
    <programlisting>map.define(person.name->person);</programlisting>
    
    <programlisting>if (!document.internal || user is Employee) { ... }</programlisting>
    
    <section id="operatorprecedence">
        <title>Operator precedence</title>
        
        <para>There are 18 distinct operator precedence levels, but these levels
        are arranged into layers in order to make them easier to predict.</para>
        
        <itemizedlist>
            <listitem><para>Operators in layer 1 produce, transform, and combine
            values.</para></listitem>
            <listitem><para>Operators in layer 2 compare or predicate values, producing
            a <literal>Boolean</literal> result.</para></listitem>
            <listitem><para>Operators in layer 3 are logical operators that operate
            upon <literal>Boolean</literal> arguments to produce a <literal>Boolean</literal>
            value.</para></listitem>
            <listitem><para>Operators in layer 4 perform assignment and conditional
            evaluation.</para></listitem>
        </itemizedlist>
        
        <para>Within each layer, postfix operators have a higher precedence than 
        prefix operators, and prefix operators have a higher precedence than 
        binary operators.</para>
        
        <para>There is a single exception to this principal: the binary 
        exponentiation operator <literal>^</literal> has a higher precedence than 
        the prefix operators <literal>+</literal> and <literal>-</literal>. The 
        reason for this is that the following expressions should be equivalent:</para>
        
        <programlisting>-x^2       //means -(x^2)</programlisting>
        <programlisting>0 - x^2    //means 0 - (x^2)</programlisting>
        
        <para>This table defines the relative precedence of the various operators, 
        from highest to lowest, along with associativity rules:</para>
        
        <table>
        <tgroup cols="4">
            <colspec colnum="1" colwidth="2.5*" align="center" colname="first"/>
            <colspec colnum="2" colwidth="2.0*" align="center"/>
            <colspec colnum="3" colwidth="1.0*" align="center"/>
            <colspec colnum="4" colwidth="0.7*" align="center" colname="last"/>
        <thead>
            <row>
                <entry>Operations</entry>
                <entry>Operators</entry>
                <entry>Type</entry>
                <entry>Associativity</entry>
            </row>
        </thead>
        <tbody>
        
            <row>
                <entry namest="first" nameend="last"><emphasis>Layer 1</emphasis></entry>
            </row>
    
            <row>
                <entry>Member invocation and selection, index, span,
                postfix increment, postfix decrement:</entry>
                <entry>
                <literal>.</literal>,
                <literal>*.</literal>, 
                <literal>?.</literal>, 
                <literal>()</literal>,
                <literal>{}</literal>,
                <literal>[]</literal>,
                <literal>[:]</literal>, 
                <literal>[..]</literal>, 
                <literal>[...]</literal>,
                <literal>++</literal>, 
                <literal>--</literal></entry>
                <entry>Binary / ternary / N-ary / unary postfix</entry>
                <entry>Left</entry>
            </row>
            <row>
                <entry>Prefix increment, prefix decrement:</entry>
                <entry>
                <literal>++</literal>, 
                <literal>--</literal>
                </entry>
                <entry>Unary prefix</entry>
                <entry>Right</entry>
            </row>
            <row>
                <entry>Exponentiation:</entry>
                <entry>
                <literal>^</literal>
                </entry>
                <entry>Binary</entry>
                <entry>Right</entry>
            </row>            
            <row>
                <entry>Negation:</entry>
                <entry>
                <literal>+</literal>,
                <literal>-</literal>
                </entry>
                <entry>Unary prefix</entry>
                <entry>Right</entry>
            </row>
            <!--row>
                <entry>Default:</entry> 
                <entry><literal>?</literal></entry>
                <entry>Binary</entry>
                <entry>Left</entry>
            </row-->
            <row>
                <entry>Set intersection:</entry> 
                <entry>
                <literal>&amp;</literal>
                </entry>
                <entry>Binary</entry>
                <entry>Left</entry>
            </row>
            <row>
                <entry>Set union and complement:</entry> 
                <entry>
                <literal>|</literal>,
                <literal>~</literal>
                </entry>
                <entry>Binary</entry>
                <entry>Left</entry>
            </row>
            <row>
                <entry>Multiplication, division, remainder:</entry> 
                <entry>
                <literal>*</literal>, 
                <literal>/</literal>, 
                <literal>%</literal>
                </entry>
                <entry>Binary</entry>
                <entry>Left</entry>
            </row>
            <row>
                <entry>Scale:</entry>
                <entry>
                <literal>**</literal>
                </entry>
                <entry>Binary</entry>
                <entry>Right</entry>
            </row>
            <row>
                <entry>Addition, subtraction:</entry> 
                <entry>
                <literal>+</literal>, 
                <literal>-</literal>
                </entry>
                <entry>Binary</entry>
                <entry>Left</entry>
            </row>
            <row>
                <entry>Range and entry construction:</entry> 
                <entry>
                <literal>..</literal>,
                <literal>:</literal>,  
                <literal>-></literal>
                </entry>
                <entry>Binary</entry>
                <entry>None</entry>
            </row>

            <row>
                <entry namest="first" nameend="last"><emphasis>Layer 2</emphasis></entry>
            </row>
    
            <row>
                <entry>Existence, emptiness:</entry>
                <entry><literal>exists</literal>, <literal>nonempty</literal></entry> 
                <entry>Unary postfix</entry>
                <entry>None</entry>
            </row>
            <row>
                <entry>Comparison, containment,
                assignability, inheritance:</entry> 
                <entry>
                <literal>&lt;=&gt;</literal>,
                <literal>&lt;</literal>, 
                <literal>&gt;</literal>, 
                <literal>&lt;=</literal>, 
                <literal>&gt;=</literal>,
                <literal>in</literal>,
                <literal>is</literal>,
                <literal>of</literal>,
                <literal>satisfies</literal>
                </entry>
                <entry>Binary (and ternary)</entry>
                <entry>None</entry>
            </row>
            <row>
                <entry>Equality, identity:</entry>
                <entry>
                <literal>&equals;</literal>, 
                <literal>!=</literal>, 
                <literal>&identical;</literal>
                </entry>
                <entry>Binary</entry>
                <entry>None</entry>
            </row>
        
            <row>
                <entry namest="first" nameend="last"><emphasis>Layer 3</emphasis></entry>
            </row>
    
            <row>
                <entry>Logical not:</entry>
                <entry><literal>!</literal></entry>
                <entry>Unary prefix</entry>
                <entry>Right</entry>
            </row>
            <row>
                <entry>Logical and:</entry> 
                <entry>
                <literal>&amp;&amp;</literal>
                </entry>
                <entry>Binary</entry>
                <entry>Left</entry>
            </row>
            <row>
                <entry>Logical or:</entry>
                <entry>
                <literal>||</literal>
                </entry>
                <entry>Binary</entry>
                <entry>Left</entry>
            </row>
            
            <row>
                <entry namest="first" nameend="last"><emphasis>Layer 4</emphasis></entry>
            </row>
            
            <row>
                <entry>Conditionals:</entry>
                <entry><literal>then</literal>, 
                <literal>else</literal></entry>
                <entry>Binary</entry>
                <entry>Left</entry>
            </row>
    
            <row>
                <entry>Assignment:</entry> 
                <entry>
                <literal>=</literal>, 
                <literal>+=</literal>, 
                <literal>-=</literal>, 
                <literal>*=</literal>, 
                <literal>/=</literal>, 
                <literal>%=</literal>, 
                <literal>&amp;=</literal>, 
                <literal>|=</literal>, 
                <literal>^=</literal>, 
                <literal>~=</literal>, 
                <literal>&amp;&amp;=</literal>, 
                <literal>||=</literal>
                <!--literal>?=</literal-->
                </entry>
                <entry>Binary</entry>
                <entry>Right</entry>
            </row>
            
        </tbody>
        </tgroup>
        </table>

        <para>It's important to be aware that in Ceylon, compared to other C-like 
        languages, the logical not operator <literal>!</literal> has a very low
        precedence. The following expressions are equivalent:</para>
        
        <programlisting>!x.y &equals; 0.0  //means !(x.y &equals; 0.0)</programlisting>
        <programlisting>x.y != 0.0</programlisting>
            
    </section>
    
    <section id="operatordefinition">
        <title>Operator definition</title>
        
    <para>The following tables define the semantics of the Ceylon operators. 
    There are six basic operators which do not have a definition in terms of 
    other operators or invocations:</para>
    
    <itemizedlist>
        <listitem>
            <para>the <emphasis>member selection</emphasis> operator
            <literal>.</literal> separates the receiver expression and member 
            name in a callable reference expression or attribute reference 
            expression,</para>
        </listitem>
        <listitem>
            <para>the <emphasis>argument specification</emphasis> operators
            <literal>()</literal> and <literal>{}</literal> specify the 
            argument list of an invocation,</para>
        </listitem>
        <listitem>
            <para>the <emphasis>assignment</emphasis> operator
            <literal>=</literal> assigns a new value to a variable and 
            returns the new value after assignment,</para>
        </listitem>
        <listitem>
            <para>the <emphasis>identity</emphasis> operator
            <literal>&identical;</literal> evaluates to <literal>true</literal> 
            if its argument expressions evaluate to references to the same 
            object, and <literal>false</literal> otherwise,</para>
        </listitem>
        <listitem>
            <para>the <emphasis>assignability</emphasis> operator
            <literal>is</literal> evaluates to <literal>true</literal> if 
            its argument expression evaluates to an instance of a class
            assignable to the specified type, and <literal>false</literal> 
            otherwise, and</para>
        </listitem>
        <listitem>
            <para>the <emphasis>coverage</emphasis> operator
            <literal>of</literal> narrows the type of an expression to
            a specified type that covers its type.</para>
        </listitem>
    </itemizedlist>
        
    <para>All other operators are defined in terms of other operators and/or
    invocations.</para>
    
    <para>In the tables, the following pseudo-code is used, which is not legal
    Ceylon syntax:</para>
    
    <para>First,</para>
    
    <programlisting>if (b) then x else y   //pseudocode</programlisting>
    
    <para>means the value of <literal>result</literal> after execution of the
    following:</para>
    
    <programlisting>X result; if (b) { result=x; } else { result=y; }</programlisting>
    
    <para>Second,</para>
    
    <programlisting>let t=x in y   //pseudocode</programlisting>
    
    <para>means the value of <literal>result</literal> after execution of the
    following:</para>
    
    <programlisting>X t = x; Y result=y;</programlisting>
    
    </section>
    
    <section id="basic">
    <title>Basic invocation and assignment operators</title>
    
        <para>These operators support method invocation and attribute evaluation and
        assignment.</para>
    
    <table>
    <tgroup cols="6">
        <colspec colnum="1" colwidth="4.5*" align="center" colname="first"/>
        <colspec colnum="2" colwidth="3.0*" align="center"/>
        <colspec colnum="3" colwidth="7.0*" align="center"/>
        <colspec colnum="4" colwidth="4.0*" align="center"/>
        <colspec colnum="5" colwidth="4.0*" align="center"/>
        <colspec colnum="6" colwidth="4.0*" align="center" colname="last"/>
    <thead>
        <row>
            <entry>Example</entry>
            <entry>Name</entry>
            <entry>Definition</entry>
            <entry>LHS type</entry>
            <entry>RHS type</entry>
            <entry>Return type</entry>
        </row>
    </thead>
    <tbody>
    
        <row><entry namest="first" nameend="last"><emphasis>Invocation</emphasis></entry></row>
        
        <row>
            <entry><literal>lhs.member</literal></entry>
            <entry>member</entry>
            <entry></entry>
            <entry><literal>X</literal></entry>
            <entry>a member of <literal>X</literal>, of type
            <literal>T</literal></entry>
            <entry><literal>T</literal></entry>
        </row>
        
        <row>
            <entry><literal>lhs(x,y,z)</literal> or 
            <literal>lhs{a=x;b=y;}</literal></entry>
            <entry>invoke</entry>
            <entry></entry>
            <entry><literal>Callable &lt;T,P&gt;</literal></entry>
            <entry>argument list of type <literal>P</literal></entry>
            <entry><literal>T</literal></entry>
        </row>
                
        <row><entry namest="first" nameend="last"><emphasis>Assignment</emphasis></entry></row>
    
        <row>
            <entry><literal>lhs = rhs</literal></entry>
            <entry>assign</entry>
            <entry><literal></literal></entry>
            <entry>variable of type <literal>X</literal></entry>
            <entry><literal>X</literal></entry>
            <entry><literal>X</literal></entry>
        </row>
        
        <row><entry namest="first" nameend="last"><emphasis>Coverage</emphasis></entry></row>
    
        <row>
            <entry><literal>lhs of Type</literal></entry>
            <entry>of</entry>
            <entry><literal></literal></entry>
            <entry><literal>X</literal></entry>
            <entry>a literal type <literal>T</literal> that covers 
            <literal>X</literal></entry>
            <entry><literal>T</literal></entry>
        </row>
        
     </tbody>
    </tgroup>
    </table>
        
    </section>
        
    <section id="equalitycomparison">
    <title>Equality and comparison operators</title>
    
        <para>These operators compare values for equality, order, magnitude, or membership,
        producing boolean values.</para>
    
    <table>
    <tgroup cols="6">
        <colspec colnum="1" colwidth="4.5*" align="center" colname="first"/>
        <colspec colnum="2" colwidth="3.0*" align="center"/>
        <colspec colnum="3" colwidth="7.0*" align="center"/>
        <colspec colnum="4" colwidth="4.0*" align="center"/>
        <colspec colnum="5" colwidth="4.0*" align="center"/>
        <colspec colnum="6" colwidth="4.0*" align="center" colname="last"/>
    <thead>
        <row>
            <entry>Example</entry>
            <entry>Name</entry>
            <entry>Definition</entry>
            <entry>LHS type</entry>
            <entry>RHS type</entry>
            <entry>Return type</entry>
        </row>
    </thead>
    <tbody>
    
        <row><entry namest="first" nameend="last"><emphasis>Equality and identity</emphasis></entry></row>
        
        <row>
            <entry><literal>lhs &identical; rhs</literal></entry>
            <entry>identical</entry>
            <entry><literal>identical(lhs,rhs)</literal></entry>
            <entry><literal>X given X satisfies Identifiable</literal></entry>
            <entry><literal>Y given Y satisfies Identifiable</literal>
            where <literal>X&amp;Y</literal> is not <literal>Nothing</literal></entry>
            <entry><literal>Boolean</literal></entry>
        </row>
        <row>
            <entry><literal>lhs &equals; rhs</literal></entry>
            <entry>equal</entry>
            <entry><literal>lhs.equals(rhs)</literal></entry>
            <entry><literal>Object</literal></entry>
            <entry><literal>Object</literal></entry>
            <entry><literal>Boolean</literal></entry>
        </row>
        <row>
            <entry><literal>lhs != rhs</literal></entry>
            <entry>not equal</entry>
            <entry><literal>!lhs.equals(rhs)</literal></entry>
            <entry><literal>Object</literal></entry>
            <entry><literal>Object</literal></entry>
            <entry><literal>Boolean</literal></entry>
        </row>
        
        <row><entry namest="first" nameend="last"><emphasis>Comparison</emphasis></entry></row>
        
        <row>
            <entry><literal>lhs &lt;=&gt; rhs</literal></entry>
            <entry>compare</entry>
            <entry><literal>lhs.compare(rhs)</literal></entry>
            <entry><literal>Comparable &lt;T&gt;</literal></entry>
            <entry><literal>T</literal></entry>
            <entry><literal>Comparison</literal></entry>
        </row>
        <row>
            <entry><literal>lhs &lt; rhs</literal></entry>
            <entry>smaller</entry>
            <entry><literal>lhs.compare(rhs)==smaller</literal></entry>
            <entry><literal>Comparable &lt;T&gt;</literal></entry>
            <entry><literal>T</literal></entry>
            <entry><literal>Boolean</literal></entry>
        </row>
        <row>
            <entry><literal>lhs &gt; rhs</literal></entry>
            <entry>larger</entry>
            <entry><literal>lhs.compare(rhs)==larger</literal></entry>
            <entry><literal>Comparable &lt;T&gt;</literal></entry>
            <entry><literal>T</literal></entry>
            <entry><literal>Boolean</literal></entry>
        </row>
        <row>
            <entry><literal>lhs &lt;= rhs</literal></entry>
            <entry>small as</entry>
            <entry><literal>lhs.compare(rhs)!=larger</literal></entry>
            <entry><literal>Comparable &lt;T&gt;</literal></entry>
            <entry><literal>T</literal></entry>
            <entry><literal>Boolean</literal></entry>
        </row>
        <row>
            <entry><literal>lhs &gt;= rhs</literal></entry>
            <entry>large as</entry>
            <entry><literal>lhs.compare(rhs)!=smaller</literal></entry>
            <entry><literal>Comparable &lt;T&gt;</literal></entry>
            <entry><literal>T</literal></entry>
            <entry><literal>Boolean</literal></entry>
        </row>
        
        <row><entry namest="first" nameend="last"><emphasis>Containment</emphasis></entry></row>
        
        <row>
            <entry><literal>lhs in rhs</literal></entry>
            <entry>in</entry>
            <entry><literal>let x=lhs in rhs.contains(x)</literal></entry>
            <entry><literal>Object</literal></entry>
            <entry><literal>Category</literal></entry>
            <entry><literal>Boolean</literal></entry>
        </row>
        
        <row><entry namest="first" nameend="last"><emphasis>Assignability</emphasis></entry></row>
        
        <row>
            <entry><literal>rhs is Type</literal></entry>
            <entry>is</entry>
            <entry></entry>
            <entry>any type which is not a subtype of 
            <literal>T</literal>, whose intersection with 
            <literal>T</literal> is not <literal>Nothing</literal></entry>
            <entry>any literal type <literal>T</literal></entry>
            <entry><literal>Boolean</literal></entry>
        </row>
        
        <!--
        <row><entry namest="first" nameend="last"><emphasis>Inheritance</emphasis></entry></row>
        
        <row>
            <entry><literal>lhs extends rhs</literal></entry>
            <entry>extends</entry>
            <entry></entry>
            <entry><literal>Type&lt;Void&gt;</literal></entry>
            <entry><literal>Class &lt;Void&gt;</literal></entry>
            <entry><literal>Boolean</literal></entry>
        </row>
        
        <row>
            <entry><literal>satisfies Type rhs</literal></entry>
            <entry>satisfies</entry>
            <entry></entry>
            <entry>literal <literal>Type&lt;Void&gt;</literal></entry>
            <entry><literal>Type&lt;Void&gt;</literal></entry>
            <entry><literal>Boolean</literal></entry>
        </row>
        -->
        
    </tbody>
    </tgroup>
    </table>
    
        <comment><para>TODO: Should we have allow the operators <literal>&lt;=</literal> 
        and <literal>&gt;=</literal> to handle partial orders? A particular usecase is
        <literal>Set</literal> comparison.</para></comment>
        
        <para>A <emphasis>bounded comparison</emphasis> is an abbreviation 
        for two binary comparisons:</para>
        
        <itemizedlist>
            <listitem>
                <para><literal>l&lt;x&lt;u</literal> means 
                <literal>x&gt;l &amp;&amp; x&lt;u</literal>,</para>
            </listitem>
            <listitem>
                <para><literal>l&lt;=x&lt;u</literal> means 
                <literal>x&gt;=l &amp;&amp; x&lt;u</literal>,</para>
            </listitem>
            <listitem>
                <para><literal>l&lt;x&lt;=u</literal> means 
                <literal>x&gt;l &amp;&amp; x&lt;=u</literal>, and</para>
            </listitem>
            <listitem>
                <para><literal>l&lt;=x&lt;=u</literal> means 
                <literal>x&gt;=l &amp;&amp; x&lt;=u</literal></para>
            </listitem>
        </itemizedlist>
        
        <para>for expressions <literal>l</literal>, <literal>u</literal>, 
        and <literal>x</literal>.</para>
        
        <para>These abbreviations have the same precedence as the binary 
        <literal>&lt;</literal> and <literal>&lt;=</literal> operators, and, 
        like the binary forms, are not associative.</para>
        
    </section>
                
    <section id="logical">
    <title>Logical operators</title>
    
        <para>These are the usual logical operations for boolean values.</para>
    
    <table>
    <tgroup cols="6">
        <colspec colnum="1" colwidth="4.5*" align="center" colname="first"/>
        <colspec colnum="2" colwidth="3.0*" align="center"/>
        <colspec colnum="3" colwidth="7.0*" align="center"/>
        <colspec colnum="4" colwidth="4.0*" align="center"/>
        <colspec colnum="5" colwidth="4.0*" align="center"/>
        <colspec colnum="6" colwidth="4.0*" align="center" colname="last"/>
    <thead>
        <row>
            <entry>Example</entry>
            <entry>Name</entry>
            <entry>Definition</entry>
            <entry>LHS type</entry>
            <entry>RHS type</entry>
            <entry>Return type</entry>
        </row>
    </thead>
    <tbody>
    
        <row><entry namest="first" nameend="last"><emphasis>Logical operators</emphasis></entry></row>
        
        <row>
            <entry><literal>!rhs</literal></entry>
            <entry>not</entry>
            <entry><literal>if (rhs) false else true</literal></entry>
            <entry></entry>
            <entry><literal>Boolean</literal></entry>
            <entry><literal>Boolean</literal></entry>
        </row>
        <row>
            <entry><literal>lhs || rhs</literal></entry>
            <entry>conditional or</entry>
            <entry><literal>if (lhs) true else rhs</literal></entry>
            <entry><literal>Boolean</literal></entry>
            <entry><literal>Boolean</literal></entry>
            <entry><literal>Boolean</literal></entry>
        </row>
        <row>
            <entry><literal>lhs &amp;&amp; rhs</literal></entry>
            <entry>conditional and</entry>
            <entry><literal>if (lhs) rhs else false</literal></entry>
            <entry><literal>Boolean</literal></entry>
            <entry><literal>Boolean</literal></entry>
            <entry><literal>Boolean</literal></entry>
        </row>

        <row><entry namest="first" nameend="last"><emphasis>Logical assignment</emphasis></entry></row>
        
        <row>
            <entry><literal>lhs ||= rhs</literal></entry>
            <entry>conditional or</entry>
            <entry><literal>if (lhs) true else lhs=rhs</literal></entry>
            <entry>variable of type <literal>Boolean</literal></entry>
            <entry><literal>Boolean</literal></entry>
            <entry><literal>Boolean</literal></entry>
        </row>

        <row>
            <entry><literal>lhs &amp;&amp;= rhs</literal></entry>
            <entry>conditional and</entry>
            <entry><literal>if (lhs) lhs=rhs else false</literal></entry>
            <entry>variable of type <literal>Boolean</literal></entry>
            <entry><literal>Boolean</literal></entry>
            <entry><literal>Boolean</literal></entry>
        </row>
        
    </tbody>
    </tgroup>
    </table>
    
    </section>
    
    <section id="nullvalues">
    <title>Operators for handling null values</title>
    
        <para>These operators make it easy to work with optional expressions.</para>
    
    <table>
    <tgroup cols="6">
        <colspec colnum="1" colwidth="4.5*" align="center" colname="first"/>
        <colspec colnum="2" colwidth="3.0*" align="center"/>
        <colspec colnum="3" colwidth="7.0*" align="center"/>
        <colspec colnum="4" colwidth="4.0*" align="center"/>
        <colspec colnum="5" colwidth="4.0*" align="center"/>
        <colspec colnum="6" colwidth="4.0*" align="center" colname="last"/>
    <thead>
        <row>
            <entry>Example</entry>
            <entry>Name</entry>
            <entry>Definition</entry>
            <entry>LHS type</entry>
            <entry>RHS type</entry>
            <entry>Return type</entry>
        </row>
    </thead>
    <tbody>
    
        <row><entry namest="first" nameend="last"><emphasis>Existence</emphasis></entry></row>
        
        <row>
            <entry><literal>lhs exists</literal></entry>
            <entry>exists</entry>
            <entry><literal>if (exists lhs) true else false</literal></entry>
            <entry>any type whose intersections with <literal>Object</literal>
            and <literal>Null</literal> are not <literal>Nothing</literal></entry>
            <entry></entry>
            <entry><literal>Boolean</literal></entry>
        </row>
        <row>
            <entry><literal>lhs nonempty</literal></entry>
            <entry>nonempty</entry>
            <entry><literal>if (nonempty lhs) true else false</literal></entry>
            <entry>any subtype of <literal>Anything[]?</literal>
            whose intersections with <literal>[]</literal> and 
            <literal>[Nothing+]</literal> are not <literal>Nothing</literal></entry>
            <entry></entry>
            <entry><literal>Boolean</literal></entry>
        </row>
                
        <row><entry namest="first" nameend="last"><emphasis>Nullsafe invocation</emphasis></entry></row>
        
        <row>
            <entry><literal>lhs?.member</literal></entry>
            <entry>nullsafe attribute</entry>
            <entry><literal>if (exists lhs) lhs.member else null</literal></entry>
            <entry><literal>X?</literal></entry>
            <entry>an attribute of type <literal>T</literal>
            of <literal>X</literal></entry>
            <entry><literal>T?</literal></entry>
        </row>
        
        <row>
            <entry><literal>lhs?.member</literal></entry>
            <entry>nullsafe method</entry>
            <entry></entry>
            <entry><literal>X?</literal></entry>
            <entry>a method of callable type 
            <literal>Callable &lt;T,P&gt;</literal> 
            of <literal>X</literal></entry>
            <entry><literal>Callable &lt;T?,P&gt;</literal></entry>
        </row>
        
    </tbody>
    </tgroup>
    </table>
    
    </section>

    <section id="listmap">
    <title>Correspondence and sequence operators</title>
    
        <para>These operators provide a simplified syntax for accessing values 
        of a <literal>Correspondence</literal>, and for joining and obtaining
        subranges of <literal>Sequence</literal>s.</para>
    
    <table>
    <tgroup cols="6">
        <colspec colnum="1" colwidth="4.5*" align="center" colname="first"/>
        <colspec colnum="2" colwidth="3.0*" align="center"/>
        <colspec colnum="3" colwidth="7.0*" align="center"/>
        <colspec colnum="4" colwidth="4.0*" align="center"/>
        <colspec colnum="5" colwidth="4.0*" align="center"/>
        <colspec colnum="6" colwidth="4.0*" align="center" colname="last"/>
    <thead>
        <row>
            <entry>Example</entry>
            <entry>Name</entry>
            <entry>Definition</entry>
            <entry>LHS type</entry>
            <entry>RHS type</entry>
            <entry>Return type</entry>
        </row>
    </thead>
    <tbody>
    
        <row><entry namest="first" nameend="last"><emphasis>Keyed item access</emphasis></entry></row>
        
        <row>
            <entry><literal>lhs[index]</literal></entry>
            <entry>lookup</entry>
            <entry><literal>lhs.item(index)</literal></entry>
            <entry><literal>Correspondence&lt;X,Y&gt;</literal></entry>
            <entry><literal>X</literal></entry>
            <entry><literal>Y?</literal></entry>
        </row>
        
        <row><entry namest="first" nameend="last"><emphasis>Spans and segments</emphasis></entry></row>
        
        <row>
            <entry><literal>lhs[from:to]</literal></entry>
            <entry>segment</entry>
            <entry><literal>lhs.segment(from,to)</literal></entry>
            <entry><literal>Ranged&lt;X,Y&gt;</literal></entry>
            <entry><literal>X</literal>, <literal>Integer</literal></entry>
            <entry><literal>Y</literal></entry>
        </row>
        <row>
            <entry><literal>lhs[from..to]</literal></entry>
            <entry>span</entry>
            <entry><literal>lhs.span(from,to)</literal></entry>
            <entry><literal>Ranged&lt;X,Y&gt;</literal></entry>
            <entry><literal>X</literal>, <literal>X</literal></entry>
            <entry><literal>Y</literal></entry>
        </row>
        <row>
            <entry><literal>lhs[from...]</literal></entry>
            <entry>upper span</entry>
            <entry><literal>lhs.spanFrom(from)</literal></entry>
            <entry><literal>Ranged&lt;X,Y&gt;</literal></entry>
            <entry><literal>X</literal></entry>
            <entry><literal>Y</literal></entry>
        </row>
        <row>
            <entry><literal>lhs[...to]</literal></entry>
            <entry>lower span</entry>
            <entry><literal>lhs.spanTo(to)</literal></entry>
            <entry><literal>Ranged&lt;X,Y&gt;</literal></entry>
            <entry><literal>X</literal></entry>
            <entry><literal>Y</literal></entry>
        </row>
        
        <row><entry namest="first" nameend="last"><emphasis>Spread invocation</emphasis></entry></row>
        
        <row>
            <entry><literal>lhs*.member</literal></entry>
            <entry>spread attribute</entry>
            <entry><literal>[ for (X x in lhs) x.member ]</literal></entry>
            <entry><literal>X[]</literal></entry>
            <entry>attribite of <literal>X</literal> of
            type <literal>T</literal></entry>
            <entry><literal>T[]</literal></entry>
        </row>
        
        <row>
            <entry><literal>lhs*.member</literal></entry>
            <entry>spread method</entry>
            <entry></entry>
            <entry><literal>X[]</literal></entry>
            <entry>method of <literal>X</literal> of
            callable type <literal>Callable &lt;T,P&gt;</literal></entry>
            <entry><literal>Callable &lt;T[],P&gt;</literal></entry>
        </row>
        
        <row><entry namest="first" nameend="last"><emphasis>Spread multiplication</emphasis></entry></row>
        
        <row>
            <entry><literal>lhs ** rhs</literal></entry>
            <entry>scale</entry>
            <entry><literal>rhs.scale(lhs)</literal></entry>
            <entry><literal>Y</literal></entry>
            <entry><literal>Scalable&lt;X,Y&gt;</literal></entry>
            <entry><literal>X</literal></entry>
        </row>
        
    </tbody>
    </tgroup>
    </table>
    
    <para>There are two special cases related to sequences. A type <literal>X</literal>
    is a <emphasis>sequence type</emphasis> if <literal>X</literal> is a subtype of 
    <literal>Sequential&lt;Anything&gt;</literal>.</para>
    
    <para>For any sequence type <literal>X</literal> and integer <literal>n</literal>, 
    we can form the <emphasis><literal>n</literal>th tail type, <literal>Xn</literal>, 
    of <literal>X</literal></emphasis> as follows:</para>
    
    <itemizedlist>
        <listitem>
            <para>for every <literal>i&lt;=0</literal>, <literal>Xi</literal> 
            is <literal>X</literal>, and</para>
        </listitem>
        <listitem>
            <para>for every <literal>i&gt;0</literal>, if <literal>Xi</literal> 
            is an invariant subtype of <literal>Tuple&lt;Ui,Fi,Yi&gt;</literal> 
            then <literal>X(i+1)</literal> is <literal>Yi</literal>, or, 
            otherwise, <literal>X(i+1)</literal> is <literal>Xi</literal>.</para>
        </listitem>
    </itemizedlist>
    
    <para>For any sequence type <literal>X</literal> and integer <literal>n</literal>, 
    we can form the <emphasis><literal>n</literal>th element type, <literal>En</literal>, 
    of <literal>X</literal></emphasis> as follows:</para>
        
    <itemizedlist>
        <listitem>
            <para>if <literal>Xn</literal> is an invariant subtype of 
            <literal>Tuple&lt;Un,Fn,Yn&gt;</literal> then <literal>En</literal> 
            is <literal>Fn</literal>, or, otherwise, <literal>Xn</literal>
            is an invariant subtype of <literal>Sequential&lt;Fn&gt;</literal> 
            and <literal>En</literal> is <literal>Fn?</literal>.</para>
        </listitem>
    </itemizedlist>
    
    <para>Then the two special cases are:</para>
    
    <itemizedlist>
        <listitem>
    <para>The type of an expression of form <literal>x[i...]</literal> where
    <literal>x</literal> is of tuple type <literal>X</literal> and 
    <literal>n</literal> is an integer literal is <literal>Xn</literal>.</para>
        </listitem>
        <listitem>
    <para>The type of an expression of form <literal>x[i]</literal> where
    <literal>x</literal> is of tuple type <literal>X</literal> and 
    <literal>n</literal> is an integer literal is <literal>En</literal>.</para>
        </listitem>
    </itemizedlist>
    
    </section>
    
    <section id="constructors">
    <title>Operators for creating objects</title>
    
        <para>These operators simplify the syntax for instantiating certain 
        commonly used built-in types.</para>
    
    <table>
    <tgroup cols="6">
        <colspec colnum="1" colwidth="4.5*" align="center" colname="first"/>
        <colspec colnum="2" colwidth="3.0*" align="center"/>
        <colspec colnum="3" colwidth="7.0*" align="center"/>
        <colspec colnum="4" colwidth="4.0*" align="center"/>
        <colspec colnum="5" colwidth="4.0*" align="center"/>
        <colspec colnum="6" colwidth="4.0*" align="center" colname="last"/>
    <thead>
        <row>
            <entry>Example</entry>
            <entry>Name</entry>
            <entry>Definition</entry>
            <entry>LHS type</entry>
            <entry>RHS type</entry>
            <entry>Return type</entry>
        </row>
    </thead>
    <tbody>
    
        <row><entry namest="first" nameend="last"><emphasis>Range and entry constructors</emphasis></entry></row>

        <row>
            <entry><literal>lhs..rhs</literal></entry>
            <entry>spanned range</entry>
            <entry><literal>Range(lhs, rhs)</literal></entry>
            <entry><literal>T given T satisfies Ordinal &amp; Comparable&lt;T&gt;</literal></entry>
            <entry><literal>T</literal></entry>
            <entry><literal>Range&lt;T&gt;</literal></entry>
        </row>
        
        <row>
            <entry><literal>lhs:rhs</literal></entry>
            <entry>segmented range</entry>
            <entry><literal>if (lhs&lt;=0) [] else TODO</literal></entry>
            <entry><literal>T given T satisfies Ordinal &amp; Comparable&lt;T&gt;</literal></entry>
            <entry><literal>Integer</literal></entry>
            <entry><literal>T[]</literal></entry>
        </row>
        
        <row>
            <entry><literal>lhs->rhs</literal></entry>
            <entry>entry</entry>
            <entry><literal>Entry(lhs, rhs)</literal></entry>
            <entry><literal>U given U satisfies Object</literal></entry>
            <entry><literal>V given V satisfies Object</literal></entry>
            <entry><literal>Entry&lt;U,V&gt;</literal></entry>
        </row>
        
        <!--
        
        <row><entry namest="first" nameend="last"><emphasis>Datetime and interval constructors</emphasis></entry></row>

        <row>
            <entry><literal>lhs @ rhs</literal></entry>
            <entry>datetime</entry>
            <entry><literal>Datetime(lhs, rhs)</literal></entry>
            <entry><literal>Date</literal></entry>
            <entry><literal>Time</literal></entry>
            <entry><literal>Datetime</literal></entry>
        </row>
        
        <row>
            <entry><literal>lhs .. rhs</literal></entry>
            <entry>interval</entry>
            <entry><literal>Interval(lhs, rhs)</literal></entry>
            <entry><literal>T given T satisfies Instant</literal></entry>
            <entry><literal>Instant&lt;T&gt;</literal></entry>
            <entry><literal>Interval&lt;T&gt;</literal></entry>
        </row>
        
        -->
        
    </tbody>
    </tgroup>
    </table>
    
    </section>
    
    <section id="conditionals">
    <title>Conditional operators</title>
    
        <para>Two special operators allow emulation of the famous ternary
        operator of C-like languages.</para>
    
    <table>
    <tgroup cols="6">
        <colspec colnum="1" colwidth="4.5*" align="center" colname="first"/>
        <colspec colnum="2" colwidth="3.0*" align="center"/>
        <colspec colnum="3" colwidth="7.0*" align="center"/>
        <colspec colnum="4" colwidth="4.0*" align="center"/>
        <colspec colnum="5" colwidth="4.0*" align="center"/>
        <colspec colnum="6" colwidth="4.0*" align="center" colname="last"/>
    <thead>
        <row>
            <entry>Example</entry>
            <entry>Name</entry>
            <entry>Definition</entry>
            <entry>LHS type</entry>
            <entry>RHS type</entry>
            <entry>Return type</entry>
        </row>
    </thead>
    <tbody>
    
        <row><entry namest="first" nameend="last"><emphasis>Conditionals</emphasis></entry></row>

        <row>
            <entry><literal>lhs then rhs</literal></entry>
            <entry>then</entry>
            <entry><literal>if (lhs) then rhs else null</literal></entry>
            <entry><literal>Boolean</literal></entry>
            <entry><literal>T given T satisfies Object</literal></entry>
            <entry><literal>T?</literal></entry>
        </row>
        
        <row>
            <entry><literal>lhs else rhs</literal></entry>
            <entry>else</entry>
            <entry><literal>if (exists lhs) then lhs else rhs</literal></entry>
            <entry><literal>U</literal> such that <literal>null is U</literal></entry>
            <entry><literal>V</literal></entry>
            <entry><literal>U&amp;Object|V</literal></entry>
        </row>
        
    </tbody>
    </tgroup>
    </table>
    
    </section>
    
    <section id="arithmetic">
    <title>Arithmetic operators</title>
    
        <para>These are the usual mathematical operations for all kinds of
        numeric values.</para>
    
    <table>
    <tgroup cols="6">
        <colspec colnum="1" colwidth="4.5*" align="center" colname="first"/>
        <colspec colnum="2" colwidth="3.0*" align="center"/>
        <colspec colnum="3" colwidth="7.0*" align="center"/>
        <colspec colnum="4" colwidth="4.0*" align="center"/>
        <colspec colnum="5" colwidth="4.0*" align="center"/>
        <colspec colnum="6" colwidth="4.0*" align="center" colname="last"/>
    <thead>
        <row>
            <entry>Example</entry>
            <entry>Name</entry>
            <entry>Definition</entry>
            <entry>LHS type</entry>
            <entry>RHS type</entry>
            <entry>Return type</entry>
        </row>
    </thead>
    <tbody>
    
        <row><entry namest="first" nameend="last"><emphasis>Increment, decrement</emphasis></entry></row>
        
        <!-- Prefix increment, decrement -->
        
        <row>
            <entry><literal>++rhs</literal></entry>
            <entry>successor</entry>
            <entry><literal>rhs=rhs.successor</literal></entry>
            <entry></entry>
            <entry>variable of type <literal>Ordinal&lt;T&gt;</literal></entry>
            <entry><literal>T</literal></entry>
        </row>
        <row>
            <entry><literal>--rhs</literal></entry>
            <entry>predecessor</entry>
            <entry><literal>rhs=rhs.predecessor</literal></entry>
            <entry></entry>
            <entry>variable of type <literal>Ordinal&lt;T&gt;</literal></entry>
            <entry><literal>T</literal></entry>
        </row>
        
        <!-- Postfix increment, decrement -->
        
        <row>
            <entry><literal>lhs++</literal></entry>
            <entry>increment</entry>
            <entry><literal>(++lhs).predecessor</literal></entry>
            <entry>variable of type <literal>Ordinal&lt;T&gt;</literal></entry>
            <entry></entry>
            <entry><literal>T</literal></entry>
        </row>
        <row>
            <entry><literal>lhs--</literal></entry>
            <entry>decrement</entry>
            <entry><literal>(--lhs).successor</literal></entry>
            <entry>variable of type <literal>Ordinal&lt;T&gt;</literal></entry>
            <entry></entry>
            <entry><literal>T</literal></entry>
        </row>
        
        <row><entry namest="first" nameend="last"><emphasis>Numeric operators</emphasis></entry></row>
        
        <!-- Unary positive and negative -->
        
        <row>
            <entry><literal>+rhs</literal></entry>
            <entry></entry>
            <entry><literal>rhs.positiveValue</literal></entry>
            <entry></entry>
            <entry><literal>Invertable &lt;I&gt;</literal></entry>
            <entry><literal>I</literal></entry>
        </row>
        
        <row>
            <entry><literal>-rhs</literal></entry>
            <entry>negation</entry>
            <entry><literal>rhs.negativeValue</literal></entry>
            <entry></entry>
            <entry><literal>Invertable &lt;I&gt;</literal></entry>
            <entry><literal>I</literal></entry>
        </row>
        
        <!-- Numeric -->
        
        <row>
            <entry><literal>lhs + rhs</literal></entry>
            <entry>sum</entry>
            <entry><literal>lhs.plus(rhs)</literal></entry>
            <entry><literal>Summable&lt;X&gt;</literal></entry>
            <entry><literal>X</literal></entry>
            <entry><literal>X</literal></entry>
        </row>
        <row>
            <entry><literal>lhs - rhs</literal></entry>
            <entry>difference</entry>
            <entry><literal>lhs.minus(rhs)</literal></entry>
            <entry><literal>Subtractable &lt;X&gt;</literal></entry>
            <entry><literal>X</literal></entry>
            <entry><literal>X</literal></entry>
        </row>
        <row>
            <entry><literal>lhs * rhs</literal></entry>
            <entry>product</entry>
            <entry><literal>lhs.times(rhs)</literal></entry>
            <entry><literal>Numeric&lt;X&gt;</literal></entry>
            <entry><literal>X</literal></entry>
            <entry><literal>X</literal></entry>
        </row>
        <row>
            <entry><literal>lhs / rhs</literal></entry>
            <entry>quotient</entry>
            <entry><literal>lhs.divided(rhs)</literal></entry>
            <entry><literal>Numeric&lt;X&gt;</literal></entry>
            <entry><literal>X</literal></entry>
            <entry><literal>X</literal></entry>
        </row>
        <row>
            <entry><literal>lhs % rhs</literal></entry>
            <entry>remainder</entry>
            <entry><literal>lhs.remainder(rhs)</literal></entry>
            <entry><literal>Integral&lt;X&gt;</literal></entry>
            <entry><literal>X</literal></entry>
            <entry><literal>X</literal></entry>
        </row>
        <row>
            <entry><literal>lhs ^ rhs</literal></entry>
            <entry>power</entry>
            <entry><literal>lhs.power(rhs)</literal></entry>
            <entry><literal>Exponentiable &lt;X,Y&gt;</literal></entry>
            <entry><literal>Y</literal></entry>
            <entry><literal>X</literal></entry>
        </row>
        
        <row><entry namest="first" nameend="last"><emphasis>Numeric assignment</emphasis></entry></row>
        
        <row>
            <entry><literal>lhs += rhs</literal></entry>
            <entry>add</entry>
            <entry><literal>lhs=lhs.plus(rhs)</literal></entry>
            <entry>variable of type <literal>Summable&lt;N&gt;</literal></entry>
            <entry><literal>N</literal></entry>
            <entry><literal>N</literal></entry>
        </row>
        <row>
            <entry><literal>lhs -= rhs</literal></entry>
            <entry>subtract</entry>
            <entry><literal>lhs=lhs.minus(rhs)</literal></entry>
            <entry>variable of type <literal>Subtractable &lt;N&gt;</literal></entry>
            <entry><literal>N</literal></entry>
            <entry><literal>N</literal></entry>
        </row>
        <row>
            <entry><literal>lhs *= rhs</literal></entry>
            <entry>multiply</entry>
            <entry><literal>lhs=lhs.times(rhs)</literal></entry>
            <entry>variable of type <literal>Numeric&lt;N&gt;</literal></entry>
            <entry><literal>N</literal></entry>
            <entry><literal>N</literal></entry>
        </row>
        <row>
            <entry><literal>lhs /= rhs</literal></entry>
            <entry>divide</entry>
            <entry><literal>lhs=lhs.divided(rhs)</literal></entry>
            <entry>variable of type <literal>Numeric&lt;N&gt;</literal></entry>
            <entry><literal>N</literal></entry>
            <entry><literal>N</literal></entry>
        </row>
        <row>
            <entry><literal>lhs %= rhs</literal></entry>
            <entry>remainder</entry>
            <entry><literal>lhs=lhs.remainder(rhs)</literal></entry>
            <entry>variable of type <literal>Integral&lt;N&gt;</literal></entry>
            <entry><literal>N</literal></entry>
            <entry><literal>N</literal></entry>
        </row>
                
    </tbody>
    </tgroup>
    </table>
    
        <para>Arithmetic operators automatically widen from <literal>Integer</literal> 
        to <literal>Float</literal> when necessary. If one operand expression is 
        of static type <literal>Integer</literal>, and the other is of type 
        <literal>Float</literal>, the operand of type <literal>Integer</literal> 
        is widened to a <literal>Float</literal> in order to make the operator 
        expression well-typed. Widening is performed by evaluating the attribute 
        <literal>float</literal> defined by <literal>Integer</literal>.</para>
        
        <comment><para>Note: this is the only circumstance in the language where 
        implicit type conversion occurs. In fact, it is more correct to view this 
        behavior as an instance of operator overloading than as an implicit type 
        conversion. Implicit widening does not occur when an expression of type 
        <literal>Integer</literal> is merely assigned to the type 
        <literal>Float</literal>, since such behavior would result in ambiguities 
        when generics come into play.</para></comment>
            
        <!--para>Ceylon's numeric type system is designed to accommodate the following
        considerations:</para>
        
        <itemizedlist>
            <listitem>
                <para>The system is extensible and new numeric types may be defined
                by libraries. Numeric types defined by libraries should work the 
                same as built-in numeric types.</para>
            </listitem>
            <listitem>
                <para>Two values of different numeric types should be combinable
                using operators without the need for explicit type conversions, 
                but</para>
            </listitem>
            <listitem>
                <para>implicit type conversions should never lose information
                and</para>
            </listitem>
            <listitem>
                <para>binary operators must be symmetric.</para>
            </listitem>
            <listitem>
                <para>Furthermore, there should be no special cases in the language 
                definition or type checker to accommodate numeric types.</para>
            </listitem>
            <listitem>
                <para>However, it must be possible for the compiler to optimize 
                certain of the built-in numeric types to take advantage of the VM's 
                native support for numeric types.</para>
            </listitem>
            <listitem>
                <para>It is not necessary to encode information about the limits
                of the machine's representation of a numeric value into the type
                system. A single <literal>Integer</literal> class is sufficient
                to represent 32, 64, or 128 bit integer values. A single 
                <literal>Float</literal> class is sufficient to represent single
                and double precision floating point values. It is simply not
                possible for the compiler to detect numeric overflow or loss of
                significant precision.</para>
            </listitem>
        </itemizedlist-->
        
    </section>
    
    <section id="sets">
    <title>Set operators</title>
    
    <para>These operators provide traditional mathematical operations for sets.</para>
    
    <table>
    <tgroup cols="6">
        <colspec colnum="1" colwidth="4.5*" align="center" colname="first"/>
        <colspec colnum="2" colwidth="3.0*" align="center"/>
        <colspec colnum="3" colwidth="7.0*" align="center"/>
        <colspec colnum="4" colwidth="4.0*" align="center"/>
        <colspec colnum="5" colwidth="4.0*" align="center"/>
        <colspec colnum="6" colwidth="4.0*" align="center" colname="last"/>
    <thead>
        <row>
            <entry>Example</entry>
            <entry>Name</entry>
            <entry>Definition</entry>
            <entry>LHS type</entry>
            <entry>RHS type</entry>
            <entry>Return type</entry>
        </row>
    </thead>
    <tbody>
    
        <row><entry namest="first" nameend="last"><emphasis>Set operators</emphasis></entry></row>
        
        <row>
            <entry><literal>lhs | rhs</literal></entry>
            <entry>union</entry>
            <entry><literal>lhs.union(rhs)</literal></entry>
            <entry><literal>Set&lt;X&gt;</literal></entry>
            <entry><literal>Set&lt;Y&gt;</literal></entry>
            <entry><literal>Set&lt;X|Y&gt;</literal></entry>
        </row>
        <row>
            <entry><literal>lhs &amp; rhs</literal></entry>
            <entry>intersection</entry>
            <entry><literal>lhs.intersection(rhs)</literal></entry>
            <entry><literal>Set&lt;X&gt;</literal></entry>
            <entry><literal>Set&lt;Y&gt;</literal></entry>
            <entry><literal>Set&lt;X&amp;Y&gt;</literal></entry>
        </row>
        <row>
            <entry><literal>lhs ~ rhs</literal></entry>
            <entry>complement</entry>
            <entry><literal>lhs.complement(rhs)</literal></entry>
            <entry><literal>Set&lt;X&gt;</literal></entry>
            <entry><literal>Set&lt;Object&gt;</literal></entry>
            <entry><literal>Set&lt;X&gt;</literal></entry>
        </row>

        
        <row><entry namest="first" nameend="last"><emphasis>Set assignment</emphasis></entry></row>
        
        <row>
            <entry><literal>lhs |= rhs</literal></entry>
            <entry>union</entry>
            <entry><literal>lhs=lhs|rhs</literal></entry>
            <entry>variable of type <literal>Set&lt;X&gt;</literal></entry>
            <entry><literal>Set&lt;X&gt;</literal></entry>
            <entry><literal>Set&lt;X&gt;</literal></entry>
        </row>
        <row>
            <entry><literal>lhs &amp;= rhs</literal></entry>
            <entry>intersection</entry>
            <entry><literal>lhs=lhs&amp;rhs</literal></entry>
            <entry>variable of type <literal>Set&lt;X&gt;</literal></entry>
            <entry><literal>Set&lt;Object&gt;</literal></entry>
            <entry><literal>Set&lt;X&gt;</literal></entry>
        </row>
        <row>
            <entry><literal>lhs ~= rhs</literal></entry>
            <entry>complement</entry>
            <entry><literal>lhs=lhs~rhs</literal></entry>
            <entry>variable of type <literal>Set&lt;X&gt;</literal></entry>
            <entry><literal>Set&lt;Object&gt;</literal></entry>
            <entry><literal>Set&lt;X&gt;</literal></entry>
        </row>
        
    </tbody>
    </tgroup>
    </table>
    
    </section>
    
    </section>
    
</chapter>
