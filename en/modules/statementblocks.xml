<chapter id="statementblocks">
    <title>Statements, blocks, and control structures</title>
    
    <para>Function, value, and class bodies contain procedural code that is executed 
    when the function is invoked, the value evaluated, or the class instantiated. The 
    code contains expressions and control directives and is organized using blocks 
    and control structures.</para>
    
    <comment><para>Note: the Ceylon language has a recursive block structure&mdash;statements 
    and declarations that are syntactically valid in the body of a toplevel declaration 
    are, in general, also syntactically valid in the body of a nested declaration or 
    of a control structure, and vice-versa.</para></comment>
    
    <!--
    <comment><para>TODO: a named argument list looks very much like a block, but is 
    not currently defined that way. The language would be more regular if we decided to 
    just make it a block.</para></comment>
    -->
    
    <section id="blockstructure">
        <title>Block structure</title>
    
        <para>A <emphasis>body</emphasis> is a block, class body or interface body. Every 
        body is list of semicolon-delimited statements, control structures, and declarations, 
        surrounded by braces. Some bodies end in a control directive. Every program element 
        in the list is said to <emphasis>directly occur</emphasis> in the body. A program 
        element <emphasis>directly occurs earlier</emphasis> than a second program element 
        if both program elements directly occur in a body and the first program element 
        occurs (lexically) earlier in the list than the second program element.</para>
        
        <!--
        <para>As a special case, the <literal>while</literal> condition of a <literal>do/while</literal> 
        loop is considered to directly occur in the <literal>do</literal> block. All other
        statements and declarations of the <literal>do</literal> block are considered to
        directly occur earlier than the <literal>while</literal> condition.</para>
        -->
        
        <para>A program element <emphasis>(indirectly) occurs</emphasis> in a body if:</para>
        
        <itemizedlist>
            <listitem>
                <para>the program element directly occurs in the body, or</para>
            </listitem>
            <listitem>
                <para>the program element indirectly occurs inside the body of a declaration
                or control structure that occurs directly in the body.</para>
            </listitem>
        </itemizedlist>
        
        <para>We sometimes say that the body <emphasis>contains</emphasis> the program 
        element if the program element (indirectly) occurs in the body.</para>
        
        <para>A program element <emphasis>(indirectly) occurs earlier</emphasis> than a 
        second program element if:</para>
        
        <itemizedlist>
            <listitem>
                <para>the two program elements both directly occur in the same body, and 
                the second program element occurs after the first program element, or</para>
            </listitem>
            <listitem>
                <para>the second program element indirectly occurs inside the body of a 
                declaration or control structure, and the first program element directly 
                occurs earlier than the declaration or control structure.</para>
            </listitem>
        </itemizedlist>
        
        <para>The set of program elements that (indirectly) occur later than a program 
        element is sometimes called the <emphasis>lexical scope</emphasis> of the program
        element.</para>
        
        <para>A program element <emphasis>sequentially occurs</emphasis> in a body if:</para>
        
        <itemizedlist>
            <listitem>
                <para>the program element directly occurs in the body, or</para>
            </listitem>
            <listitem>
                <para>the program element sequentially occurs inside the body of a control 
                structure that occurs directly in the body.</para>
            </listitem>
        </itemizedlist>
        
        <para>A program element <emphasis>sequentially occurs earlier</emphasis> than a 
        second program element if:</para>
        
        <itemizedlist>
            <listitem>
                <para>the two program elements both directly occur in the same body, and 
                the second program element occurs after the first program element, or</para>
            </listitem>
            <listitem>
                <para>the second program element sequentially occurs inside the body of a 
                control structure, and the first program element directly occurs earlier 
                than the declaration or control structure.</para>
            </listitem>
        </itemizedlist>
        
        <para>If a program element sequentially occurs earlier than a second program element, 
        the <emphasis>sequence of statements</emphasis> from the first program element to the
        second program element comprises:</para>
        
        <itemizedlist>
            <listitem>
                <para>the sequence of statements that occur directly in the body in which
                the first program element directly occurs, beginning from the first program 
                element and ending with the second program element, if the second program 
                element occurs directly in the same body as the first program element, or</para>
            </listitem>
            <listitem>
                <para>the sequence of statements that occur directly in the body in which
                the first program element directly occurs, beginning from the first program 
                element and ending with the declaration or control structure in whose body 
                the second program element sequentially occurs, followed by the sequence of 
                statements from the first statement of the declaration whose body contains 
                the second program element to the second program element itself, otherwise.</para>
            </listitem>
        </itemizedlist>
        
    <section id="declarationnameuniqueness">
        <title>Declaration name uniqueness</title>
        
        <para>A package may not contain two toplevel declarations with the same name.</para>
        
        <para>A program element is contained within the <emphasis>namespace</emphasis> 
        of a declaration if either:</para>
        
        <itemizedlist>
            <listitem>
                <para>it directly occurs in the body in which the declaration 
                directly occurs,</para>
            </listitem>
            <listitem>
                <para>the declaration is a parameter or type parameter, and it 
                directly occurs in the body of the parameterized declaration,</para>
            </listitem>
            <!--
            <listitem>
                <para>it is a type parameter of the declaration,</para>
            </listitem>
            <listitem>
                <para>it indirectly occurs in the body of the declaration, and the 
                declaration is a class or interface,</para>
            </listitem>
            <listitem>
                <para>it is a type parameter of a declaration that indirectly occurs 
                in the body of the declaration, and the declaration is a class or 
                interface,</para>
            </listitem>
            -->
            <listitem>
                <para>it is a control structure variable or iteration variable of a 
                control structure contained in the namespace of the declaration, or</para>
            </listitem>
            <listitem>
                <para>it directly occurs in the body of a control structure contained
                in the namespace of the declaration.</para>
            </listitem>
        </itemizedlist>

        <para>The namespace of a declaration may not contain a second declaration with 
        the same name. (A parameter or type parameter is considered to be a declaration 
        that is directly contained by the body of the declaration it parameterizes.)</para>
        
        <para>A class or interface may not inherit a declaration with the same name as 
        a declaration it contains unless either:</para>
            
        <itemizedlist>
            <listitem>
                <para>the contained declaration directly or indirectly refines the 
                inherited declaration,</para>
            </listitem>
            <listitem>
                <para>the contained declaration is a block local declaration, or</para>
            </listitem>
            <listitem>
                <para>the inherited declaration is a block local declaration.</para>
            </listitem>
        </itemizedlist>
        
        <para>A class or interface may not inherit two declarations with the same name 
        unless either:</para>

        <itemizedlist>
            <listitem>
                <para>both of the inherited declarations are <literal>formal</literal>
                and directly or indirectly refine some member of a common 
                supertype,</para>
            </listitem>
            <listitem>
                <para>the class or interface contains a declaration that directly or 
                indirectly refines both the inherited declarations (in which case both 
                the inherited declarations directly or indirectly refine some member 
                of a common supertype),</para>
            </listitem>
            <listitem>
                <para>one of the inherited declarations directly or indirectly refines 
                the other inherited declaration, or</para>
            </listitem>
            <listitem>
                <para>at least one of the inherited declarations is a block local 
                declaration.</para>
            </listitem>
        </itemizedlist>
        
    </section>
    
    <section id="scopeofdeclaration">
        <title>Scope of a declaration</title>
        
        <para>The scope of a declaration is governed by the body or package in which it 
        occurs. A declaration is <emphasis>in scope</emphasis> at a program element if
        and only if either:</para>
        
        <itemizedlist>
            <listitem>
                <para>the declaration is a parameter or type parameter of a declaration 
                whose body contains the program element,</para>
            </listitem>
            <listitem>
                <para>the declaration is a control structure variable or iteration 
                variable belonging to a block of a control structure that contains the 
                program element,</para>
            </listitem>
            <listitem>
                <para>the program element belongs to or is contained in the body of the 
                declaration itself,</para>
            </listitem>
            <listitem>
                <para>the program element belongs to or is contained in the body of a 
                class or interface which inherits the declaration,</para>
            </listitem>
            <listitem>
                <para>the declaration directly occurs in a body containing the program
                element,</para>
            </listitem>
            <!--listitem>
                <para>the program element is the <literal>while</literal> condition of a 
                <literal>do/while</literal> loop and the <literal>do</literal> block of 
                the loop contains the declaration,</para>
            </listitem-->
            <listitem>
                <para>the declaration is imported by the compilation unit containing the 
                program element and is visible to the program element, or</para>
            </listitem>
            <listitem>
                <para>the declaration is a toplevel declaration in the package containing 
                the program element.</para>
            </listitem>
        </itemizedlist>
        
        <para>Where:</para>
        
        <itemizedlist>
        <listitem>
        <para>A control structure variable or iteration variable <emphasis>belongs</emphasis> 
        to a block of a control structure if the block immediately follows the declaration 
        of the variable.</para>
        </listitem>
        <listitem>
        <para>A program element <emphasis>belongs</emphasis> to a declaration if it occurs
        in the <literal>extends</literal>, <literal>satisfies</literal>, <literal>of</literal>,
        <literal>given</literal>, <literal>abstracts</literal>, <literal>adapts</literal> or
        <literal>is</literal> clause of the declaration.</para>
        </listitem>
        </itemizedlist>
        
    </section>
    
    <section id="hidingdeclaration">
        <title>Hiding a declaration</title>
    
        <para>If two declarations with the same name are both in scope at a certain program 
        element, then one declaration may <emphasis>hide</emphasis> the other declaration.</para>
        
        <!--
        <itemizedlist>
            <listitem>
                <para>A declaration that directly occurs in the inner body hides a declaration, 
                parameter, type parameter or control structure variable of the outer body.</para>
            </listitem>
            <listitem>
                <para>If the inner body is a class or interface, a declaration inherited by the 
                inner body hides a declaration, parameter, type parameter or control structure 
                variable of the outer body.</para>
            </listitem>
            <listitem>
                <para>If the inner body is a control structure, a control structure or iteration 
                variable of the inner body hides any declaration in scope the outer body.</para>
            </listitem>
        </itemizedlist>
        
         -->
         
        <itemizedlist>
            <listitem>
                <para>If an inner body is contained (directly or indirectly) in an outer 
                body, a declaration that is in scope in the inner body but is not in 
                scope in the outer body hides a declaration that is in scope in the outer 
                body. (In particular, a declaration inherited by a nested class or 
                interface hides a declaration of the containing body.)</para>
            </listitem>
            <listitem>
                <para>An block-local declaration of a class containing the program element 
                hides a declaration inherited by the class.</para>
            </listitem>
            <listitem>
                <para>An <literal>actual</literal> declaration hides the declaration it
                refines.</para>
            </listitem>
            <listitem>
                <para>A declaration occurring in a body containing the program element 
                hides a declaration imported by the compilation unit containing the body
                or implicitly imported from the module <literal>ceylon.language</literal>.</para>
            </listitem>
            <listitem>
                <para>A toplevel declaration of the package containing the program element 
                hides a declaration implicitly imported from the module 
                <literal>ceylon.language</literal>.</para>
            </listitem>
            <listitem>
                <para>A declaration explicitly imported by the compilation unit containing
                the program element hides a declaration implicitly imported from the module 
                <literal>ceylon.language</literal>.</para>
            </listitem>
            <!--listitem>
                <para>A toplevel declaration of the compilation unit containing the program 
                element hides a declaration explicitly imported by the compilation unit.</para>
            </listitem-->
            <listitem>
                <para>A declaration explicitly imported by the compilation unit containing 
                the program element hides a toplevel declaration of <!--another compilation unit
                in--> the package containing the compilation unit.</para>
            </listitem>
            <listitem>
                <para>A declaration explicity imported by name in the compilation unit 
                containing the program element hides a declaration explicitly imported 
                by wildcard in the compilation unit.</para>
            </listitem>
        </itemizedlist>
        
        <para>For example, the following code is legal:</para>
        
        <programlisting>class Person(name) {
    String name;
    shared String lowerCaseName {
        String name = this.name.lowercased;
        return name;
    }
}</programlisting>
        
        <para>As is this code:</para>
        
        <programlisting>class Point(x, y) {
    shared Float x; 
    shared Float y;
}

class Complex(Float x, Float y=0.0) 
        extends Point(x, y) {}</programlisting>
        
    </section>
    
    <section id="referenceabilityofdeclaration">
        <title>Referenceability of a declaration</title>
        
        <para>A declaration may be in scope at a program element, but not 
        <emphasis>referenceable</emphasis> at the program element. A declaration is 
        referenceable at a program element if the declaration is in scope at the program 
        element and either:</para>
        
        <itemizedlist>
            <listitem>
                <para>the program element occurs within the lexical scope of the 
                declaration, or</para>
            </listitem>
            <listitem>
                <para>the declaration does not directly occur in a block or in the
                initializer section of a class body.</para>
            </listitem>
        </itemizedlist>
        
        <!--itemizedlist>
            <listitem>
                <para>the declaration is a parameter or type parameter,</para>
            </listitem>
            <listitem>
                <para>the declaration is a control structure variable or iteration 
                variable,</para>
            </listitem>
            <listitem>
                <para>the program element belongs to or is contained in the body of the 
                declaration itself,</para>
            </listitem>
            <listitem>
                <para>the program element belongs to or is contained in the body of a 
                class or interface which inherits the declaration,</para>
            </listitem>
            <listitem>
                <para>the program element occurs within the lexical scope of the 
                declaration,</para>
            </listitem>
            <listitem>
                <para>the declaration directly occurs in an interface body,</para>
            </listitem>
            <listitem>
                <para>the declaration directly occurs in the declaration section of a class 
                body, or</para>
            </listitem>
            <listitem>
                <para>the declaration is a toplevel declaration.</para>
            </listitem>
        </itemizedlist-->
        
        <para>Note that these rules have very different consequences for:</para>
        
        <itemizedlist>
            <listitem>
                <para>declarations that occur in blocks and class initializer sections, and
                </para>
            </listitem>
            <listitem>
                <para>toplevel declarations, and declarations that occur in class declaration 
                sections and interface bodies.</para>
            </listitem>
        </itemizedlist> 
        
        <para>Declarations that occurs in a block or class initializer section are interspersed
        with procedural code that initializes references. Therefore, a program element in a 
        block or initializer may not refer to a declaration that occurs later in the block or 
        class body. This restriction does not apply to declarations that occur in an interface 
        body or class declaration section.</para>
        
        <para>The following toplevel function declarations, belonging to the same package, 
        are legal:</para>
    
        <programlisting>Float x => y;</programlisting>

        <programlisting>Float y => x;</programlisting>
        
        <para>This code is not legal, since the body of a function is an ordinary block:</para>
    
        <programlisting>Float->Float xy() {
    Float x => y;  //compiler error: y is not referenceable
    Float y => x;
    return x->y;
}</programlisting>

        <para>This code is not legal, since all three statements occur in the initializer 
        section of the class body:</para>
    
        <programlisting>class Point() {
    Float x => y;  //compiler error: y is not referenceable
    Float y => x;
    Float->Float xy = x->y;
}</programlisting>

        <para>However, this code <emphasis>is</emphasis> legal, since the statements occur 
        in the declaration section of the class body:</para>
    
        <programlisting>class Point() {
    Float x => y;
    Float y => x;
}</programlisting>

        <para>Likewise, this code is legal, since the statements occur in an interface 
        body:</para>
    
        <programlisting>interface Point {
    Float x => y;
    Float y => x;
}</programlisting>

    </section>
    
    <section id="typedetermination">
        <title>Type determinability of a declaration</title>
        
        <para>A value declared using the keyword <literal>value</literal> or a
        function declared using the keyword <literal>function</literal> may be 
        in scope at a program element, but its type may not be 
        <emphasis>determinable</emphasis> at the program element.</para>
        
        <para>The type of a value or function declared using the keyword 
        <literal>value</literal> or <literal>function</literal> is determinable 
        at a program element if the declaration is in scope at the program 
        element and the program element occurs within the lexical scope of the 
        declaration.</para>
        
        <comment><para>Note: the type of a value or function declared using
        the keyword <literal>value</literal> or <literal>function</literal> is
        not determinable within the body of the value or function itself.</para></comment>
        
        <para>For any other declaration, the type is considered determinable
        at a program element if the declaration is in scope at the program 
        element.</para>
        
        <para>The following code is not legal:</para>
        
        <programlisting>interface Point {
    value x => y;  //compiler error: type of y is not determinable
    value y => x;
}</programlisting>
        
        <para>However, this code is legal:</para>
        
        <programlisting>interface Point {
    value x => y;
    Float y => x;
}</programlisting>
        
    </section>
        
    <section id="unqualifiedreferenceresolution">
        <title>Unqualified reference resolution</title>
        
        <para>An <emphasis>unqualified reference</emphasis> is:</para>
        
        <itemizedlist>
            <listitem>
                <para>the type name in an unqualified type declaration, for 
                example <literal>String</literal> or <literal>Sequence</literal> 
                in <literal>Sequence&lt;String&gt;</literal>,</para>
            </listitem>
            <listitem>
                <para>the value name in an unqualified value reference, for 
                example <literal>counter</literal> in <literal>counter.count</literal>, 
                or</para>
            </listitem>
            <listitem>
                <para>the function or type name in an unqualified callable 
                reference, for example <literal>entries</literal> in 
                <literal>entries(people*.name)</literal> or <literal>Entry</literal>
                in <literal>Entry(name,item)</literal>.</para>
            </listitem>
        </itemizedlist>
        
        <para>If a program element contains an unqualified reference:</para>
        
        <itemizedlist>
            <listitem>
                <para>There must be at least one declaration with the given name in scope 
                at the program element.</para>
            </listitem>
            <listitem>
                <para>If multiple declarations with the given name are in scope at the 
                program element where the given name occurs, then there must be exactly 
                one such declaration which is not hidden by another declaration.</para>
            </listitem>
        </itemizedlist>
        
        <para>Then the given name refers to this unique unhidden declaration, and:</para> 
        
        <itemizedlist>
            <listitem>
                <para>the declaration must be referenceable at the program element,</para>
            </listitem>
            <listitem>
                <para>the type of the declaration must be determinable at the program 
                element, and</para>
            </listitem>
            <listitem>
                <para>if the declaration is forward-declared, it must be definitely
                initialized at the program element.</para>
            </listitem>
        </itemizedlist>
        
    </section>
    
    <section id="qualifiedreferenceresolution">
        <title>Qualified reference resolution</title>
        
        <para>A <emphasis>qualified reference</emphasis> is:</para>
        
        <itemizedlist>
            <listitem>
                <para>the type name in a qualified type declaration, for example 
                <literal>Buffer</literal> in <literal>BufferedReader.Buffer</literal>,</para>
            </listitem>
            <listitem>
                <para>the value name in a qualified value reference, for example
                <literal>count</literal> in <literal>counter.count</literal>, or</para>
            </listitem>
            <listitem>
                <para>the function or type name in a qualified callable reference, 
                for example <literal>split</literal> in <literal>text.split()</literal>,
                or <literal>Buffer</literal> in <literal>br.Buffer()</literal>.</para>
            </listitem>
        </itemizedlist>
        
        <para>Every qualified reference has a qualifying type:</para>
        
        <itemizedlist>
            <listitem>
                <para>For a type declaration, the qualifying type is the full
                qualified type the qualifies the type name.</para>
            </listitem>
            <listitem>
                <para>For a value reference or callable reference, the 
                qualifying type is the type of the receiver expression.</para>
            </listitem>
        </itemizedlist>
                
        <para>If a program element contains a qualified reference:</para>
        
        <itemizedlist>
            <listitem>
                <para>The qualifying type must have at least one member with the given 
                name which is visible at the program element.</para>
            </listitem>
            <listitem>
                <para>If there are multiple visible members with the given name, then 
                it is guaranteed by the type system that there is exactly one such 
                member which is not refined by another member.</para>
            </listitem>
        </itemizedlist>
        
        <comment><para>TODO: that's not true for intersection types! We need more detail
        here about member resolution for intersection and union types, including how we
        compute principal instantiations.</para></comment>
        
        <para>Then the given name refers to this unique member. If the program element 
        is contained in the body of a class or interface, and the member declaration 
        directly occurs in the body of the class or interface, and the qualified reference
        is a value reference or callable reference, and the receiver expression is a self 
        reference to the instance being initialized, then:</para>
        
        <itemizedlist>
            <listitem>
                <para>the member declaration must be referenceable at the program
                element,</para>
            </listitem>
            <listitem>
                <para>the type of the member must be determinable at the program 
                element, and</para>
            </listitem>
            <listitem>
                <para>if the member declaration is forward-declared, it must be 
                definitely initialized at the program element.</para>
            </listitem>
        </itemizedlist>
        
        <comment><para>TODO: what about "inherited" interfaces and <literal>abstract</literal>
        classes? Currently the compiler allows this!</para></comment>
        
    </section>
            
        <section id="closure">
            <title>Closure</title>
            
            <para>The principle of <emphasis>closure</emphasis> states a that nested body
            always has access to a set of values for all references declared by containing 
            bodies.</para>
    
            <para>If a declaration is nested directly or indirectly inside a class or interface 
            declaration, then there is always a <emphasis>current instance</emphasis> of the 
            class or interface when the nested declaration body is executed. The current 
            instance is determined as follows:</para>
            
            <itemizedlist>
                <listitem>
                    <para>for the innermost class or interface declaration that contains the 
                    nested declaration, the current instance is the receiving instance of the
                    invocation, evaluation, or assignment, and</para>
                </listitem>
                <listitem>
                    <para>for any other class or interface that contains the nested declaration,
                    the current instance is the same object that was the current instance when
                    the initializer of the current instance of the innermost class or interface 
                    declaration was executed.</para>
                </listitem>
            </itemizedlist>
            
            <para>For example:</para>
            
            <programlisting>Outer outerObject = Outer();
Inner innerObject = outerObject.Inner();
innerObject.member();</programlisting>
            
            <para>In this example, <literal>innerObject</literal> is the current instance of 
            <literal>Inner</literal> when <literal>member()</literal> is executed, and
            <literal>outerObject</literal> is the current instance of <literal>Outer</literal>.</para>
                        
            <para>If a declaration is nested directly or indirectly inside a block, then there 
            is always a <emphasis>current frame</emphasis> of the block when the nested 
            declaration is executed. The current frame contains the values of all references 
            declared by the block. The current frame is determined as follows:</para>
            
            <itemizedlist>
                <listitem>
                    <para>if the nested declaration is nested directly inside a block,
                    the current frame contains the current values at the point of execution
                    of the value reference expression or callable reference expression that
                    refers to the nested declaration, or, otherwise,</para>
                </listitem>
                <listitem>
                    <para>if the nested declaration is contained inside the body of another
                    nested declaration, the current frame is the current frame of the 
                    containing declaration at the point of execution of the value reference 
                    expression or callable reference expression that refers to the nested 
                    declaration.</para>
                </listitem>
            </itemizedlist>
            
            <para>For example:</para>
            
            <programlisting>String()() outerMethod(String s) {
    String() middleMethod() {
        String innerMethod() => s;
        return innerMethod;
    }
    return middleMethod;
}

String middleMethod()() => outerMethod("hello");
String innerMethod() => middleMethod();
String result = innerMethod();</programlisting>

            <programlisting>Object outerMethod(String s) {
    object middleObject {
        shared actual String string => s;
    }
    return middleObject;
}

Object middleObject = outerMethod("hello");
String result = middleObject.string;</programlisting>

            <para>In both examples, <literal>result</literal> refers to the value 
            <literal>"hello"</literal>.</para>
            
            <para>The set of <!--all declarations which belong directly to a containing body 
            of a nested declaration, together with the --> current instances of containing 
            classes and interfaces and current frames of containing blocks is called the 
            <emphasis>closure</emphasis> of the nested declaration.</para>           
            
        </section>
        
    <section id="containingbodies">
        <title>References within a closure</title>
        
        <para>The initializer of a class, or the body of a member of a class may instantiate,
        invoke, evaluate or assign members of the current instance of the class which defines 
        the initializer or member&mdash;the instance being instantiated or invoked&mdash;without 
        explicitly specifying the receiver, or by specifying a self reference 
        <literal>this</literal> as the receiver.</para>
        
        <para>The initializer of a nested class, or the body of a member of a nested class
        or nested interface may invoke, evaluate or assign members of the current instance 
        of the containing class or interface&mdash;the parent instance of the instance being 
        instantiated or invoked&mdash;without explicitly specifying the receiver, or by 
        specifying an outer instance reference <literal>outer</literal> as the receiver.</para>
        
        <para>A toplevel function or value body may not refer to a self reference, since 
        there is no current instance.</para>
        
        <para>The body of a value, function, or class nested inside the body of another 
        function or value may invoke or evaluate any <!--non-<literal>variable</literal>--> 
        block local value or block local method whose declaration indirectly occurs earlier 
        within the containing scope.</para>
        
        <para>When a member of a class is hidden by a block local declaration, the member 
        may be accessed via the self reference <literal>this</literal> or via the outer 
        instance reference <literal>outer</literal>:</para>
        
        <programlisting>shared class Item(name) {
    variable String name;
    shared void changeName(String name) {
        this.name = name;
    }
}</programlisting>
        
        <programlisting>class Catalog(name) {
    shared String name;
    class Schema(name) {
        shared String name;
        Catalog catalog => outer;
        String catalogName => outer.name;
        class Table(name) {
            shared String name;
            Schema schema => outer;
            String schemaName => outer.name;
            String catalogName => catalog.name;
        }
    }
}</programlisting>
        
        <para>When a toplevel declaration of a package is hidden by another declaration, 
        the toplevel declaration may be accessed via the containing package reference 
        <literal>package</literal>:</para>
        
        <programlisting>Integer n => 0;
Integer f(Integer n) => n+package.n;</programlisting>
        
        </section>
    
    </section>
    
    <section id="blocksandstatements">
        <title>Blocks and statements</title>
            
        <para>A <emphasis>block</emphasis> is list of semicolon-delimited statements, 
        control structures, and declarations, surrounded by braces.</para>
        
        <programlisting>Block: "{" (Declaration | Statement)* "}"</programlisting>
        
        <para>A <emphasis>statement</emphasis> is an assignment or specification, an 
        invocation of a method, an instantiation of a class, a control structure, a 
        control directive, or an assertion.</para>

        <programlisting>Statement: ExpressionStatement | Specification | Assertion | DirectiveStatement | ControlStructure</programlisting>
        
        <para>The statements and reference specifiers that directly occur in a block 
        are executed sequentially in the lexical order in which they occcur. Execution 
        of a block begins at the first statement or reference specifier. Execution of 
        a block terminates when the last statement or reference specifier of the block 
        finishes executing, or when a control directive that terminates the block is 
        executed, or when an exception is thrown by an evaluation, invocation, or
        instantiation.</para>
        
        <para>A statement or declaration contained in a block may not evaluate a value, 
        invoke a function, instantiate a class, or extend a class whose declaration 
        occurs later in the block.</para>
        
        <!-- 
        <para>A simple attribute or local may not be used in an expression until its value 
        has been explicitly specified or initialized. The Ceylon compiler guarantees this
        by evaluating all conditional branches that lead to the first use of an attribute
        of local in an expression. Each conditional branch must specify or assign a value 
        to the simple attribute or local before using it in an expression.</para>
        
        <para>Every simple attribute of a concrete class must be explicitly specified or 
        initialized by the initializer of the class or by the initializer of one of its 
        superclasses. The Ceylon compiler guarantees this by evaluating all conditional 
        branches that lead to termination of the initializer without an uncaught exception. 
        Each conditional branch must specify or assign a value to the simple attribute 
        before the initializer terminates without an uncaught exception.</para>
        
        <para>A simple attribute or local may not be the target of a specifier expression 
        if its value has already been specified. The Ceylon compiler guarantees this by 
        evaluating all conditional branches that lead to the use of a simple attribute or 
        local in a specifier expression. No conditional branch may specify a value to the 
        simple attribute or local before using it in a specifier expression.</para>
        
        <para>Every non-<literal>void</literal> method or attribute getter must terminate in
        the execution of a <literal>return</literal> or <literal>throw</literal> directive. 
        The Ceylon compiler guarantees this by evaluating all conditional branches that lead 
        to termination of the method. Each conditional branch must end in a 
        <literal>return</literal> or <literal>throw</literal> directive.</para>
        -->
        
        <comment><para>Note: an unused block local declaration results in a compiler 
        warning.</para></comment>
        
        <section id="expressionstatements">
            <title>Expression statements</title>
        
        <para>Only certain expressions are valid statements:</para>
        
        <itemizedlist>
            <listitem>
                <para>assignment,</para>
            </listitem>
            <listitem>
                <para>prefix or postfix increment or decrement,</para>
            </listitem>
            <listitem>
                <para>invocation of a method,</para>
            </listitem>
            <listitem>
                <para>instantiation of a class.</para>
            </listitem>
        </itemizedlist>
        
        <programlisting>ExpressionStatement: ( Assignment | IncrementOrDecrement | Invocation ) ";"</programlisting>
        
        <para>For example:</para>
        
        <programlisting>x += 1;</programlisting>
        <programlisting>x++;</programlisting>
        <programlisting>print("Hello");</programlisting>
        <programlisting>Main(process.arguments);</programlisting>
        
        </section>
        
        <section id="controldirectives">
            <title>Control directives</title>
            
        <para>Control directive statements end execution of the current block and force 
        the flow of execution to resume in some outer scope. They may only occur as the
        lexically last statement of a block.</para>

        <programlisting>DirectiveStatement: Directive ";"</programlisting>
        
        <para>There are four control directives:</para>
        
        <itemizedlist>
            <listitem>the <literal>return</literal> directive&mdash;to return a value from 
            a getter or non-<literal>void</literal> function or terminate execution of a 
            setter, class initializer, or <literal>void</literal> method,</listitem>
            <listitem>the <literal>break</literal> directive&mdash;to terminate a loop,</listitem>
            <listitem>the <literal>continue</literal> directive&mdash;to jump to the next iteration 
            of a loop, and</listitem>
            <listitem>the <literal>throw</literal> directive&mdash;to raise an exception.</listitem>
        </itemizedlist>
                
        <programlisting>Directive: Return | Throw | Break | Continue</programlisting>

        <para>For example:</para>
        
        <programlisting>throw Exception();</programlisting>
        <programlisting>return x+y;</programlisting>
        <programlisting>break;</programlisting>
        <programlisting>continue;</programlisting>
        
        <para>The <literal>return</literal> directive must sequentially occur in the body 
        of a function, getter, setter, or class initializer. In the case of a 
        setter, class initializer, or <literal>void</literal> function, no expression may 
        be specified. In the case of a getter or non-<literal>void</literal> function, an 
        expression must be specified. The expression type must be assignable to the return 
        type of the function or the type of the value. When the directive is executed, the 
        expression is evaluated to determine the return value of the function or getter.</para>
        
        <programlisting>Return: "return" (Expression | Function)?</programlisting>
        
        <para>The <literal>break</literal> directive must sequentially occur in the body 
        of a loop.</para>
        
        <programlisting>Break: "break"</programlisting>
        
        <para>The <literal>continue</literal> directive must sequentially occur in the body 
        of a loop.</para>
        
        <programlisting>Continue: "continue"</programlisting>
        
        <para>A <literal>throw</literal> directive may appear anywhere and may specify an 
        expression, whose type must be a subtype of type <literal>Exception</literal> 
        defined in <literal>ceylon.language</literal>. When the directive is executed, the 
        expression is evaluated and the resulting exception is thrown. If no expression is 
        specified, the directive is equivalent to <literal>throw Exception()</literal>.</para>
        
        <programlisting>Throw: "throw" Expression?</programlisting>
        
        </section>
        
        <section id="specificationstatements">
            <title>Specification statements</title>
            
        <para>A specification statement may specify or initialize the persistent 
        value of a forward-declared reference, or specify the implementation of a
        forward-declared getter or function.</para>
        
        <programlisting>Specification: ValueSpecification | LazySpecification</programlisting>
        
        <para>The persistent value of a forward-declared reference or the 
        implementation of a forward-declared function may be specified using 
        <literal>=</literal>. The specification statement consists of an unqualified 
        value reference and a specifier. The value reference must refer to a 
        declaration which sequentially occurs earlier in the body in which the 
        specification statement occurs.</para>
        
        <programlisting>ValueSpecification: MemberName Specifier ";"</programlisting>
        
        <para>The type of the specified expression must be assignable to the type of 
        the reference, or to the callable type of the function.</para>
        
        <programlisting>String greeting;
if (exists name) {
    greeting = "hello ``name``";
}
else {
    greeting = "hello world";
}</programlisting>
        
        <programlisting>String process(String input);
if (normalize) {
    process = String.normalized;
}
else {
    process = (String s) => s;
}</programlisting>
        
        <comment><para>Note: there is an apparent ambiguity here. Is the statement
        <literal>x=1;</literal> a value specification statement, or an assignment 
        expression statement? The language resolves this ambiguity by favoring the
        interpretation as a specification statement whenever that interpretation is
        viable. This is a transparent solution, since it accepts strictly more code 
        than the alternative interpretation, and for ambiguous cases the actual 
        semantics are identical between the two interpretations.</para></comment>
        
        <para>The implementation of forward-declared getter or function may be
        specified using <literal>=&gt;</literal>. The specification statement 
        consists of either:</para>
        
        <itemizedlist>
            <listitem>
                <para>an unqualified value reference and a lazy specifier, or</para>
            </listitem>
            <listitem>
                <para>a unqualified callable reference, one or more parameter lists, 
                and a lazy specifier.</para>
            </listitem>
        </itemizedlist>
        
        
        <para>The value reference or callable reference must refer to a declaration 
        which sequentially occurs earlier in the body in which the specification 
        statement occurs.</para>
        
        <para>A callable reference followed by a parameter list is itself considered 
        a callable reference, called a <emphasis>parameterized reference</emphasis>. 
        If the parameter list has type <literal>P</literal> then the callable reference 
        must have the exact type <literal>Callable&lt;R,P&gt;</literal> for some type 
        <literal>R</literal>. Then the type of the parameterized reference is
        <literal>R</literal>.</para>
        
        <programlisting>ParameterizedReference: MemberName Params+</programlisting>
        
        <para>Thus, the specification statement consists of a parameterized reference
        followed by a lazy specifier.</para>
        
        <programlisting>LazySpecification: (MemberName | ParameterizedReference) LazySpecifier ";"</programlisting>
        
        <para>The type of the specified expression must be assignable to the type of 
        the parameterized reference, or to the type of the value reference.</para>
        
        <programlisting>String greeting;
if (exists name) {
    greeting => "hello ``name``";
}
else {
    greeting => "hello world";
}</programlisting>
        
        <programlisting>String process(String input);
if (normalize) {
    process(String input) => input.normalized;
}
else {
    process(String s) => s;
}</programlisting>
        
        </section>
        
        <section id="definitereturn">
            <title>Definite return</title>
            
            <para>A sequence of statements may <emphasis>definitely return.</emphasis></para>
            
            <itemizedlist>
                <listitem>
                    <para>A sequence of statements definitely returns if it ends in a 
                    <literal>return</literal> or <literal>throw</literal> directive, or 
                    in a control structure that definitely returns.</para>
                </listitem>
                <listitem>
                    <para>A body definitely returns if it contains a list of statements
                    that definitely returns.</para>
                </listitem>
                <listitem>
                    <para>An <literal>if</literal> conditional definitely returns if it has
                    an <literal>else</literal> block and both the <literal>if</literal>
                    and <literal>else</literal> blocks definitely return.</para>
                </listitem>
                <listitem>
                    <para>A <literal>switch</literal> conditional definitely returns if all
                    <literal>case</literal> blocks definitely return and the <literal>else</literal> 
                    block, if any, definitely returns.</para>
                </listitem>
                <listitem>
                    <para>A <literal>for</literal> loop definitely returns if it has an
                    <literal>else</literal> block that definitely returns, and there is
                    no <literal>break</literal> directive in the <literal>for</literal>
                    block, or if the iterated expression type is a nonempty type, and
                    the <literal>for</literal> block definitely returns.</para>
                </listitem>
                <listitem>
                    <para>A <literal>while</literal> loop does not definitely return.</para>
                </listitem>
                <!--listitem>
                    <para>A <literal>do/while</literal> loop definitely returns if the 
                    <literal>do</literal> block definitely returns.</para>
                </listitem-->
                <listitem>
                    <para>A <literal>try/catch</literal> exception manager definitely 
                    returns if the <literal>try</literal> block definitely returns and
                    all <literal>catch</literal> blocks definitely return or if the
                    <literal>finally</literal> block definitely returns.</para>
                </listitem>
            </itemizedlist>
            
            <para>The body of a non-<literal>void</literal> method or getter must definitely 
            return.</para>
            
            <para>A body may not contain an additional statement, control structure, or
            declaration following a sequence of statements that definitely returns. Such a 
            statement, control structure, or declaration is considered 
            <emphasis>unreachable</emphasis>.</para>
            
        </section>
        
        <section id="definiteinitialization">
            <title>Definite initialization</title>
            
            <para>A sequence of statements may <emphasis>definitely initialize</emphasis> a
            forward-declared declaration.</para>
            
            <itemizedlist>
                <listitem>
                    <para>A sequence of statements definitely initializes a declaration if 
                    one of the statements is a specification statement or assigment 
                    expression for the declaration or a control structure that definitely 
                    initializes the declaration, or if the sequence of statements ends in 
                    a <literal>return</literal> or <literal>throw</literal> directive.</para>
                </listitem>
                <listitem>
                    <para>An <literal>if</literal> conditional definitely initializes a 
                    declaration if it has an <literal>else</literal> block and both the 
                    <literal>if</literal> and <literal>else</literal> blocks definitely
                    initialize the declaration.</para>
                </listitem>
                <listitem>
                    <para>A <literal>switch</literal> conditional definitely initializes a
                    declaration if all <literal>case</literal> blocks definitely initialize 
                    the declaration and the <literal>else</literal> block, if any, definitely 
                    initializes the declaration.</para>
                </listitem>
                <listitem>
                    <para>A <literal>for</literal> loop definitely initializes a declaration 
                    if it has an <literal>else</literal> block that definitely initializes 
                    the declaration, and there is no <literal>break</literal> directive in 
                    the <literal>for</literal> block, or if the iterated expression type is 
                    a nonempty type, and the <literal>for</literal> block definitely 
                    initializes the declaration.</para>
                </listitem>
                <listitem>
                    <para>A <literal>while</literal> loop does not definitely initialize a 
                    declaration.</para>
                </listitem>
                <!-- 
                <listitem>
                    <para>A <literal>do/while</literal> loop definitely initializes a local or 
                    simple attribute if the <literal>do</literal> block definitely initializes
                    the local or simple attribute.</para>
                </listitem>
                -->
                <listitem>
                    <para>A <literal>try/catch</literal> exception manager definitely initializes 
                    a declaration if the <literal>try</literal> block definitely initializes the 
                    declaration and all <literal>catch</literal> blocks definitely initialize the 
                    declaration or if the <literal>finally</literal> block definitely initializes 
                    the declaration.</para>
                </listitem>
            </itemizedlist>
            
            <para>A forward-declared declaration is considered <emphasis>definitely initialized</emphasis> 
            at a certain statement or declaration if its declaration has a specifier or initializer, 
            if it is referenced by a parameter, or if it is definitely initialized by the sequence 
            of statements from its declaration to the given statement or declaration.</para>
            
            <para>A forward-declared declaration must be definitely initialized wherever any value 
            reference or callable reference to it occurs as an expression within the body in which 
            it is declared.</para>
            
            <para>A <emphasis>shared</emphasis> forward-declared declaration must be definitely 
            initialized:</para>
            
            <itemizedlist>
                <listitem>
                    <para>at every <literal>return</literal> statement of the initializer of the 
                    containing class, and</para>
                </listitem>
                <listitem>
                    <para>at the very last expression statement, directive statement or 
                    specification statement of the initializer of the containing class.</para>
                </listitem>
            </itemizedlist>
            
            <para>A specification statement for a method or non-<literal>variable</literal> 
            reference, getter, or function may not (indirectly) occur in a <literal>for</literal> 
            or <literal>while</literal> block unless the declaration itself occurs within the same
            <literal>for</literal> or <literal>while</literal> block.</para>
            
        </section>
            
        <section id="definiteuninitialization">
            <title>Definite uninitialization</title>
            
            <para>A sequence of statements may <emphasis>possibly initialize</emphasis> a 
            forward-declared declaration.</para>
            
            <itemizedlist>
                <listitem>
                    <para>A sequence of statements possibly initializes a declaration if one of 
                    the statements is a specification statement for the declaration or a control 
                    structure that possibly initializes the declaration.</para>
                </listitem>
                <listitem>
                    <para>An <literal>if</literal> conditional possibly initializes a declaration 
                    if either the <literal>if</literal> block possibly initializes the declaration 
                    or if the <literal>else</literal> block, if any, possibly initializes the 
                    declaration.</para>
                </listitem>
                <listitem>
                    <para>A <literal>switch</literal> conditional possibly initializes a declaration 
                    if one of the <literal>case</literal> blocks possibly initializes the declaration 
                    or the <literal>else</literal> block, if any, possibly initializes the 
                    declaration.</para>
                </listitem>
                <listitem>
                    <para>A <literal>for</literal> loop possibly initializes a declaration if the 
                    <literal>for</literal> block possibly initializes the declaration or if it has 
                    an <literal>else</literal> block that possibly initializes the declaration.</para>
                </listitem>
                <listitem>
                    <para>A <literal>while</literal> loop possibly initializes a declaration if the 
                    <literal>while</literal> block possibly initializes the declaration.</para>
                </listitem>
                <listitem>
                    <para>A <literal>try/catch</literal> exception manager possibly initializes a 
                    declaration if the <literal>try</literal> block possibly initializes the 
                    declaration, if one of the <literal>catch</literal> blocks possibly initializes 
                    the declaration, or if the <literal>finally</literal> block possibly initializes 
                    the declaration.</para>
                </listitem>
            </itemizedlist>
            
            <para>A forward-declared declaration is considered <emphasis>definitely uninitialized</emphasis> 
            at a certain statement or declaration if:</para>
            
            <itemizedlist>
                <listitem>
                    <para>it is not possibly initialized by the sequence of statements from its declaration 
                    to the given statement or declaration,</para>
                </listitem>
                <listitem>
                    <para>the statement does not (indirectly) occur in the <literal>for</literal> block or
                    <literal>else</literal> block of a <literal>for</literal> loop with a <literal>for</literal> 
                    block that possibly initializes it,</para>
                </listitem>
                <listitem>
                    <para>the statement does not (indirectly) occur in the <literal>while</literal> block of 
                    a <literal>while</literal> loop with a <literal>while</literal> block that possibly 
                    initializes it,</para>
                </listitem>
                <listitem>
                    <para>the statement does not (indirectly) occur in a <literal>catch</literal> block 
                    of a <literal>try/catch</literal> exception manager with a <literal>try</literal> block 
                    that possibly initializes it, and</para>
                </listitem>
                <listitem>
                    <para>the statement does not (indirectly) occur in the <literal>finally</literal> block 
                    of a <literal>try/catch</literal> exception manager with a <literal>try</literal> block 
                    or <literal>catch</literal> block that possibly initializes it.</para>
                </listitem>
            </itemizedlist>
            
            <para>A method or non-<literal>variable</literal> local or simple attribute must be definitely 
            uninitialized wherever any value reference or callable reference to it occurs as a specification 
            statement within the body in which it is declared.</para>
            
        </section>
        
    </section>
    
    <section id="controlstructures">
        <title>Control structures and assertions</title>
        
        <para>Control of execution flow may be achieved using control directives and control 
        structures. Control structures include conditionals, loops, and exception management.</para>

        <para>Ceylon provides the following control structures:</para>
        
        <itemizedlist>
            <listitem>
                <para>the <literal>if/else</literal> conditional&mdash;for controlling execution 
                based upon a boolean condition, type condition, or check for a non-null or 
                non-empty value,</para>
            </listitem>
            <listitem>
                <para>the <literal>switch/case/else</literal> conditional&mdash;for controlling 
                execution using an enumerated list of values or types,</para>
            </listitem>
            <listitem>
                <para>the <literal>while</literal> loop&mdash;for loops which terminate based a 
                boolean condition,</para>
            </listitem>
            <listitem>
                <para>the <literal>for/else</literal> loop&mdash;for looping over elements of a 
                collection, and</para>
            </listitem>
            <listitem>
                <para>the <literal>try/catch/finally</literal> exception manager&mdash;for managing 
                exceptions and controlling the lifecycle of objects which require explicit 
                destruction.</para>
            </listitem>
        </itemizedlist>
                
        <programlisting>ControlStructure: IfElse | SwitchCaseElse | While | ForFail | TryCatchFinally</programlisting>
       
        <para>Control structures are not considered to be expressions, and therefore do not evaluate
        to a value.</para>
        
        <para><emphasis>Assertions</emphasis> are runtime checks upon program invariants, or 
        function preconditions and postconditions. An assertion failure represents a bug in
        the program, and is not considered recoverable. Therefore, assertions should not be 
        used to control "normal" execution flow.</para>
        
        <comment><para>Note: of course, in certain circumstances, it is appropriate to handle
        the exception that results from an assertion failure, for example, to display a message
        to the user, or in a testing framework to aggregate and report the failures that occurred
        in test assertions. A test failure may be considered "normal" occurrence from the point 
        of view of a testing framework, but it's not "normal" in the sense intended above.</para></comment>
        
        <section id="controlstructurevariables">
            <title>Control structure variables</title>
       
        <para>Some control structures allow inline declaration of a <emphasis>variable</emphasis>,
        a reference that is scoped to the control structure body.</para>
        
        <programlisting>TypedVariable: EntryType MemberName</programlisting>
        
        <para>In most cases, the explicit type be omitted.</para>
        
        <programlisting>Variable: EntryType? MemberName</programlisting>
        
        <para>If the type is missing from the declaration, the type of the variables is 
        inferred from the type of the expression that follows.</para>

        <comment><para>TODO: write down the rules for inferring the type of control structure
        variables!</para></comment>
        
        </section>
        
        <section id="iterationvariables">
            <title>Iteration variables</title>
       
            <para>A <literal>for</literal> loop requires an <emphasis>iteration variable</emphasis> 
            declaration. An iteration variable declaration must specify an iteration variable.</para>

            <programlisting>IteratorVariable: Variable | CallableVariable | EntryVariablePair</programlisting>
            
            <para>An iteration variable of type <literal>Entry</literal> may be specified in 
            destructured form.</para>
        
            <programlisting>EntryVariablePair: Variable "->" Variable</programlisting>
            
            <para>An iteration variable may be callable.</para>
            
            <programlisting>CallableVariable: (EntryType | "void")? MemberName Params+</programlisting>
        
            <para>If the return type is missing from the declaration, the return type of the 
            callable variable is inferred.</para>
            
            <comment><para>TODO: is there any value to allowing this syntax? It seems more regular,
            but I really can't see why I would ever want to write 
            <literal>for (f(Float x) in functions)</literal>. Perhaps it could help readability in 
            some cases?</para></comment>

        </section>
        
        <section id="controlstructureconditions">
            <title>Control structure conditions</title>
            
        <para>Some control structures expect conditions. There are four kinds of condition:</para>
        
        <itemizedlist>
            <listitem>
                <para>a <emphasis>boolean condition</emphasis> is satisfied when a boolean expression
                evaluates to <literal>true</literal>,</para>
            </listitem>
            <listitem>
                <para>an <emphasis>assignabilty condition</emphasis> is satisfied when an expression
                 evaluates to an instance of a specified type,</para>
            </listitem>
            <listitem>
                <para>an <emphasis>existence condition</emphasis> is satisfied when an expression 
                evaluates to a non-null value, and</para>
            </listitem>
            <listitem>
                <para>a <emphasis>nonemptiness condition</emphasis> is satisfied when an expression 
                evaluates to a non-null, non-empty value.</para>
            </listitem>
            <!--listitem>
                <para>a <emphasis>subtype condition</emphasis> is satisfies when a given type is a 
                subtype of the specified type.</para>
            </listitem-->
        </itemizedlist>
        
        <programlisting>Condition: BooleanCondition | IsCondition | ExistsOrNonemptyCondition</programlisting>
        
        <para>A condition list has one or more conditions.</para>
        
        <programlisting>ConditionList: "(" Condition ("," Condition) ")"</programlisting>
        
        <para>A condition list is satisfied if all of its constituent conditions are satisfied.
        The conditions are evaluated in the lexical order in which they occur in the condition
        list.</para>
        
        </section>
        
        <section id="booleanconditions">
            <title>Boolean conditions</title>
        
        <para>A boolean condition is just an expression.</para>
        
        <programlisting>BooleanCondition: Expression</programlisting>
        
        <para>The expression must be of type <literal>Boolean</literal>.</para>
        
        <para>The condition is satisfied if the expression evaluates to <literal>true</literal> when 
        the containing control structure is executed.</para>
        
        </section>
        
        <section id="assignabilityexistencenonemptinessconditions">
            <title>Assignability, existence, and nonemptiness conditions</title>
        
        <para>An assignability, existence, or nonemptiness condition may contain either:</para>
        
        <itemizedlist>
            <listitem>
                <para>an unqualified value reference to a non-<literal>variable</literal>,
                non-<literal>default</literal> reference, or</para>
            </listitem>
            <listitem>
                <para>an inline variable declaration together with an expression.</para>
            </listitem>
        </itemizedlist>
        
        <para>In the case of an assignability or existence condition, the type of the variable may be 
        inferred.</para>
                
        <programlisting>IsCondition: "!"? "is" (TypedVariable Specifier | EntryType MemberName)</programlisting>
        
        <programlisting>ExistsOrNonemptyCondition: ("exists" | "nonempty") (Variable Specifier | MemberName)</programlisting>
        
        <para>The type of the value reference or expression must be:</para>
        
        <itemizedlist>
            <listitem>
                <para>in the case of an assignability condition, a type which is not a subtype of 
                the specified type, but whose intersection with the specified type is not exactly 
                <literal>Nothing</literal>, except</para>
            </listitem>
            <listitem>
                <para>in the case of a <emphasis>negated assignability condition</emphasis> with 
                <literal>!is</literal>, a type whose intersection with the specified type is not 
                exactly <literal>Nothing</literal>, and which is not a supertype of the specified
                type, or</para>
            </listitem>
            <listitem>
                <para>in the case of an exists condition, a type whose intersection with 
                <literal>Null</literal> is not exactly <literal>Nothing</literal> and whose 
                intersection with <literal>Object</literal> is not exactly <literal>Nothing</literal>, 
                or</para>
            </listitem>
            <listitem>
                <para>in the case of a nonemptiness condition, a subtype of <literal>Anything[]?</literal> 
                whose intersection with <literal>[]</literal> is not exactly <literal>Nothing</literal>, 
                and whose intersection with <literal>[Nothing+]</literal> is not exactly 
                <literal>Nothing</literal>.</para>
            </listitem>
        </itemizedlist>
        
        <comment><para>Note: an assignability condition may narrow to an intersection or union 
        type.</para>
        <programlisting>if (is Printable&amp;Identifiable object) { ... }</programlisting>
        <programlisting>if (is Integer|Float num) { ... }</programlisting></comment>

        <para>Every existence or nonemptiness condition is equivalent to&mdash;and may be 
        considered an abbreviation of&mdash;an assignability condition:</para>
        
        <itemizedlist>
            <listitem>
                <para><literal>exists x</literal> is equivalent to <literal>is Object x</literal>, 
                and</para>
            </listitem>
            <listitem>
                <para><literal>nonempty x</literal> is equivalent to <literal>is [E+] x</literal>
                where <literal>x</literal> is an expression whose type is an invariant subtype of
                <literal>E[]?</literal>.</para>
            </listitem>
        </itemizedlist>
        
        <para>For an <literal>is</literal> condition:</para>
        
        <itemizedlist>
            <listitem>
                <para>if the condition contains a value reference, the value will be treated by the 
                compiler as having type <literal>T&amp;X</literal> where the conditional expression 
                is of type <literal>T</literal> and <literal>X</literal> is the specified type, 
                inside the block that immediately follows the condition, unless</para>
            </listitem>
            <listitem>
                <para>it is a <emphasis>negated assignability condition</emphasis> with 
                <literal>!is</literal>, in which case the value will be treated by the compiler as 
                having type <literal>T~X</literal>.</para>
            </listitem>
        </itemizedlist>
        
        <comment><para>TODO: define the <literal>~</literal> operation, which is in general not very
        robust due to decidability constraints.</para></comment>
        
        <para>If you prefer, you can think of the following:</para>
        
        <programlisting>Transaction tx = ...
if (is Usable tx) { ... }</programlisting>
        
        <para>As an abbreviation of:</para>
        
        <programlisting>if (is Transaction&amp;Usable tx = tx) { ... }</programlisting>
        
        <para>Where the <literal>tx</literal> declared by the condition hides the outer declaration
        of <literal>tx</literal> inside the block that follows.</para>
        
        <para>For an <literal>exists</literal> condition:</para>
        
        <itemizedlist>
            <listitem>
                <para>if the condition declares a variable, the declared type of the variable 
                must be a supertype of <literal>T&amp;Object</literal>, where the specifier 
                expression is of type <literal>T</literal>, or</para>
            </listitem>
            <listitem>
                <para>if the condition contains a value reference, the value will be treated by 
                the compiler as having type <literal>T&amp;Object</literal> inside the block that 
                immediately follows the condition, where the conditional expression is of type 
                <literal>T</literal>.</para>
            </listitem>
        </itemizedlist>
        
        <para>For a <literal>nonempty</literal> condition:</para>
        
        <itemizedlist>
            <listitem>
                <para>if the condition declares a variable, the declared type of the variable must 
                be a supertype of <literal>T&amp;[E+]</literal>, where the specifier expression is 
                of type <literal>T</literal> and <literal>T</literal> is an invariant subtype of
                <literal>E[]?</literal>, or</para>
            </listitem>
            <listitem>
                <para>if the condition contains a value reference, the value will be treated by the 
                compiler as having type <literal>T&amp;[E+]</literal> inside the block that 
                immediately follows the condition, where the conditional expression is of type 
                <literal>T</literal> and <literal>T</literal> is an invariant subtype of 
                <literal>E[]?</literal>.</para>
            </listitem>
        </itemizedlist>
        
        <para>If you prefer, you can think of the following:</para>
        
        <programlisting>if (exists name) { ... }</programlisting>
        
        <para>As an abbreviation of:</para>
        
        <programlisting>if (exists String name = name) { ... }</programlisting>
        
        <para>Where the <literal>name</literal> declared by the condition hides the outer declaration
        of <literal>name</literal> inside the block that follows.</para>
        
        <para>The condition is satisfied if the value reference or expression evaluates to an 
        instance of the required type when the control structure containing the condition is
        executed:</para>
        
        <itemizedlist>
            <listitem>
                <para>for an assignability condition, the condition is satisfied if the expression 
                evaluates to an instance of the specified type when the control structure is 
                executed,</para>
            </listitem>
            <listitem>
                <para>for an existence condition, the condition is satisfied unless the expression 
                evaluates to an instance of <literal>Null</literal> when the control structure 
                is executed, or</para>
            </listitem>
            <listitem>
                <para>for a nonemptiness expression, the condition is satisfied unless the 
                expression evaluates to an instance of <literal>[]|Null</literal> when the 
                control structure is executed.</para>
            </listitem>
        </itemizedlist>
        
        <!--para>Note that these are formal definitions. In fact, the compiler erases 
        <literal>Nothing|T</literal> to <literal>T</literal> before generating bytecode.
        So <literal>if (exists x)</literal> is actually processed as <literal>if (x!=null)</literal>
        by the virtual machine.</para-->
        
        </section>
                
        <!--section id="subtypeconditions">
            <title>Subtype conditions</title>
        
        <para>A subtype condition specifies a <emphasis>specified type</emphasis> (first) and a 
        <emphasis>given type</emphasis> (second).</para>
        
        <programlisting>SatisfiesCondition: "satisfies" Type Type</programlisting>        
        
        <para>The given type will be treated by the compiler as a subtype of the specified type 
        inside the block that immediately follows the condition.</para>
        
        <para>The condition is satisfied if the given type is a subtype of the specified type when 
        the control structure containing the condition is executed.</para>
        
        </section-->
        
        <!--section id="exhaustivecaselists">
            <title>Exhaustive lists of cases</title>
            
            <para>A <literal>switch</literal> statement may be <emphasis>exhaustive</emphasis>. 
            To determine if a <literal>switch</literal> is exhaustive, we consider the 
            <emphasis>exhaustive list of cases</emphasis> of the <literal>switch</literal>
            expression type.</para>
            
            <para>The <emphasis>exhaustive list of cases of an enumerated type</emphasis> 
            <literal>T</literal> comprises the following types:</para>
            
            <itemizedlist>
                <listitem>
                    <para>every case of <literal>T</literal> which is an anonymous class, and</para>
                </listitem>
                <listitem>
                    <para>every case of <literal>T</literal> which is not itself an enumerated 
                    type, together with</para>
                </listitem>
                <listitem>
                    <para>the exhaustive list of cases of every case of <literal>T</literal>
                    which is itself an enumerated type.</para>
                </listitem>
            </itemizedlist>
            
            <para>The <emphasis>exhaustive list of cases of a union type</emphasis> 
            <literal>T|U|V|...</literal> comprises the following types:</para>
            
            <itemizedlist>
                <listitem>
                    <para>every type belonging to the union which is not an enumerated type, 
                    together with</para>
                </listitem>
                <listitem>
                    <para>the exhaustive list of cases of every type belonging to the union
                    which is an enumerated type.</para>
                </listitem>
            </itemizedlist>
            
        </section-->
        
        <section id="ifelse">
            <title><literal>if/else</literal></title>
            
            <para>The <literal>if/else</literal> conditional has the following form:</para>
            
            <programlisting>IfElse: If Else?</programlisting>

            <programlisting>If: "if" ConditionList Block</programlisting>
            
            <programlisting>Else: "else" (Block | IfElse)</programlisting>
            
            <para>When the construct is executed, the condition list is evaluated. If the 
            condition list is satisfied, the <literal>if</literal> block is executed. 
            Otherwise, the <literal>else</literal> block, if any, is executed.</para>
            
            <para>For example:</para>
            
            <programlisting>if (payment.amount &lt;= account.balance) {
    account.balance -= payment.amount;
    payment.paid = true;
}
else {
    throw NotEnoughMoneyException();
}</programlisting>
            
            <programlisting>shared void welcome(User? user) {
    if (exists user) {
        print("Welcome back, ``user.name``!");
    }
    else {
        print("Welcome to Ceylon!");
    }
}</programlisting>
            
            <programlisting>if (is CardPayment p = order.payment, 
        !p.paid) {
    p.card.charge(total);
}</programlisting>
            
        </section>
        
        <section id="switchcaseelse">
            <title><literal>switch/case/else</literal></title>
            
            <para>The <literal>switch/case/else</literal> conditional has the following 
            form:</para>
            
            <programlisting>SwitchCaseElse: Switch Cases</programlisting>
            
            <programlisting>Switch: "switch" "(" Expression ")"</programlisting>
            
            <programlisting>Cases: CaseItem+ DefaultCaseItem?</programlisting>

            <programlisting>CaseItem: "case" "(" Case ")" Block</programlisting>
            
            <programlisting>DefaultCaseItem: "else" Block</programlisting>

            <para>For a <literal>switch</literal> statement whose <literal>switch</literal> 
            expression is of type <literal>U</literal>, each <literal>case</literal> must 
            be either:</para> 
            
            <itemizedlist>
                <listitem>
                    <para>a list of value references of form <literal>case (x, y, z)</literal> 
                    where each value reference <literal>x</literal>, <literal>y</literal>, and 
                    <literal>z</literal> refers to an anonymous class that is a subtype of 
                    <literal>U</literal>, or</para>
                </listitem>
                <listitem>
                    <para>an assignability condition of form <literal>case (is V)</literal> 
                    where the intersection type <literal>V&amp;U</literal> is not exactly
                    <literal>Nothing</literal>.</para>
                </listitem>
            </itemizedlist>
            
            <para>Two <literal>case</literal>s are said to be <emphasis>disjoint</emphasis> 
            if the intersection of their types is exactly <literal>Nothing</literal>. In every
            <literal>switch</literal> statement, all <literal>case</literal>s must be mutually 
            disjoint.</para>
            
            <para>A <literal>switch</literal> is <emphasis>exhaustive</emphasis> if the union 
            type formed from by the types of the <literal>case</literal>s of the 
            <literal>switch</literal> covers the <literal>switch</literal> expression type.</para>
            
            <para>If no <literal>else</literal> block is specified, the <literal>switch</literal> 
            must be exhaustive. <!--Conversely, if the <literal>switch</literal> is exhaustive, 
            no <literal>else</literal> block may be specified.--></para>
            
            <programlisting>Case: Expression ("," Expression)* | "is" EntryType</programlisting>
            
            <comment><para>Note: an assignability condition <literal>case</literal> may narrow to 
            an intersection or union type.</para>
            <programlisting>case (is Format &amp; IdentifiableObject) { ... }</programlisting>
            <programlisting>case (is Integer | Float) { ... }</programlisting></comment>

            <para>If a <literal>switch</literal> has an assignability condition <literal>case</literal>,
            then the <literal>switch</literal> expression must be an unqualified value reference to 
            a non-<literal>variable</literal>, non-<literal>default</literal> reference.</para>
            
            <para>For an assignability condition <literal>case</literal>, the value referred by the
            <literal>switch</literal> expression will be treated by the compiler as having the 
            intersection type of its declared type with the specified type inside the <literal>case</literal> 
            block. This intersection type must not be exactly <literal>Nothing</literal>.</para>
            
            <para>For example:</para>

            <programlisting>Boolean? maybe = ... ;
switch (maybe) 
case (null, false) {
    return false;
}
case (true) { 
    return true;
}</programlisting>
            
            <programlisting>Integer|Float number = ... ;
switch (number)
case (is Integer) { 
    return sqrt(number.float);
} 
case (is Float) { 
    return sqrt(number);
}</programlisting>
            
            <para>A Java-style overloaded method may be emulated as follows:</para>
            
            <programlisting>shared void print&lt;Printable&gt;(Printable printable) 
        given Value of String | Integer | Float {
    switch (printable)
    case (is String) { 
        print("\"``printable``\""); 
    }
    case (is Integer) { 
        print(printable + ".00"); 
    }
    case (is Float) { 
        print(formatFloat(printable, 2)); 
    }
}</programlisting>

            <!--para>Or, even better:</para>
            
            <programlisting>shared Value join&lt;Value&gt;(Value x, Value y) 
        given Value of String | Integer {
    switch (Value)
    case (satisfies String) { 
        return x+y;
    }
    case (satisfies Integer) { 
        return (IntegerFormat(x,2)+IntegerFormat(y,2)).parseInteger(2);
    }
}</programlisting-->
            
        </section>
        
        <section id="forelse">
            <title><literal>for/else</literal></title>
            
             <para>The <literal>for/else</literal> loop has the following form:</para>
             
            <programlisting>ForFail: For Fail?</programlisting>

            <programlisting>For: "for" ForIterator Block</programlisting>
            
            <programlisting>Fail: "else" Block</programlisting>

            <para>The <literal>for</literal> iterator consists of an iteration variable 
            declaration and an iterated expression that contains the range of values to 
            be iterated.</para>
            
            <programlisting>ForIterator: "(" IteratorVariable "in" Expression ")"</programlisting>

            <para>The type of the iterated expression depends upon the iteration variable 
            declarations:</para>
            
            <itemizedlist>
            <listitem>
                <para>The iterated expression must be an expression of type assignable to 
                <literal>Iterable&lt;X&gt;</literal> <!--or <literal>Iterator&lt;X&gt;</literal>-->
                where <literal>X</literal> is the declared type of the iteration variable.</para> 
            </listitem>
            <listitem>
                <para>If two iteration variables are defined, the iterated expression type 
                must be assignable to <literal>Iterable&lt;Entry&lt;U,V&gt;&gt;</literal> <!--or 
                <literal>Iterator&lt;Entry&lt;U,V&gt;&gt;</literal>--> where <literal>U</literal>
                and <literal>V</literal> are the declared types of the iteration variables.</para>
            </listitem>
            </itemizedlist>
            
            <para>When the construct is executed:</para>
            
            <itemizedlist>
                <listitem>
                    <para><!--if the iterated expression is of type <literal>Iterable</literal>,-->
                    the iterator is obtained by evaluating <literal>iterator</literal>, and 
                    then</para>
                </listitem>
                <listitem>
                    <para>the <literal>for</literal> block is executed once for each value 
                    of type <literal>X</literal> produced by the iterator, until the iterator 
                    is exhausted, or until a <literal>break</literal>, <literal>return</literal>,
                    or <literal>throw</literal> directive is executed.</para>
                </listitem>
            </itemizedlist>
            
            <para>Note that:</para>
            
            <itemizedlist>
                <listitem>
                    <para>if the iterated expression is also of type <literal>Sequence&lt;X&gt;</literal>,
                    the compiler is permitted to optimize away the use of <literal>Iterator</literal>, 
                    instead using indexed element access.</para>
                </listitem>
                <listitem>
                    <para>if the iterated expression is a range constructor expression, the compiler 
                    is permitted to optimize away creation of the <literal>Range</literal>, and generate
                    the indices using the <literal>successor</literal> operation.</para>
                </listitem>
            </itemizedlist>
            
            <para>We say that the loop <emphasis>exits early</emphasis> if it ends via execution 
            of a <literal>break</literal>, <literal>return</literal>, or <literal>throw</literal>
            directive. Otherwise, we say that the loop <emphasis>completes</emphasis> normally.</para>
             
            <para>If the loop completes normally, the <literal>else</literal> block is executed. 
            Otherwise, if the loop exists early, the <literal>else</literal> block is not executed.</para>
                                
            <para>For example:</para>

            <programlisting>for (p in people) { 
    print(p.name);
}</programlisting>

            <programlisting>variable Float sum := 0.0;
for (i in -10..10) {
    sum += x[i] else 0.0;
}</programlisting>
            
            <programlisting>for (word -> freq in wordFrequencyMap) { 
    print("The frequency of ``word`` is ``freq``."); 
}</programlisting>
            
            <programlisting>for (p in group) {
    if (p.age >= 18) {
        log.info("Found an adult: ``p.name``.");
        break;
    }
}
else {
    log.info("No adult in group.");
}
</programlisting>
            
        </section>
        
        <section id="while">
            <title><literal>while</literal></title>
            
            <para>The <literal>while</literal> loop has the form:</para>
            
            <programlisting>While: LoopCondition Block</programlisting>
            
            <para>The loop condition list determines when the loop terminates.</para>
            
            <programlisting>LoopCondition: "while" ConditionList</programlisting>
            
            <para>When the construct is executed, the loop condition list is evaluated 
            repeatedly until the first time the condition list is not satisfied, or 
            until a <literal>break</literal>, <literal>return</literal>, or 
            <literal>throw</literal> directive is executed. Each time the condition is 
            satisfied, the block is executed.</para>
            
            <comment><para>TODO: does <literal>while</literal> need a <literal>fail</literal> 
            block? Python has it, but what is the real usecase?</para></comment>
            
            <para>For example:</para>
            
            <programlisting>variable Integer n=0;
variable [Integer*] seq = [];
while (n&lt;=max) {
    seq=seq.withTrailing(n);
    n+=step(n);
}</programlisting>
            
        </section>

        <section id="trycatchfinally">
            <title><literal>try/catch/finally</literal></title>
            
            <para>The <literal>try/catch/finally</literal> exception manager has the 
            form:</para>
            
            <programlisting>TryCatchFinally: Try Catch* Finally?</programlisting>

            <programlisting>Try: "try" ("(" Resource ")")? Block</programlisting>
            
            <programlisting>Catch: "catch" "(" Variable ")" Block</programlisting>
            
            <programlisting>Finally: "finally" Block</programlisting>

            <para>Each <literal>catch</literal> block defines a variable. The type of
            the variable must be assignable to <literal>Exception</literal> in
            <literal>ceylon.language</literal>. If no type is explicitly specified, 
            the type is inferred to be <literal>Exception</literal>.</para> 
            
            <comment><para>Note: a <literal>catch</literal> block type may be a union 
            or intersection type:</para>
            <programlisting>catch (NotFoundException|DeletedException e) { ... }</programlisting></comment>
            
            <para>If there are multiple <literal>catch</literal> blocks in a certain
            control structure, then:</para>
            
            <itemizedlist>
                <listitem>
                    <para>The type of a <literal>catch</literal> variable may not be 
                    a subtype of any catch variable of an earlier <literal>catch</literal> 
                    block belonging to the same control structure.</para>
                </listitem>
                <listitem>
                    <para>If the type of a <literal>catch</literal> variable is a union
                    type <literal>E1|E2|...|En</literal> then no member <literal>Ei</literal>
                    of the union may be a subtype of any catch variable of an earlier 
                    <literal>catch</literal> block belonging to the same control structure.</para>
                </listitem>
            </itemizedlist>
            
            <para>The <literal>try</literal> block may declare a <emphasis>resource</emphasis>
            expression, which may be either:</para>
            
            <itemizedlist>
                <listitem><para>an unqualified value reference to a non-<literal>variable</literal> 
                reference,</para></listitem>
                <listitem><para>an instantiation expression, or</para></listitem>
                <listitem><para>an inline variable declaration together with an expression.</para></listitem>
            </itemizedlist>
            
            <para>A resource expresson produces a heavyweight object that must be 
            released when execution of the <literal>try</literal> terminates. Each 
            resource expression must be of type assignable to <literal>Closeable</literal>
            in <literal>ceylon.language</literal>.</para>
            
            <programlisting>Resource: MemberName | InitializerReference Arguments | Variable Specifier </programlisting>
            
            <para>When the construct is executed:</para>
            
            <itemizedlist>
                <listitem>
                    <para>the resource expression, if any, is evaluated, and then 
                    <literal>open()</literal> is called on the resulting resource 
                    instance, then</para>
                </listitem>
                <listitem>
                    <para>the <literal>try</literal> block is executed, then</para>
                </listitem>
                <listitem>
                    <para><literal>close()</literal> is called on the resource 
                    instance, if any, with the exception that propagated out of 
                    the <literal>try</literal> block, if any, then</para>
                </listitem>
                <listitem>
                    <para>if an exception did propagate out of the <literal>try</literal> 
                    block, the first <literal>catch</literal> block with a variable 
                    to which the exception is assignable, if any, is executed, and 
                    then</para>
                </listitem>
                <listitem>
                    <para>the <literal>finally</literal> block, if any, is 
                    executed.</para>
                </listitem>
            </itemizedlist>
            
            <comment><para>TODO: Precisely what happens if <literal>close()</literal> 
            throws an exception? Wrap and rethrow the exception as a 
            <literal>CloseException</literal>, bypassing any handler for the exception 
            from the <literal>try</literal> block?</para></comment>
            
            <para>For example:</para>
            
            <programlisting>try (file = File(path)) {
    file.open(readOnly);
    ...
}
catch (FileNotFoundException fnfe) {
    print("file not found: ``path``");
}
catch (FileReadException fre) {
    print("could not read from file: ``path``");
}
finally {
    assert (file.closed);
}</programlisting>
            
            <programlisting>try (Transaction()) {
    try (s = Session()) {
        return s.get(Person, id);
    }
    catch (NotFoundException|DeletedException e) {
        return null;
    }
}</programlisting>
            
        </section>
        
        <section id="assertions">
            <title>Assertions</title>
            
            <para>An assertion has an asserted condition list and, optionally, an 
            annotation list.</para>
            
            <programlisting>Assertion: Annotations "assert" ConditionList ";"</programlisting>
            
            <para>When the assertion is executed, the condition list is evaluated.
            If the condition list is not satisfied, an exception of type 
            <literal>AssertionFailure</literal> in <literal>ceylon.language</literal>
            is thrown.</para>
            
            <para>The message carried by the assertion failure may be specified
            using a <literal>doc</literal> annotation.</para>
            
            <programlisting>"total must be less than well-defined bound"
assert (exists bound, total&lt;bound);</programlisting>
            
            <para>If the assertion contains an assignability, existence, or 
            nonemptiness condition containing a value reference then the compiler 
            treats the referenced value as having a narrowed type at program 
            elements that occur in the lexical scope of the assertion.</para>
            
            <programlisting>{Element*} elements = ... ;
assert (nonempty elements);
Element first = elements.first;</programlisting>
            
        </section>
         
    </section>

</chapter>
