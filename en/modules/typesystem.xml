<chapter id="typesystem">
    <title>Type system</title>
    
    <para>Every value in a Ceylon program is an instance of a type that can be expressed 
    within the Ceylon language as a <emphasis>class</emphasis>. The language does not 
    define any primitive or compound types that cannot, in principle, be expressed within 
    the language itself.</para>
    
    <para>A class is a recipe for producing new values, called <emphasis>instances</emphasis>
    of the class (or simply <emphasis>objects</emphasis>), and defines the operations and 
    attributes of the resulting values. A class instance may hold references to other 
    objects, and has an identity distinct from these references.</para>
    
    <para>Each class declaration defines a type. However, not all types are classes. It 
    is often advantageous to write generic code that abstracts the concrete class of a 
    value. This technique is called <emphasis>polymorphism</emphasis>. Ceylon supports 
    two different kinds of polymorphism:</para>
    
    <itemizedlist>
        <listitem>
            <para><emphasis>subtype polymorphism</emphasis>, where a subtype <literal>B</literal>
            inherits a supertype <literal>A</literal>, and</para>
        </listitem>
        <listitem>
            <para><emphasis>parametric polymorphism</emphasis>, where a type definition 
            <literal>A&lt;T&gt;</literal> is parameterized by a <emphasis>generic type 
            parameter</emphasis> <literal>T</literal>.</para>
        </listitem>
    </itemizedlist>
    
    <para>Ceylon, like Java and many other object-oriented languages, supports a single
    inheritance model for classes. A class may directly inherit at most one other class, 
    and all classes eventually inherit, directly or indirectly, the class 
    <literal>Anything</literal> defined in the module <literal>ceylon.language</literal>, 
    which acts as the root of the class hierarchy.</para>
    
    <para>A truly hierarchical type system is much too restrictive for more abstract 
    programming tasks. Therefore, in addition to classes, Ceylon recognizes the following 
    kinds of type:</para>
    
    <itemizedlist>
        <listitem>
            <para>An <emphasis>interface</emphasis> is an abstract type schema that cannot
            itself be directly instantiated. An interface may define concrete members, but
            these members may not hold references to other objects. A class may inherit one 
            or more interfaces. An instance of a class that inherits an interface is also 
            considered an instance of the interface.</para>
        </listitem>
        <listitem>
            <para>A <emphasis>generic type parameter</emphasis> is considered a type
            within the declaration that it parameterizes. In fact, it is an abstraction
            over many types: it generalizes the declaration to all types which could be 
            assigned to the parameter.</para>
        </listitem>
        <listitem>
            <para>A <emphasis>produced type</emphasis> is formed by specifying arguments
            for the generic type parameters of a parameterized type.</para>
        </listitem>
        <listitem>
            <para>A <emphasis>union type</emphasis> is a type to which each of an 
            enumerated list of produced types is assignable.</para>
        </listitem>
        <listitem>
            <para>An <emphasis>intersection type</emphasis> is a type which is assignable 
            to each of an enumerated list of produced types.</para>
        </listitem>
    </itemizedlist>
    
    <para>Although we often use the term <emphasis>parameterized type</emphasis> or even
    <emphasis>generic type</emphasis> to refer to a parameterized type definition, it is
    important to keep in mind that a parameterized type definition is not itself a type.
    Rather, it is a <emphasis>type constructor</emphasis>, a function that maps types 
    to types. Given a list of type arguments, the function yields a produced type.</para>
    
    <para>In light of the fact that Ceylon makes it so easy to construct new types from
    existing types <emphasis>without the use of inheritance</emphasis>, by forming unions, 
    intersections, and produced types, it's often useful to assign a name to such a type.</para>
    
    <itemizedlist>
        <listitem>
            <para>A <emphasis>type alias</emphasis> is a synonym for an expression 
            involving other types or generic types. A type alias may itself be
            parameterized.</para>
        </listitem>
    </itemizedlist>
    
    <para>The Ceylon type system is much more complete than most other object oriented
    languages. In Ceylon, it's possible to answer questions that might at first sound
    almost nonsensical if you're used to languages with more traditional type systems. 
    For example:</para>
    
    <itemizedlist>
        <listitem>
            <para>What is the type of a function which accepts a non-null value and returns a 
            <literal>String</literal>?</para>
        </listitem>
        <listitem>
            <para>What is the type of a local that may or may not hold a value of 
            type <literal>Element</literal>?</para>
        </listitem>
        <listitem>
            <para>What is the type of a parameter that accepts either an 
            <literal>Integer</literal> or a <literal>Float</literal>s?</para>
        </listitem>
        <listitem>
            <para>What is the type of a parameter that accepts one or more
            <literal>String</literal>s?</para>
        </listitem>
        <listitem>
            <para>What is the type of a parameter that accepts values which are instances 
            of both <literal>Persistent</literal> and <literal>Printable</literal>?</para>
        </listitem>
        <listitem>
            <para>What is the type of a sequence consisting of a <literal>String</literal>
            followed by two <literal>Float</literal>s?</para>
        </listitem>
        <!--listitem>
            <para>What is the type that represents methods that accept two <literal>Float</literal>
            values?</para>
        </listitem>
        <listitem>
            <para>What is the type that represents subclasses of <literal>Renderer</literal> 
            which must be provided at instantiation time with a function that accepts an 
            object and produces a <literal>String</literal>?</para>
        </listitem-->
    </itemizedlist>
    
    <para>The answers, as we shall see, are: <literal>String(Object)</literal>, 
    <literal>Element?</literal>, <literal>Integer|Float</literal>, <literal>{String+}</literal>,
    <literal>Persistent&amp;Printable</literal>, and <literal>[String,Float,Float]</literal>.</para>
    <!--<literal>Method&lt;Object,Anything,Float,Float&gt;</literal>,
    <literal>Class&lt;Renderer,String(Object)&gt;</literal>-->
        
    <para>It's important that there is always a unique "best" answer to questions
    like this in Ceylon. The "best" answer is called the <emphasis>principal type
    of an expression</emphasis>. Every other type to which the expression is 
    assignable is a supertype of the principal type.</para>
    
    <para>Thus, every legal Ceylon expression has a unique, well-defined type, 
    representable within the type system, without reference to how the expression 
    is used or to what type it is assigned. This is the case even when type inference 
    or type argument inference comes into play.</para>
    
    <para>Neither this specification nor the internal implementation of the Ceylon 
    compiler itself use any kind of "non-denotable" types. Every type mentioned 
    here or inferred internally by the compiler has a representation within the 
    language itself. Thus, the programmer is never exposed to confusing error 
    messages referring to mysterious types that are not part of the syntax of the 
    language.</para>
    
    <!--para>The ability to represent types like <literal>Method</literal>, <literal>Class</literal>,
    and <literal>Callable</literal> within the type system, and to therefore write
    code that operates on instances of these types in a typesafe way is what makes
    Ceylon a <emphasis>higher order</emphasis> language.</para-->
    
    <section id="identifiernaming">
        <title>Identifier naming</title>

        <para>The Ceylon compiler enforces identifier naming conventions. Types must
        be named with an initial uppercase letter. Methods, attributes, parameters, 
        and locals must be named with an initial lowercase letter or underscore.</para>
        
        <programlisting>TypeName: UIdentifier</programlisting>
        <programlisting>MemberName: LIdentifier</programlisting>
        
        <para>A package or module name is a sequence of identifiers, each with an 
        initial lowercase letter or underscore.</para>
        
        <programlisting>PackageName: LIdentifier</programlisting>

        <para>Ceylon defines three identifier namespaces:</para>
        
        <itemizedlist>
            <listitem>
                <para>classes, interfaces, type aliases, and type parameters share 
                a single namespace,</para>
            </listitem>
            <listitem>
                <para>functions, values, and parameters share a single namespace, 
                and</para>
            </listitem>
            <listitem>
                <para>packages have their own dedicated namespace.</para>
            </listitem>
        </itemizedlist>
        
        <para>The Ceylon parser is able to unambiguously identify which namespace an 
        identifier belongs to.</para>
        
        <para>An identifier that begins with an initial lowercase letter may be 
        <emphasis>forced</emphasis> into the namespace of types by prefixing the
        identifier <literal>\I</literal>. An identifier that begins with an initial
        uppercase letter may be forces into the namespace of methods and attributes
        by prefixing the identifier <literal>\i</literal>. This allow interoperation
        with languages like Java which do not enforce these naming conventions.</para>
        
    </section>
      
    <section id="type">
        <title>Types</title>
    
        <para>A <emphasis>type</emphasis> or <emphasis>type schema</emphasis> is a name 
        (an initial uppercase identifier) and an optional list of type parameters, with 
        a set of:</para>
        
        <itemizedlist>
            <listitem>
                <para>value schemas,</para>
            </listitem>
            <listitem>
                <para>function schemas, and</para>
            </listitem>
            <listitem>
                <para>class schemas.</para>
            </listitem>
        </itemizedlist>
        
        <para>The value, function, and class schemas are called the <emphasis>members</emphasis> 
        of the type.</para>
        
        <para>Speaking formally:</para>
        
        <itemizedlist>
            <listitem>
                <para>A <emphasis>value schema</emphasis> is a name (an initial 
                lowercase identifier) with a type and mutability.</para>
            </listitem>
            <listitem>
                <para>A <emphasis>function schema</emphasis> is a name (an initial 
                lowercase identifier) and an optional list of type parameters, with a 
                type (often called the <emphasis>return type</emphasis>) and a sequence 
                of one or more parameter lists.</para>
            </listitem>
            <listitem>
                <para>A <emphasis>class schema</emphasis> is a type schema with exactly
                one parameter list.</para>
            </listitem>
            <listitem>
                <para>A <emphasis>parameter list</emphasis> is a list of names (initial 
                lowercase identifiers) with types. The <emphasis>signature</emphasis> of 
                a parameter list is formed by discarding the names, leaving the list of 
                types.</para>
            </listitem>
        </itemizedlist>
        
        <para>Speaking slightly less formally, we usually refer to an <emphasis>attribute</emphasis>, 
        <emphasis>method</emphasis>, or <emphasis>member class</emphasis> of a type, meaning 
        a value schema, function schema, or class schema that is a member of the type.</para>
        
        <para>A function or value schema may occur outside of a type schema. If it occurs 
        directly in a compilation unit, we often call it a <emphasis>toplevel function</emphasis> 
        or <emphasis>toplevel value</emphasis>.</para>
        
        <section id="memberdistinctness">
            <title>Member distinctness</title>
        
        <para>Overloading is illegal in Ceylon. A type may not have:</para>
        
        <itemizedlist>
            <listitem>
                <para>two attributes with the same name,</para>
            </listitem>
            <listitem>
                <para>a method and an attribute with the same name,</para>
            </listitem>
            <listitem>
                <para>two methods with the same name, or</para>
            </listitem>
            <listitem>
                <para>two member classes with the same name.</para>
            </listitem>
        </itemizedlist>
        
        </section>
        
        <section id="subtyping">
            <title>Subtyping</title>
        
        <para>A type may be a <emphasis>subtype</emphasis> of another type. Subtyping obeys 
        the following rules:</para>
        
        <itemizedlist>
            <listitem>
                <para>Identity: <literal>X</literal> is a subtype of <literal>X</literal>.</para>
            </listitem>
            <listitem>
                <para>Transitivity: if <literal>X</literal> is a subtype of <literal>Y</literal>
                and <literal>Y</literal> is a subtype of <literal>Z</literal> then
                <literal>X</literal> is a subtype of <literal>Z</literal>.</para>
            </listitem>
            <listitem>
                <para>Noncircularity: if <literal>X</literal> is a subtype of <literal>Y</literal>
                and <literal>Y</literal> is a subtype of <literal>X</literal> then
                <literal>Y</literal> and <literal>X</literal> are the same type.</para>
            </listitem>
            <listitem>
                <para>Single root: all types are subtypes of the class <literal>Anything</literal>
                defined in the module <literal>ceylon.language</literal>.</para>
            </listitem>
            <!--listitem>
                <para>Generic consistency: If <literal>Y</literal> is a parameterized type, and 
                a class or interface <literal>X</literal> is a subtype of both <literal>Y&lt;U&gt;</literal> 
                and <literal>Y&lt;V&gt;</literal> then either <literal>Y&lt;U&gt;</literal> is a 
                subtype of <literal>Y&lt;V&gt;</literal> or <literal>Y&lt;V&gt;</literal> is a 
                subtype of <literal>Y&lt;U&gt;</literal>.</para>
            </listitem-->
        </itemizedlist>
        
        <!--comment><para>Note: intersections and <literal>Bottom</literal> don't satisfy the last of 
        these rules.</para></comment-->
        
        <para>Every interface type is a subtype of the class <literal>Object</literal> 
        defined in <literal>ceylon.language</literal>.</para>
        
        <para>If <literal>X</literal> is a subtype of <literal>Y</literal>, then:</para>
        
        <itemizedlist>
            <listitem>
                <para>For each non-<literal>variable</literal> attribute of <literal>Y</literal>, 
                <literal>X</literal> has an attribute with the same name, whose type is 
                assignable to the type of the attribute of <literal>Y</literal>.</para>
            </listitem>
            <listitem>
                <para>For each <literal>variable</literal> attribute of <literal>Y</literal>, 
                <literal>X</literal> has a <literal>variable</literal> attribute with the 
                same name and the same type.</para>
            </listitem>
            <listitem>
                <para>For each method of <literal>Y</literal>, <literal>X</literal> has a 
                method with the same name, with the same number of parameter lists, with 
                the same signatures, and whose return type is assignable to the return type 
                of the method of <literal>Y</literal>.</para>
            </listitem>
            <listitem>
                <para>For each member class of <literal>Y</literal>, <literal>X</literal>
                has a member class of the same name, with a parameter list with the same 
                signature, that is a subtype of the member class of <literal>Y</literal>.</para>
            </listitem>
        </itemizedlist>
        
        <para>Furthermore, we say that <literal>X</literal> is <emphasis>assignable</emphasis>
        to <literal>Y</literal>.</para>
        
        </section>
        
        <section id="uniontypes">
            <title>Union types</title>
            
        <para>For any types <literal>X</literal> and <literal>Y</literal>, the 
        <emphasis>union</emphasis>, or <emphasis>disjunction</emphasis>,
        <literal>X|Y</literal>, of the types may be formed. A union type is a supertype of 
        both of the given types <literal>X</literal> and <literal>Y</literal>, and an instance
        of either type is an instance of the union type.</para>
        
        <para>The union type constructor <literal>|</literal> is associative, so the union 
        of three types may be written <literal>X|Y|Z</literal>.</para>
            
        <programlisting>UnionType: IntersectionType ("|" IntersectionType)*</programlisting>
        
        <para>If <literal>X</literal> and <literal>Y</literal> are both subtypes of a third type 
        <literal>Z</literal>, then <literal>X|Y</literal> inherits all members of <literal>Z</literal>.</para>

        <programlisting>void write(String|Integer|Float printable) { ... }</programlisting>
        
        <para>Union types satisfy the following rules, for any types <literal>X</literal>,
        <literal>Y</literal>, and <literal>Z</literal>:</para>
        
        <itemizedlist>
            <listitem>
                <para>
                    Commutativity: <literal>X|Y</literal> is the same 
                    type as <literal>Y|X</literal>.
                </para>
            </listitem>
            <listitem>
                <para>
                    Associativity: <literal>X|(Y|Z)</literal> is the same 
                    type as <literal>(X|Y)|Z</literal>.
                </para>
            </listitem>
            <listitem>
                <para>
                    Simplification: if <literal>X</literal> is a subtype 
                    of <literal>Y</literal>, then <literal>X|Y</literal> 
                    is the same type as <literal>Y</literal>.
                </para>
            </listitem>
            <listitem>
                <para>
                    Subtypes: <literal>X</literal> is a subtype of 
                    <literal>X|Y</literal>.
                </para>
            </listitem>
            <listitem>
                <para>
                    Supertypes: if both <literal>X</literal> and 
                    <literal>Y</literal> are subtypes of <literal>Z</literal>, 
                    then <literal>X|Y</literal> is also a subtype of
                    <literal>Z</literal>.
                </para>
            </listitem>
        </itemizedlist>
        
        <para>The following results follow from these rules:</para>
        
        <itemizedlist>
            <listitem>
                <para>
                    <literal>X|Nothing</literal> is the same  type as <literal>X</literal> 
                    for any type <literal>X</literal>, and
                </para>
            </listitem>
            <listitem>
                <para>
                    <literal>X|Anything</literal> is the same type as <literal>Anything</literal>
                    for any type <literal>X</literal>.
                </para>
            </listitem>
        </itemizedlist>
        
        <para>Finally:</para>
        
        <itemizedlist>
            <listitem>
                <para>If <literal>X&lt;T&gt;</literal> is covariant in the type parameter 
                <literal>T</literal>, then <literal>X&lt;U&gt;|X&lt;V&gt;</literal> is a
                subtype of <literal>X&lt;U|V&gt;</literal> for any types <literal>U</literal>
                and <literal>V</literal> that satisfy the type constraints on <literal>T</literal>.</para>
            </listitem>
            <listitem>
                <para>If <literal>X&lt;T&gt;</literal> is contravariant in the type parameter 
                <literal>T</literal>, then <literal>X&lt;U&gt;|X&lt;V&gt;</literal> is a
                subtype of <literal>X&lt;U&amp;V&gt;</literal> for any types <literal>U</literal>
                and <literal>V</literal> that satisfy the type constraints on <literal>T</literal>.</para>
            </listitem>
        </itemizedlist>
                
        </section>
        
        <section id="intersectiontypes">
            <title>Intersection types</title>
            
        <para>For any types <literal>X</literal> and <literal>Y</literal>, the 
        <emphasis>intersection</emphasis>, or <emphasis>conjunction</emphasis>,
        <literal>X&amp;Y</literal>, of the types may be formed. An intersection type is a subtype 
        of both of the given types <literal>X</literal> and <literal>Y</literal>, and any object
        which is an instance of both types is an instance of the union type.</para>
        
        <para>The union type constructor <literal>&amp;</literal> is associative, so the union 
        of three types may be written <literal>X&amp;Y&amp;Z</literal>.</para>
            
        <programlisting>IntersectionType: PrimaryType ("&amp;" PrimaryType)*</programlisting>
        
        <para>The intersection <literal>X&amp;Y</literal> inherits all members of both
        <literal>X</literal> and <literal>Y</literal>.</para>
        
        <programlisting>void store(Persistent&amp;Printable&amp;Identifiable object) { ... }</programlisting>
        
        <para>Intersection types satisfy the following rules, for any types <literal>X</literal>,
        <literal>Y</literal>, and <literal>Z</literal>:</para>
        
        <itemizedlist>
            <listitem>
                <para>
                    Commutativity: <literal>X&amp;Y</literal> is the same 
                    type as <literal>Y&amp;X</literal>.
                </para>
            </listitem>
            <listitem>
                <para>
                    Associativity: <literal>X&amp;(Y&amp;Z)</literal> is the same 
                    type as <literal>(X&amp;Y)&amp;Z</literal>.
                </para>
            </listitem>
            <listitem>
                <para>
                    Simplification: if <literal>X</literal> is a subtype 
                    of <literal>Y</literal>, then <literal>X&amp;Y</literal> 
                    is the same type as <literal>X</literal>.
                </para>
            </listitem>
            <listitem>
                <para>
                    Supertypes: <literal>X</literal> is a supertype of 
                    <literal>X&amp;Y</literal>.
                </para>
            </listitem>
            <listitem>
                <para>
                    Subtypes: if both <literal>X</literal> and 
                    <literal>Y</literal> are supertypes of <literal>Z</literal>, 
                    then <literal>X&amp;Y</literal> is also a supertype of
                    <literal>Z</literal>.
                </para>
            </listitem>
            <listitem>
                <para>
                    Distributivity over union: <literal>X&amp;(Y|Z)</literal> is the same 
                    type as <literal>(X&amp;Y)|(X&amp;Z)</literal>.
                </para>
            </listitem>
        </itemizedlist>
        
        <para>The following results follow from these rules:</para>
        
        <itemizedlist>
            <listitem>
                <para>
                    <literal>X&amp;Nothing</literal> is the same type as <literal>Nothing</literal> 
                    for any type <literal>X</literal>, and
                </para>
            </listitem>
            <listitem>
                <para>
                    <literal>X&amp;Anything</literal> is the same type as <literal>X</literal>
                    for any type <literal>X</literal>.
                </para>
            </listitem>
        </itemizedlist>
        
        <para>Finally:</para>
        
        <itemizedlist>
            <listitem>
                <para>If <literal>X&lt;T&gt;</literal> is covariant in the type parameter 
                <literal>T</literal>, then <literal>X&lt;U&gt;&amp;X&lt;V&gt;</literal> is a
                supertype of <literal>X&lt;U&amp;V&gt;</literal> for any types <literal>U</literal>
                and <literal>V</literal> that satisfy the type constraints on <literal>T</literal>.</para>
            </listitem>
            <listitem>
                <para>If <literal>X&lt;T&gt;</literal> is contravariant in the type parameter 
                <literal>T</literal>, then <literal>X&lt;U&gt;&amp;X&lt;V&gt;</literal> is a
                supertype of <literal>X&lt;U|V&gt;</literal> for any types <literal>U</literal>
                and <literal>V</literal> that satisfy the type constraints on <literal>T</literal>.</para>
            </listitem>
        </itemizedlist>
        
        <comment><para>Note: an intersection <literal>X&lt;A&gt;&amp;X&lt;P&gt;</literal> of 
        two instantiations of an invariant type, <literal>X&lt;T&gt;</literal> where 
        one type argument <literal>P</literal> is a type parameter introduces a known hole in 
        our type system. It is impossible to form a principal instantiation of <literal>X</literal>
        for this intersection type without resorting to use-site covariance, which is 
        non-denoteable in Ceylon. We're investigating how to reasonably prevent such types 
        arising and produce meaningful errors.</para></comment>
        
        </section>
        
        <section id="bottomtype">
            <title>The bottom type</title>
            
            <para>The special type <literal>Nothing</literal> represents:</para>
            
            <itemizedlist>
                <listitem>
                    <para>the intersection of all types, or, equivalently</para>
                </listitem>
                <listitem>
                    <para>the empty set.</para>
                </listitem>
            </itemizedlist>
            
            <para><literal>Nothing</literal> is assignable to all other types, but has
            no instances.</para>
            
            <para>A reference to a member of an expression of type <literal>Nothing</literal>
            is always an error, since there can never be a receiving instance.</para>
            
            <para><literal>Nothing</literal> is considered to belong to the module
            <literal>ceylon.language</literal>. However, it cannot be defined within
            the language.</para>
            
            <para>Because of the restrictions imposed by Ceylon's mixin inheritance 
            model:</para>
            
            <itemizedlist>
            <listitem>
                <para>If <literal>X</literal> and <literal>Y</literal> are classes, and
                <literal>X</literal> is not a subclass of <literal>Y</literal>, and 
                <literal>Y</literal> is not a subclass of <literal>X</literal>, then
                the intersection type <literal>X&amp;Y</literal> is equivalent to 
                <literal>Nothing</literal>.</para>
            </listitem>
            <listitem>
                <para>If <literal>X</literal> is an interface, the intersection type 
                <literal>X&amp;Nothing</literal> is equivalent to <literal>Nothing</literal>.</para>
            </listitem>
            <listitem>
                <para>If <literal>X&lt;T&gt;</literal> is invariant in its type parameter
                <literal>T</literal>, and the distinct types <literal>A</literal> and 
                <literal>B</literal> do not involve type parameters, then 
                <literal>X&lt;A&gt;&amp;X&lt;B&gt;</literal> is equivalent to 
                <literal>Nothing</literal>.</para>
            </listitem>
            </itemizedlist>
            
            <comment><para>TODO: Should the name of this type be a keyword, perhaps
            <literal>nothing</literal>, to emphasize that it is defined primitively?</para></comment>
            
        </section>
        
        <section id="dynamictype">
            <title>The dynamic type</title>
            
            <comment><para>TODO: define <literal>Dynamic</literal>.</para></comment>
            
        </section>
            
        <section id="typeofaprogramelement">
            <title>Type expressions</title>
        
        <para>Function and value declarations usually declare a type, by specifying
        a <emphasis>type expression</emphasis>.</para>
        
        <programlisting>Type: UnionType | EntryType</programlisting>
        
        <para>Type expressions are formed by combining produced types using union,
        intersection, and type abbreviations.</para>
        
        <para>Type expressions support grouping using angle brackets:</para>
        
        <programlisting>GroupedType: "&lt;" Type "&gt;"</programlisting>
        
        <para>Produced types are identified by the name of the type (a class, interface, 
        or type parameter), together with a list of type arguments if the type definition 
        specifies type parameters.</para>
        
        <programlisting>TypeNameWithArguments: TypeName TypeArguments?</programlisting>
        
        <para>If the type is a class or interface nested inside a containing class or 
        interface, the type must be fully qualified by its containing types, except when 
        used inside the body of a containing type.</para>
        
        <programlisting>QualifiedType: TypeNameWithArguments ("." TypeNameWithArguments)*</programlisting>
        
        <para>If a type has type parameters or a sequenced type parameter, a type argument 
        list must be specified. If a type has no type parameters, and no sequenced type 
        parameter, no type argument list may be specified.</para>
        
        <programlisting>BufferedReader.Buffer</programlisting>
        <programlisting>Entry&lt;Integer,Element&gt;</programlisting>
        
        <para>The name of a type may not be qualified by the package name.</para>
        
        </section>
        
        <section id="typenameabbreviations">
            <title>Type abbreviations</title>
        
        <para>Certain important types may be written using an abbreviated syntax.</para>
        
        <programlisting>PrimaryType: AtomicType | OptionalType | SequenceType | CallableType</programlisting>   
        <programlisting>AtomicType: QualifiedType | EmptyType | TupleType | IterableType | GroupedType</programlisting>
        
        <para>First, there are postfix-style abbreviations for <emphasis>optional types</emphasis>, 
        <emphasis>sequence types</emphasis>, and <emphasis>callable types</emphasis>.</para>
                
        <programlisting>OptionalType: PrimaryType "?"</programlisting>
        <programlisting>SequenceType: PrimaryType "[" "]"</programlisting>
        <programlisting>CallableType: PrimaryType "(" TypeList? ")"</programlisting>
        
        <itemizedlist>
            <listitem>
                <para><literal>X?</literal> means <literal>Nothing|X</literal> for any 
                type <literal>X</literal>,</para>
            </listitem>
            <listitem>
                <para><literal>X[]</literal> means <literal>Sequential&lt;X&gt;</literal> 
                for any type <literal>X</literal>, and</para>
            </listitem>
            <listitem>
                <para><literal>X(Y,Z)</literal> means <literal>Callable&lt;X,[Y,Z]&gt;</literal>
                where <literal>Y,Z</literal> is a list of types of any length.</para>
            </listitem>
        </itemizedlist>
        
        <para>More precisely, the type meant by a callable type abbreviation is
        <literal>Callable&lt;X,T&gt;</literal> where <literal>X</literal> is the type 
        outside the parentheses in the the callable type abbreviation, and 
        <literal>T</literal> is the tuple type formed by the types listed inside the 
        parentheses.</para>
        
        <para>Next, abbreviations for <emphasis>iterable types</emphasis> are written
        using braces.</para>
        
        <programlisting>IterableType: "{" UnionType ("*"|"+") "}"</programlisting>
        
        <itemizedlist>
            <listitem>
                <para><literal>{X*}</literal> means <literal>Iterable&lt;X,Null&gt;</literal> 
                for any type <literal>X</literal>, and</para>
            </listitem>
            <listitem>
                <para><literal>{X+}</literal> means <literal>Iterable&lt;X,Nothing&gt;</literal> 
                for any type <literal>X</literal>.</para>
            </listitem>
        </itemizedlist>
        
        <para>Next, abbreviations for <emphasis>sequence types</emphasis> and 
        <emphasis>tuple types</emphasis> may be written using brackets.</para>
        
        <programlisting>EmptyType: "[" "]"</programlisting>
        
        <programlisting>TupleType: "[" TypeList "]"</programlisting>
        
        <programlisting>TypeList: (EntryType ",")* UnionType ("*"|"+")?</programlisting>
        
        <itemizedlist>
            <listitem>
                <para><literal>[X*]</literal> means <literal>Sequential&lt;X&gt;</literal> 
                for any type <literal>X</literal>,</para>
            </listitem>
            <listitem>
                <para><literal>[]</literal> means <literal>Empty</literal>,</para>
            </listitem>
            <listitem>
                <para><literal>[X+]</literal> means <literal>Sequence&lt;X&gt;</literal> 
                for any type <literal>X</literal>, and</para>
            </listitem>
            <listitem>
                <para><literal>[X,Y]</literal> means <literal>Tuple&lt;X|Y,X,Tuple&lt;Y,Y,[]&gt;&gt;</literal>
                where <literal>X,Y</literal> is a list of types of any length.</para>
            </listitem>
        </itemizedlist>
        
        <para>More precisely, the type meant by a tuple type abbreviation is
        <literal>Tuple&lt;X|Y,X,T&gt;</literal> where <literal>T</literal> is the type 
        of the tuple type abbreviation formed by removing the first type from the list 
        of types in the original tuple type abbreviation, and <literal>T</literal> is 
        an invariant subtype of <literal>Y[]</literal>. The type meant by a tuple type 
        abbreviation with no types, <literal>[]</literal> is <literal>Empty</literal>.</para>
        
        <comment><para>TODO: this definition does not cover variadic tuple types like
        <literal>[X,Y*]</literal> and <literal>[X,Y+]</literal>.</para></comment>
        
        <para>Finally, an <emphasis>entry type</emphasis> may be abbreviated using
        an arrow.</para>
                
        <programlisting>EntryType: UnionType "->" UnionType</programlisting>
        
        <itemizedlist>
            <listitem>
                <para><literal>X->Y</literal> means <literal>Entry&lt;X,Y&gt;</literal>, 
                for any types <literal>X</literal>, <literal>Y</literal>.</para>
            </listitem>
        </itemizedlist>
        
        <comment><para>Note: the abbreviations <literal>T[]</literal> and 
        <literal>[T*]</literal> are synonyms. The syntax <literal>T[]</literal> is
        supported for reasons of nostalgia.</para></comment>
        
        <para>Abbreviations may be combined:</para>
        
        <programlisting>String?[] words = { "hello", "world", null };
String? firstWord = words[0];

String->[Integer,Integer] onetwo = "onetwo"->[1, 2];

[Float+](Float x, Float[] xs) add = (Float x, Float[] xs) => append(xs, x);</programlisting>
        
        <para>When a type appears in a value expression, these abbreviations cannot be used 
        (they cannot be disambiguated from operator expressions).</para>
                
        </section>
        
        <section id="typeinference">
            <title>Type inference</title>
        
        <para>Certain declarations which usually require an explicit type may omit the type, 
        forcing the compiler to infer it, by specifying the keyword <literal>value</literal>
        or <literal>function</literal> where the type usually appears.</para>
                
        <programlisting>value names = people*.name;</programlisting>

        <programlisting>function parse(String text) => text.split(" .!?,:;()\n\f\r\t");</programlisting>

        <para>Type inference is only allowed for block local declarations which are are 
        referred to only by statements and declarations that occur within the lexical scope 
        of the declaration. A <literal>value</literal> or <literal>function</literal> 
        declaration may not:</para>
        
        <itemizedlist>
            <listitem>
                <para>be annotated <literal>shared</literal>,</para>
            </listitem>
            <listitem>
                <para>occur as a toplevel declaration in a compilation unit, or</para>
            </listitem>
            <listitem>
                <para>be referred to by statements or declarations that occur earlier in 
                the body containing of the declaration.</para>
            </listitem>
        </itemizedlist>
        
        <para>Nor may a parameter or forward-declared value or function have an inferred 
        type.</para>
        
        <para>These restrictions allow the compiler to infer undeclared types in a single 
        pass of the code.</para>
        
        <comment><para>Note: in future releases of the language, the inferred type will
        be context-dependent, that is, in program elements immediately following an
        assignment or specification, the inferred type will be the type just assigned.
        When conditional execution results in definite assignment, the inferred type
        will be the union of the conditionally assigned types. This will allow us to to
        relax the restriction that forward-declared functions and values can't have their
        type inferred. For example:</para>
        <programlisting>value one;
if (float) {
    one = 1.0;
    Float float = one;
}
else {
    one = 1;
    Integer int = one;
}
Float|Integer num = one;</programlisting></comment>
        
        </section>
        
    </section>
        
    <section id="inheritance">
        <title>Inheritance</title>
        
        <para>Subtyping is a static relationship between classes, interfaces, and type 
        parameters, produced through the use of <emphasis>inheritance</emphasis>:</para>
        
        <itemizedlist>
            <listitem>
                <para>a class may <emphasis>extend</emphasis> another class,</para>
            </listitem>
            <listitem>
                <para>a class may <emphasis>satisfy</emphasis> one or more interfaces,</para>
            </listitem>
            <listitem>
                <para>an interface may <emphasis>satisfy</emphasis> one or more other 
                interfaces, or</para>
            </listitem>
            <listitem>
                <para>a type parameter may <emphasis>satisfy</emphasis> a class and/or one or 
                more interfaces or type parameters.</para>
            </listitem>
            <!--listitem>
                <para>a type parameter may <emphasis>abstract</emphasis> a class, interface or 
                type parameter.</para>
            </listitem-->
        </itemizedlist>
        
        <para>If a type declaration extends or satisfies a type, we say it 
        <emphasis>inherits</emphasis> the type. Inheritance results in a relationship
        called <emphasis>invariant subtyping</emphasis> between produced types.</para>
        
        <itemizedlist>
        <listitem>
            <para>If a type <literal>X</literal> inherits a type <literal>Y</literal>, 
            then <literal>X</literal> is an invariant subtype of <literal>Y</literal>.</para>
        </listitem>
        <listitem>  
            <para>If a parameterized type <literal>X&lt;T&gt;</literal> inherits a type 
            <literal>Y</literal>, then the produced type <literal>X&lt;B&gt;</literal> 
            is an invariant subtype of <literal>Y</literal> for any type <literal>B</literal>.</para>
        </listitem>
        <listitem>  
            <para>If a parameterized type <literal>X&lt;T&gt;</literal> inherits a 
            produced type <literal>Y&lt;T&gt;</literal> that depends upon the type
            parameter <literal>T</literal>, then the produced type <literal>X&lt;B&gt;</literal> 
            is an invariant subtype of the produced type <literal>Y&lt;B&gt;</literal> 
            formed by substituting <literal>B</literal> for <literal>T</literal> for 
            any type <literal>B</literal>.</para>
        </listitem>
        </itemizedlist>
        
        <para>If a type is an invariant subtype of a second type then it is also a 
        subtype of the second type.</para>
        
        <comment><para>TODO: these rules need to be formalized into the language of
        <emphasis>type constructors</emphasis>.</para></comment>
        
        <comment>
        <para>Note: when a type declaration specifies a relationship to other types, 
        Ceylon visually distinguishes between a list of types which conceptually 
        represents a combination of (intersection of) the types, and a list of types 
        which represents a choice between (union of) the types. For example, when a 
        class <literal>C</literal> satisfies multiple interfaces, they are written as 
        <literal>X&amp;Y&amp;Z</literal>. On the other hand, the cases of an 
        enumerated class <literal>E</literal> are written as <literal>X|Y|Z</literal>.
        This syntax emphasizes that <literal>C</literal> is also a subtype of the 
        intersection type <literal>X&amp;Y&amp;Z</literal>, and that <literal>E</literal> 
        may be narrowed to the union type <literal>X|Y|Z</literal> using a 
        <literal>switch</literal> statement or the <literal>of</literal> operator.</para>
        </comment>
        
        <section id="pii">
            <title>Principal instantiation inheritance</title>
            
            <para>If a class or interface <literal>A</literal> is a subtype of the types
            <literal>B&lt;X&gt;</literal> and <literal>B&lt;Y&gt;</literal> for some
            parameterized type <literal>B&lt;T&gt;</literal>, and types <literal>X</literal> 
            and <literal>Y</literal>, then <literal>A</literal> must also be a subtype of 
            <literal>B&lt;Z&gt;</literal> for some subtype <literal>Z</literal> of 
            <literal>X</literal> and <literal>Y</literal>.</para>
            
            <para>Or, equivalently, <literal>B&lt;T&gt;</literal> must not be invariant in 
            <literal>T</literal> and <literal>A</literal> must also be a subtype of:</para>
            
            <itemizedlist>
                <listitem>
                    <para><literal>B&lt;X&amp;Y&gt;</literal> if <literal>B&lt;T&gt;</literal>
                    is covariant in <literal>T</literal>, or</para>
                </listitem>
                <listitem>
                    <para><literal>B&lt;X|Y&gt;</literal> if <literal>B&lt;T&gt;</literal>
                    is contravariant in <literal>T</literal>.</para>
                </listitem>
            </itemizedlist>
            
            <para>It further follows that if <literal>X</literal> and <literal>Y</literal>
            are distinct types, and <literal>B&lt;T&gt;</literal> is invariant in 
            <literal>T</literal>, then the type <literal>B&lt;X&gt;&amp;B&lt;Y&gt;</literal>
            is the empty type <literal>Nothing</literal>.</para>
            
            <comment><para>Note: in fact, the type checker actually enforces an additional
            condition, that might be strictly stronger than this one: that the intersection
            between the direct supertypes of a type must not be equivalent to 
            <literal>Nothing</literal>. However, in order to prove this, it must first prove
            that the above condition holds, or the simplification algorithm runs the risk of 
            not terminating.</para></comment>
        
        </section>
        
    <section id="extendedclass">
        <title>Extension</title>
    
        <para>A class may extend another class, in which case the first class is a subtype
        of the second class and inherits its members.</para>
        
        <programlisting>ExtendedType: "extends" ("super" ".")? QualifiedType PositionalArguments</programlisting>
    
        <para>The <literal>extends</literal> clause must specify exactly one superclass.</para>
        
        <itemizedlist>
            <listitem>
                <para>If the superclass is a parameterized type, the <literal>extends</literal> 
                clause must also explicitly specify type arguments.</para>
            </listitem>
            <listitem>
                <para>The <literal>extends</literal> clause must specify arguments for the 
                initializer parameters of the superclass.</para>
            </listitem>
        </itemizedlist>
        
        <para>The type arguments may <emphasis>not</emphasis> be inferred from the 
        initializer arguments.</para>
        
        <programlisting>extends Person(name, org)</programlisting>
        
        <para>A member class annotated <literal>actual</literal> may use the qualifier 
        <literal>super</literal> in the <literal>extends</literal> clause to refer to the 
        member class it refines. When the qualifier <literal>super</literal> appears, the
        following class name refers to a member class of the superclass of the class that
        contains the member class annotated <literal>actual</literal>.</para>
        
        <programlisting>extends super.Buffer()</programlisting>
        
        <comment><para>TODO: This doesn't work if the member class being refined belongs
        to an interface.</para></comment>
        
        <para>
        The root class <literal>Anything</literal> defined in <literal>ceylon.language</literal> 
        does not have a superclass.
        </para>
        
    </section>
    
    <section id="satisfiedinterfaces">
        <title>Satisfaction</title>
       
        <para>The <literal>satisfies</literal> clause does double duty. It's used to 
        specify that a class or interface is a direct subtype of one or more interfaces, 
        and to specify upper bound type constraints applying to a type parameter.</para>
        
        <comment><para>Note: for this reason the keyword is not named 
        "<literal>implements</literal>". It can't reasonably be said that a type 
        parameter "implements" its upper bounds. Nor can it be reasonably said that
        an interface "implements" its super-interfaces.</para></comment>
        
        <itemizedlist>
        <listitem>
            <para>A class or interface may satisfy one or more interfaces, in which case
            the class or interface is a subtype of the satisfied interfaces, and inherits 
            their members.</para>
        </listitem>
        <listitem>
            <para>A type parameter may satisfy one or more interfaces, optionally, a class,
            and optionally, another type parameter. In this case, the satisfied types are 
            interpreted as upper bound type constraints on arguments to the type 
            parameter.</para>
        </listitem>
        </itemizedlist>
        
        <comment><para>Note: currently, a type parameter upper bound may not be specified
        in combination with other upper bounds. This restriction will likely be removed in
        future.</para></comment>
        
        <programlisting>SatisfiedTypes: "satisfies" PrimaryType ("&amp;" PrimaryType)*</programlisting>
    
        <para>The <literal>satisfies</literal> clause may specify multiple types. If a 
        satisfied type is a parameterized type, the <literal>satisfies</literal> clause 
        must specify type arguments.</para>
        
        <programlisting>satisfies Sequence&lt;Element&gt; &amp; Collection&lt;Element&gt;</programlisting>
        
    </section>
    
    </section>
    
    <section id="casesandcoverage">
        <title>Case enumeration and coverage</title>
        
        <para><emphasis>Coverage</emphasis> is a static relationship between classes, 
        interfaces, and type parameters, produced through the use of <emphasis>case 
        enumeration</emphasis>:</para>
        
        <itemizedlist>
        <listitem>
            <para>An <literal>abstract</literal> class or interface may be an 
            <emphasis>enumerated type</emphasis>, with an enumerated list of 
            disjoint subtypes called <emphasis>cases</emphasis>.</para>
        </listitem>
        <listitem>
            <para>A type parameter may have an <emphasis>enumerated bound</emphasis>,
            with an enumerated list possible type arguments.</para>
        </listitem>
        <listitem>
            <para>An <literal>abstract</literal> class or interface may have a 
            <emphasis>self type</emphasis>, a type parameter representing the
            concrete type of an instance.</para>
        </listitem>
        </itemizedlist>
        
    <section id="coverage">
        <title>Coverage</title>
        
        <para>Coverage is a strictly weaker relationship than assignability:</para>
        
        <itemizedlist>
        <listitem>
            <para>If a type is a subtype of a second type, then the second type
            covers the first type.</para>
        </listitem>
        <listitem>
            <para>If a type enumerates its cases, then the union of its cases
            covers the type.</para>
        </listitem>
        <listitem>
            <para>If a type has a self type, then its self type covers the type.</para>
        </listitem>
        <listitem>
            <para>If a type <literal>X</literal> covers two types <literal>A</literal> 
            and <literal>B</literal>, then <literal>X</literal> also covers their
            union <literal>A|B</literal>.</para>
        </listitem>
        <listitem>
            <para>Coverage is transitive. If <literal>X</literal> covers
            <literal>Y</literal> and <literal>Y</literal> covers <literal>Z</literal>,
            then <literal>X</literal> covers <literal>Z</literal>.</para>
        </listitem>
        </itemizedlist>
        
        <para>It follows that coverage obeys the identity property of assignability:
        a type covers itself. However, coverage does not obey the noncircularity property 
        of assignability. It is possible to have distinct types <literal>A</literal> and 
        <literal>B</literal> where <literal>A</literal> covers <literal>B</literal> and 
        <literal>B</literal> covers <literal>A</literal>.</para>
        
        <para>Case enumeration allows safe use of a type in a <literal>switch</literal> 
        statement, or as the subject of the <literal>of</literal> operator. The 
        compiler is able to statically validate that the <literal>switch</literal> 
        contains an exhaustive list of all cases of the type, by checking that the
        union of cases enumerated in the <literal>switch</literal> covers the type,
        or that the second operand of <literal>of</literal> covers the type.</para>
        
        <comment>
        <para>Note: however, a type is <emphasis>not</emphasis> considered automatically 
        assignable to the union of its cases, or to its self type. Instead, the type
        must be <emphasis>explicitly</emphasis> narrowed to the union of its cases, 
        or to its self type, using either the <literal>of</literal> operator or the
        <literal>switch</literal> construct. This narrowing type conversion can be
        statically checked&mdash;if <literal>X</literal> covers <literal>Y</literal>
        then <literal>Y of X</literal> is guaranteed to succeed at runtime.
        Unfortunately, and quite unintuitively, the compiler is not able to analyse 
        coverage implicitly at the same time as assignability, because that results in 
        undecidability!</para>
        </comment>
    
    </section>
        
    <section id="cases">
        <title>Cases</title>
        
        <para>The <literal>of</literal> clause does triple duty. It's used to define
        self types and type families, "algebraic" (sum) types, and enumerated type 
        constraints.</para>
        
        <itemizedlist>
        <listitem>
            <para>An interface or <literal>abstract</literal> class may optionally 
            specify an enumerated list of subtypes, in which case every subclass of 
            the interface or <literal>abstract</literal> class must be a subtype of 
            exactly one of the enumerated subtypes.</para>
        </listitem>
        <listitem>
            <para>Likewise, a type parameter may specify an enumerated list of all
            types it accepts as a type argument.</para>
        </listitem>
        <listitem>
            <para>An interface or <literal>abstract</literal> class may specify a 
            single self type parameter, which must be a type parameter declared by 
            the interface or <literal>abstract</literal> class or by the immediately 
            containing type, if any.</para>
        </listitem>
        </itemizedlist>
        
        <para>The <literal>of</literal> clause may specify multiple types, called
        <emphasis>cases</emphasis>.</para>
        
        <programlisting>CaseTypes: "of" CaseType ("|" CaseType)*</programlisting>
        
        <programlisting>CaseType: MemberName | PrimaryType</programlisting>
        
        <!--
        <para>The compiler is able to infer certain subtyping relationships from the 
        types listed in the <literal>of</literal> clause.</para>
        
        <itemizedlist>
        <listitem>
            <para>If every case of a type <literal>X</literal> is an invariant suptype 
            of a type <literal>Y</literal>, then <literal>X</literal> is an invariant 
            subtype of <literal>Y</literal>.</para>
        </listitem>
        <listitem>  
            <para>If every case of a parameterized type <literal>X&lt;T&gt;</literal> 
            is an invariant suptype of a type <literal>Y</literal>, then the produced 
            type <literal>X&lt;B&gt;</literal> is an invariant subtype of <literal>Y</literal> 
            for any type <literal>B</literal>.</para>
        </listitem>
        <listitem>  
            <para>If every case of a parameterized type <literal>X&lt;T&gt;</literal> 
            is an invariant suptype of a produced type <literal>Y&lt;T&gt;</literal> 
            that depends upon the type parameter <literal>T</literal>, then the produced 
            type <literal>X&lt;B&gt;</literal> is an invariant subtype of the produced 
            type <literal>Y&lt;B&gt;</literal> formed by substituting <literal>B</literal> 
            for <literal>T</literal> for any type <literal>B</literal>.</para>
        </listitem>
        </itemizedlist>
        -->
               
        <para>If an interface of <literal>abstract</literal> class has exactly one 
        case, and it is a type parameter of the interface of <literal>abstract</literal> 
        class, or of the immediately containing type, if any, then that type parameter 
        is a self type of the interface of <literal>abstract</literal> class, and:</para> 
        
        <itemizedlist>
            <listitem>
                <para>the self type parameter covers the declared type within the 
                body of the declaration,</para>
            </listitem>
            <listitem>
                <para>the type argument to the self type parameter in a produced type
                 of the declared type covers the produced type, and</para>
            </listitem>
            <listitem>
                <para>every type which extends or satisfies a produced type of the 
                declared type must also be covered by the type argument to the self
                type parameter in the produced type.</para>
            </listitem>
        </itemizedlist>
        
        <programlisting><![CDATA[shared abstract class Comparable<Other>() of Other 
        given Other satisfies Comparable<Other> {
    
    shared formal Integer compare(Other that);
    
    shared Integer reverseCompare(Other that) => that.compare(this) of Other;
    
}]]></programlisting>
        
        <programlisting>Comparable&lt;Item&gt; comp = ... ;
Item item = comp of Item;</programlisting>
    
        <para>Otherwise, an interface of <literal>abstract</literal> class may have 
        multiple cases, and each case must be either:</para>
        
        <itemizedlist>
            <listitem>
                <para>a subtype of the interface or <literal>abstract</literal> 
                class, or</para>
            </listitem>
            <listitem>
                <para>the name specified in the <literal>object</literal> 
                declaration of a toplevel anonymous class that is a subtype of 
                the interface or <literal>abstract</literal> class.</para>
            </listitem>
        </itemizedlist>
        
        <programlisting>of larger | smaller | equal</programlisting>
        
        <programlisting>of Root&lt;Element&gt; | Leaf&lt;Element&gt; | Branch&lt;Element&gt;</programlisting>
        
        <para>A class or interface may not be a subtype of more than one case of an 
        enumerated type.</para>
        
        <para>A type parameter may specify multiple cases, and each case must be a 
        type.</para>
        
    </section>
        
    </section>

    <section id="generictypeparameters">
        <title>Generic type parameters</title>
    
        <para>Function, class, and interface schemas may be parameterized by one or more 
        generic type parameters. A parameterized type schema defines a type constructor, 
        a function that produces a type given a tuple of compatible type arguments. A 
        parameterized class or function schema defines a function that produces the 
        signature of an invokable operation given a tuple of compatible type arguments.</para>
        
        <programlisting>TypeParameters: "&lt;" (TypeParameter ",")* TypeParameter "&gt;"</programlisting>
        
        <para>A declaration with type parameters is called <emphasis>generic</emphasis> or
        <emphasis>parameterized</emphasis>.</para>
        
        <itemizedlist>
        <listitem>
            <para>A type schema with no type parameters defines exactly one type. A 
            parameterized type schema defines a template for producing types: one type 
            for each possible combination of type arguments that satisfy the type constraints 
            specified by the type. The types of members of the this type are determined by 
            replacing every appearance of each type parameter in the schema of the 
            parameterized type definition with its type argument.</para>
        </listitem>
        <listitem>
            <para>A function schema with no type parameters defines exactly one operation 
            per type. A parameterized function declaration defines a template for producing
            overloaded operations: one operation for each possible combination of type 
            arguments that satisfy the type constraints specified by the method declaration.</para>
        </listitem>
        <listitem>
            <para>A class schema with no type parameters defines exactly one instantiation 
            operation. A parameterized class schema defines a template for producing 
            overloaded instantiation operations: one instantiation operation for each possible 
            combination of type arguments that satisfy the type constraints specified by the 
            class declaration. The type of the object produced by an instantiation operation is 
            determined by substituting the same combination of type arguments for the type 
            parameters of the parameterized class schema.</para>
        </listitem>
        </itemizedlist>
        
        <comment><para>Note: by convention, type parameter names should be constructed from
        meaningful words. The use of single-letter type parameter names is discouraged. The 
        name of a type parameter should be chosen so that declarations within the body of 
        the parameterized declaration read naturally. For example, 
        <literal>class Entry&lt;Key,Item&gt;</literal> is reasonable, since
        <literal>Key key</literal> and <literal>Item item</literal> read naturally within 
        the body of the <literal>Entry</literal> class. The following identifier names 
        usually refer to a type parameter: <literal>Element</literal>, <literal>Other</literal>,
        <literal>This</literal>, <literal>Value</literal>, <literal>Key</literal>, 
        <literal>Item</literal>, <literal>Argument</literal>, <literal>Args</literal> and 
        <literal>Result</literal>. Avoid, where reasonable, using these names for interfaces 
        and classes.</para></comment>
        
        <section id="typeparametersandvariance">
            <title>Type parameters and variance</title>
        
        <para>A <emphasis>type parameter</emphasis> allows a declaration to be abstracted 
        over a constrained set of types.</para>
        
        <programlisting>TypeParameter: Variance? TypeName ("=" Type)</programlisting>
        
        <para>Every type parameter has a name and a <emphasis>variance</emphasis>.</para>
        
        <programlisting>Variance: "out" | "in"</programlisting>
        
        <itemizedlist>
            <listitem>
                <para>A <emphasis>covariant</emphasis> type parameter is indicated using the
                keyword <literal>out</literal>.</para>
            </listitem>
            <listitem>
                <para>A <emphasis>contravariant</emphasis> type parameter is indicated using 
                the keyword <literal>in</literal>.</para>
            </listitem>
            <listitem>
                <para>By default, a type parameter is <emphasis>invariant</emphasis>.</para>
            </listitem>
        </itemizedlist>
        
        <para>A type parameter may, optionally, have a default type argument. A type
        parameter with a default type argument must occur after all type parameters without
        default type arguments in the type parameter list. The default type argument must
        satisfy the constraints on the type parameter.</para> 
        
        <para>Within the body of the schema it parameterizes, a type parameter is itself a 
        type. The type parameter is a subtype of every upper bound of the type parameter. 
        However, a class or interface may not extend or satisfy a type parameter.</para>
        
        <programlisting>&lt;Key, out Item&gt;</programlisting>
        
        <programlisting>&lt;in Message&gt;</programlisting>
        
        <programlisting>&lt;out Element=Object&gt;</programlisting>
        
        <programlisting>&lt;in Left, in Right, out Result&gt;</programlisting>
        
        </section>
        
        <section id="variancevalidation">
            <title>Variance validation</title>
        
        <para>A covariant type parameter may only appear in <emphasis>covariant positions</emphasis> 
        of the parameterized schema. A contravariant type parameter may only appear in 
        <emphasis>contravariant positions</emphasis> of the parameterized schema. An 
        invariant type parameter may appear in any position.</para>
        
        <para>Furthermore, a type with a contravariant type parameter may only appear in a
        covariant position in an extended type, satisfied type, case type, or upper bound
        type constraint.</para>
        
        <comment><para>Note: this restriction exists to eliminate certain undecidable cases
        described in Tate et al.</para></comment>
        
        <para>To determine if a type expression occurs in a covariant or contravariant 
        position, we first consider how the type occurs syntactically.</para> 
        
        <para>For a generic function we examine the return type of the function, which
        is a covariant position.</para>
        
        <para>For a generic type schema we examine each <literal>shared</literal> 
        member along with extended/satisfied types and case types:</para> 
        
        <itemizedlist>
            <listitem>
                <para>An extended type, satisfied type, or case type of the type schema 
                itself is a covariant position.</para>
            </listitem>
        </itemizedlist>
        
        <para>In a <literal>shared</literal> member method of the parameterized type 
        schema:</para>
        
        <itemizedlist>
            <listitem>
                <para>The return type of the method is a covariant position.</para>
            </listitem>
            <listitem>
                <para>Any parameter type of the method is a contravariant position.</para>
            </listitem>
            <listitem>
                <para>Any upper bound of a type parameter of the method is a contravariant 
                position.</para>
            </listitem>
            <!--listitem>
                <para>Any lower bound of a type parameter of the method is a covariant 
                position.</para>
            </listitem-->
        </itemizedlist>
        
        <para>In a <literal>shared</literal> attribute declaration that is not
        variable:</para>
        
        <itemizedlist>
            <listitem>
                <para>The type of the attribute is a covariant position.</para>
            </listitem>
        </itemizedlist>
        
        <para>In a <literal>shared</literal> reference declaration that is 
        variable:</para>
        
        <itemizedlist>
            <listitem>
               <para>The type of the attribute is an invariant position.</para>
            </listitem>
        </itemizedlist>
        
        <para>In a <literal>shared</literal> nested class declaration of the 
        parameterized type schema:</para>
        
        <itemizedlist>
            <listitem>
                <para>Any initializer parameter type of the class is a contravariant 
                position.</para>
            </listitem>
            <listitem>
                <para>Any upper bound of a type parameter of the class is a contravariant 
                position.</para>
            </listitem>
            <!--listitem>
                <para>Any lower bound of a type parameter of the class is a covariant 
                position.</para>
            </listitem-->
            <listitem>
                <para>An extended type, satisfied type, or case type of the nested class
                is a covariant position.</para>
            </listitem>
            <listitem>
                <para>Every covariant position of the nested class schema is a covariant
                position of the containing type schema. Every contravariant position of 
                the nested class schema is a contravariant position of the containing type 
                schema.</para>
            </listitem>
        </itemizedlist>
        
        <para>In a <literal>shared</literal> nested interface declaration of the 
        parameterized type schema:</para>
        
        <itemizedlist>
            <listitem>
                <para>An extended type, satisfied type, or case type of the nested interface 
                is a covariant position.</para>
            </listitem>
            <listitem>
                <para>Every covariant position of the nested interface schema is a covariant
                position of the containing type schema. Every contravariant position of 
                the nested interface schema is a contravariant position of the containing 
                type schema.</para>
            </listitem>
        </itemizedlist>
        
        <para>For parameters of callable parameters, we first determine if the callable
        parameter itself is covariant or contravariant:</para>
        
        <itemizedlist>
            <listitem>
                <para>A callable parameter of a method or nested class is contravariant.</para>
            </listitem>
            <listitem>
                <para>A callable parameter of a covariant parameter is contravariant.</para>
            </listitem>
            <listitem>
                <para>A callable parameter of a contravariant parameter is covariant.</para>
            </listitem>
        </itemizedlist>
        
        <para>Then:</para>
        
        <itemizedlist>
            <listitem>
                <para>The return type of a covariant callable parameter is a covariant 
                position.</para>
            </listitem>
            <listitem>
                <para>The return type of a contravariant callable parameter is a 
                contravariant position.</para>
            </listitem>
            <listitem>
                <para>The type of a parameter of a covariant callable parameter is a 
                contravariant position.</para>
            </listitem>
            <listitem>
                <para>The type of a parameter of a contravariant callable parameter is a 
                covariant position.</para>
            </listitem>
        </itemizedlist>
        
        <para>Finally, to determine if a type parameter that occurs as a type argument occurs
        in a covariant or contravariant position, we must consider the declared variance
        of the corresponding type parameter:</para>
        
        <itemizedlist>
            <listitem>
                <para>A type argument of a covariant type parameter of a type in a covariant 
                position is a covariant position.</para>
            </listitem>
            <listitem>
                <para>A type argument of a contravariant type parameter of a type in a 
                covariant position is a contravariant position.</para>
            </listitem>
            <listitem>
                <para>A type argument of a covariant type parameter of a type in a 
                contravariant position is a contravariant position.</para>
            </listitem>
            <listitem>
                <para>A type argument of a contravariant type parameter of a type in a 
                contravariant position is a covariant position.</para>
            </listitem>
            <listitem>
                <para>A type argument of an invariant type parameter of a type in any position 
                is an invariant position.</para>
            </listitem>
            <listitem>
                <para>A type argument of any type parameter of a type in an invariant position 
                is an invariant position.</para>
            </listitem>
        </itemizedlist>
        
        </section>
        
        <section id="typeparametersandenumeratedtypes">
            <title>Type parameters and enumerated types</title>
        
        <para>If an enumerated type <literal>T&lt;X&gt;</literal> has a case type 
        which is a produced type of a type schema <literal>U</literal> then either:</para>
        
        <itemizedlist>
            <listitem>
                <para><literal>U</literal> is parameterized by a type parameter
                <literal>X</literal> and <literal>U&lt;X&gt;</literal> obeys the
                rules enumerated below, or
                </para>
            </listitem>
            <listitem>
                <para><literal>T&lt;X&gt;</literal> is covariant in 
                <literal>X</literal> and <literal>U</literal> is an invariant 
                subtype of <literal>T&lt;Nothing&gt;</literal>, or</para>
            </listitem>
            <listitem>
                <para><literal>T&lt;X&gt;</literal> is contravariant in 
                <literal>X</literal> and <literal>U</literal> is an invariant 
                subtype of <literal>T&lt;I&gt;</literal> where <literal>I</literal>
                is the intersection of all upper bounds on <literal>X</literal>, or
                <literal>Anything</literal> if <literal>X</literal> has not upper
                bounds.</para>
            </listitem>
        </itemizedlist>
        
        <para>If <literal>U&lt;X&gt;</literal> is a case of an enumerated type
        <literal>T&lt;X&gt;</literal>, then <literal>U&lt;X&gt;</literal> must be 
        an invariant subtype of <literal>T&lt;X&gt;</literal> and:</para>
        
        <itemizedlist>
            <listitem>
                <para>if <literal>T&lt;X&gt;</literal> is covariant in <literal>X</literal>
                then <literal>U&lt;Y&gt;</literal> must be covariant in <literal>Y</literal>, 
                and</para>
            </listitem>
            <listitem>
                <para>if <literal>T&lt;X&gt;</literal> is contravariant in <literal>X</literal>
                then <literal>U&lt;Y&gt;</literal> must be contravariant in <literal>Y</literal>.</para>
            </listitem>
        </itemizedlist>
        
        </section>
    
    <section id="generictypeconstraints">
    <title>Generic type constraints</title>

        <para>A parameterized method, class, or interface declaration may declare constraints 
        upon ordinary type parameters using the <literal>given</literal> clause.</para>
        
        <programlisting>TypeConstraints: TypeConstraint+</programlisting>
        
        <para>There may be at most one <literal>given</literal> clause per type parameter.</para>
        
        <programlisting>TypeConstraint: "given" TypeName TypeParameters? TypeConstraintInheritance</programlisting>
        
        <programlisting>TypeConstraintInheritance: CaseTypes? SatisfiedTypes?</programlisting>
        
        <!--
        <programlisting>TypeConstraintInheritance: CaseTypes? SatisfiedTypes? AbstractedType?</programlisting>
        
        <programlisting>AbstractedType: "abstracts" Type</programlisting>
        -->
        
        <comment>
        <para>Note that the syntax for a type constraint is essentially the same syntax 
        used for other type declarations such as class and interface declarations.</para>
        </comment>
        
        <para>There are two different kinds of type constraint:</para>
        
        <itemizedlist>
            <listitem>
                <para>an <emphasis>upper bound</emphasis>, <literal>given X satisfies T</literal>, 
                specifies that the type parameter <literal>X</literal> is a subtype of 
                a given type <literal>T</literal>,</para>
            </listitem>
            <!--
            <listitem>
                <para>a <emphasis>lower bound</emphasis>, <literal>given X abstracts T</literal>, 
                specifies that a given type <literal>T</literal> is a subtype of the 
                type parameter <literal>X</literal>,</para>
            </listitem>
            -->
            <listitem>
                <para>an <emphasis>enumerated bound</emphasis>, <literal>given X of T|U|V</literal>
                specifies that the type parameter <literal>X</literal> represents one 
                of the enumerated types,</para>
            </listitem>
            <!--
            <listitem>
                <para>a <emphasis>parameter bound</emphasis>, 
                <literal>given X(...)</literal> specifies that the type parameter 
                <literal>X</literal> is a concrete class with the given parameter types, 
                and</para>
            </listitem>
            <listitem>
                <para>a <emphasis>metatype bound</emphasis>, <literal>given X is T</literal>, 
                specifies that the concrete metatype of the type parameter is a subtype 
                of a given type <literal>T</literal>. <emphasis>(Note that metatypes are 
                a proposed feature for a future version of the language.)</emphasis></para>
            </listitem>
            -->
        </itemizedlist>
        
        <para>A single <literal>given</literal> clause may specify multiple constraints
        on a certain type parameter. For example, it may specify multiple upper bounds
        together with an enumerated bound. If multiple upper bounds are specified, at most
        one upper bound may be a class, and at most one upper bound may be a type parameter.</para>
        
        <programlisting><![CDATA[given Value satisfies Ordinal & Comparable<Value>]]></programlisting>
        
        <programlisting><![CDATA[given Quantities satisfies Correspondence<Key,Decimal>]]></programlisting>
        
        <programlisting><![CDATA[given Argument of String | Integer | Float]]></programlisting>
        
        <comment><para>TODO: Should we inherit generic type constraints from supertypes, 
        like in C#, or require them to be redeclared, like in Java?</para></comment>
        
        <para>A type parameter is a subtype of its upper bounds.</para>
        
        <programlisting><![CDATA[class Holder<Value>(shared Value value) 
        extends Object
        given Value satisfies Object {
    shared actual Boolean equals(Object that) {
        if (is Holder<Value> that) {
            return value==that.value;
        }
        else {
            return false;
        }
    }
    shared actual Integer hash =>  value.hash;
}]]></programlisting>
        
        <para>Every type parameter has an implicit upper bound of type 
        <literal>Anything</literal>.</para>
                
        <para>An enumerated bound allows the use of an exhaustive <literal>switch</literal>
        with expressions of the parameter type.</para>
        
        <programlisting><![CDATA[Characters uppercase<Characters>(Characters chars) 
       given Characters of String | Range<Character> { 
    switch (Characters)
    case (satisfies String) { 
        return chars.uppercased;
    }
    case (satisfies Range<Character>) { 
        return chars.first.uppercased..chars.last.uppercased;
    }
}]]></programlisting>
        
        <comment><para>TODO: do we need lower bound type constraints? With union types
        they don't appear to be anywhere near as useful.</para></comment>
        
        <comment><para>TODO: since we have reified types, it will be possible to support
        a type constraint that allows instantiation of the type parameter.</para>
        <programlisting>given T(Object arg)</programlisting>
        </comment>
        
    <!--section>
        <title>Parameter bounds</title>

        <para>A parameter bound allows instantiation of the type represented by the 
        type parameter within the body of the declaration.</para>
        
        <programlisting><![CDATA[Result create<Result>(Object object) 
        given Result(String s) { 
    return Result(object.string.lowercased);
}]]></programlisting>

    </section-->
    
    <!--section>
        <title>PROPOSAL: Metatype bounds</title>
        
        <comment><para>NOTE: Metatypes are a proposed feature for a future version 
        of the language.</para></comment>
        
        <para>Note that an upper bound type constraint of form:</para>
        
        <programlisting>given X satisfies T</programlisting>
        
        <para>is equivalent to a metatype bound of this form:</para>
        
        <programlisting>given X is Type&lt;T&gt;</programlisting>
        
        <para>and that a parameter bound type constraint of form:</para>
        
        <programlisting>given X(A a, B b)</programlisting>
        
        <para>is equivalent to a metatype bound of this form:</para>
        
        <programlisting>given X is Callable&lt;X,A,B&gt;</programlisting>
        
        <comment><para>Note: I suppose that types introduced to the metatype should 
        be considered to satisfy a metatype bound, allowing type class introduction.
        </para></comment>
        
    </section-->
        
    </section>
    
    </section>

    <section id="generictypearguments">
        <title>Generic type arguments</title>
            
        <para>A list of <emphasis>type arguments</emphasis> produces a new type schema 
        from a parameterized type schema, or a new function schema from a from a
        parameterized function schema.</para>
        
        <para>A type argument list is a list of types.</para>
        
        <programlisting>TypeArguments: "&lt;" (Type ",")* Type "&gt;"</programlisting>
        
        <para>A type argument may itself be a parameterized type or type parameter.</para>
        
        <programlisting>&lt;Key, List&lt;Item&gt;&gt;</programlisting>
        <programlisting>&lt;String, Person?&gt;</programlisting>
        <programlisting>&lt;String[], [{Object*}]&gt;</programlisting>
         
    <section>
        <title>Type arguments and type constraints</title>
    
        <para>A generic type constraint affects the type arguments that can be assigned 
        to a type parameter:</para>
        
        <itemizedlist>
            <listitem>
                <para>A type argument to a type parameter with an upper bound must be a 
                type which is a subtype of all upper bounds.</para>
            </listitem>
            <!--listitem>
                <para>A type argument to a type parameter with a lower bound must be a 
                type of which all lower bounds are subtypes.</para>
            </listitem-->
            <listitem>
                <para>A type argument to a type parameter with an enumerated type bound 
                must be a subtype of one of the enumerated types, or a type with an 
                enumerated subtype list that is a subset of the enumerated types of the 
                constraint.</para>
            </listitem>
            <!--
            <listitem>
                <para>A type argument to a type parameter with an initialization parameter
                specification must be a class with the given initialization parameter
                types.</para>
            </listitem>
            <listitem>
                <para>A type argument to a type parameter with a metatype bound must have 
                a metatype assignable to all metatype bounds. <emphasis>(Note that metatype 
                bounds are a proposed feature for a future version of the language.)</emphasis></para>
            </listitem>
            -->
        </itemizedlist>
    
        <para>A type argument list <emphasis>conforms</emphasis> to a type parameter list 
        if for every type parameter in the list, there is a type argument that satisfies 
        the constraints of the type parameter, or there is no explicit type argument and
        type parameter has a default type argument.</para>
        
    </section>
        
        <section id="producedtypes">
            <title>Produced types and and variance</title>
            
        <para>If a type argument list conforms to a type parameter list, the combination
        of the parameterized type together with the type argument list is itself a type,
        called a <emphasis>produced type</emphasis>.</para>
        
        <para>For a generic type <literal>T&lt;X&gt;</literal>, the types 
        <literal>T&lt;A&gt;</literal> and <literal>T&lt;B&gt;</literal> represent the 
        same type if and only if <literal>A</literal> and <literal>B</literal> are the 
        same type.</para>
        
        <!--
        <para>For a generic type <literal>T&lt;n&gt;</literal>, the types 
        <literal>T&lt;a&gt;</literal> and <literal>T&lt;b&gt;</literal> represent the 
        same type if and only if <literal>a</literal> and <literal>b</literal> are 
        equivalent dimension expressions.</para>
        -->
        
        <para>For a generic type <literal>T&lt;X&gt;</literal>, a type <literal>A</literal>,
        and a subtype <literal>B</literal> of <literal>A</literal>:</para>
        
        <itemizedlist>
            <listitem>
                <para>
                    If <literal>X</literal> is a covariant type parameter, 
                    <literal>T&lt;B&gt;</literal> is a subtype of <literal>T&lt;A&gt;</literal>.
                </para>
            </listitem>
            <listitem>
                <para>
                    If <literal>X</literal> is a contravariant type parameter, 
                    <literal>T&lt;A&gt;</literal> is a subtype of <literal>T&lt;B&gt;</literal>.
                </para>
            </listitem>
            <listitem>
                <para>
                    If <literal>X</literal> is invariant (neither covariant nor contravariant), 
                    there is no subtype relationship between <literal>T&lt;A&gt;</literal> and 
                    <literal>T&lt;B&gt;</literal> unless <literal>A</literal> and <literal>B</literal> 
                    are the same type.
                </para>
            </listitem>
        </itemizedlist>
        
        <comment><para>Note that if <literal>X</literal> is an invariant type parameter, 
        then a produced type <literal>S</literal> is a subtype of <literal>T&lt;A&gt;</literal> 
        if and only if <literal>S</literal> is an invariant subtype of 
        <literal>T&lt;A&gt;</literal>.</para></comment>
        
        <para>A produced type is a subtype of the type argument to any type parameter 
        that appears in the <literal>of</literal> clause of the type declaration. If 
        <literal>X</literal> is a type parameter of the parameterized type 
        <literal>T&lt;X&gt; of X</literal>, then <literal>T&lt;A&gt;</literal> is 
        assignable to <literal>A</literal> for every type argument <literal>A</literal> 
        which satisfies the other type constraints on <literal>X</literal>.</para>
        
        </section>
        
        <section id="qualifiedtypes">
            <title>Qualified types</title>
            
            <para>If a class or interface declaration <literal>X&lt;P1,P2,...&gt;</literal> 
            with type parameters <literal>P1,P2,...</literal> has a member class or interface 
            declaration <literal>M&lt;Q1,Q2,...&gt;</literal>, then:</para>
            
            <itemizedlist>
                <listitem>
                    <para><literal>U.M&lt;A1,A2,...&gt;</literal> is a subtype of 
                    <literal>V.M&lt;B1,B2,...&gt;</literal> if <literal>U</literal> is a subtype 
                    of <literal>X&lt;C1,C2,...&gt;</literal> and <literal>V</literal> is an 
                    invariant subtype of <literal>X&lt;C1,C2,...&gt;</literal> and <literal>V</literal> 
                    directly inherits <literal>M</literal> from <literal>X</literal> without 
                    refining <literal>M</literal> and if <literal>M&lt;A1,A2,...&gt;</literal> 
                    is a subtype of <literal>M&lt;B1,B2,...&gt;</literal>.</para>
                </listitem>
                <listitem>
                    <para><literal>M&lt;A1,A2,...&gt;</literal>
                    is a subtype of <literal>V.M&lt;B1,B2,...&gt;</literal> if <literal>U</literal> 
                    is a subtype of <literal>X&lt;C1,C2,...&gt;</literal>and <literal>V</literal> 
                    is an invariant subtype of <literal>X&lt;P1,P2,...&gt;</literal> and <literal>V</literal> 
                    directly inherits <literal>M</literal> from <literal>X</literal> without 
                    refining <literal>M</literal> and if <literal>M&lt;A1,A2,...&gt;</literal> 
                    is a subtype of <literal>M&lt;B1,B2,...&gt;</literal>.</para>
                </listitem>
            </itemizedlist>
            
            <comment><para>Note that a type like <literal>M&lt;A1,A2,...&gt;</literal> is only
            well-formed inside the scope in which <literal>M</literal> is declared or imported.
            Outside this scope, references to <literal>M</literal> must be qualified by the 
            containing type.</para></comment>
            
        </section>
                
        <section id="typeargumentsubstitution">
            <title>Type argument substitution</title>
        
        <para>A type argument is substituted for every appearance of the corresponding
        type parameter in the schema of the parameterized declaration, including:</para>
        
        <itemizedlist>
            <listitem>
                <para>attribute types,</para>
            </listitem>
            <listitem>
                <para>method return types,</para>
            </listitem>
            <listitem>
                <para>method parameter types,</para>
            </listitem>
            <listitem>
                <para>initializer parameter types, and</para>
            </listitem>
            <listitem>
                <para>type arguments of extended classes and satisfied interfaces.</para>
            </listitem>
        </itemizedlist>
        
        <!--
        <para>A dimension is substituted for every appearance of the corresponding 
        dimensional type parameter in the schema of the parameterized declaration.
        The dimension appears as a parenthesized expression in expressions involving
        the dimensional type parameter.</para>
        -->
        
        </section>
                
        <section id="typeargumentinference">
            <title>Type argument inference</title>
        
        <para>When a direct invocation expression for a generic function or a direct 
        instantiation expression for a generic class does not explicitly specify type 
        arguments, the type arguments are inferred from the argument expression types. 
        The types of the argument expressions and the declared types of the corresponding 
        parameters determine an <emphasis>inferred lower bound</emphasis> for each type 
        parameter.</para>
        
        <para>If a list of argument expressions has types <literal>A1,A2,...</literal> 
        and the corresponding list of parameters has declared types <literal>P1,P2,...</literal>, 
        the inferred lower bound for a type parameter <literal>T</literal> of the generic
        declaration is the conjunction of:</para>
        
        <itemizedlist>
            <listitem>
                <para>the lower bound <literal>X</literal> explicitly declared by a type 
                constraint on <literal>T</literal> of form <literal>given T abstracts X</literal>, 
                if any, with</para>
            </listitem>
            <listitem>
                <para>all inferred lower bounds <literal>Ai</literal> on <literal>Pi</literal> 
                for <literal>T</literal>.</para>
            </listitem>
        </itemizedlist>
        
        <para>Given types <literal>A</literal> and <literal>P</literal>, we determine 
        the <emphasis>inferred lower bound</emphasis> <literal>A</literal> on 
        <literal>P</literal> for <literal>T</literal> according to the nature of 
        <literal>A</literal> and <literal>P</literal>:</para>
        
        <itemizedlist>
            <listitem>
                <para>If <literal>P</literal> is exactly <literal>T</literal>, the 
                inferred lower bound <literal>A</literal> on <literal>P</literal> for 
                <literal>T</literal> is <literal>T abstracts A</literal>.</para>
            </listitem>
            <listitem>
                <para>If <literal>P</literal> is a union type <literal>Q|R</literal>, 
                the lower bound <literal>A</literal> on <literal>P</literal> for 
                <literal>T</literal> is the disjunction of the lower bound 
                <literal>A</literal> on <literal>Q</literal> for <literal>T</literal> 
                with the lower bound <literal>A</literal> on <literal>R</literal> 
                for <literal>T</literal>.</para>
            </listitem>
            <listitem>
                <para>If <literal>P</literal> is an intersection type <literal>Q&amp;R</literal>, 
                the lower bound <literal>A</literal> on <literal>P</literal> for 
                <literal>T</literal> is the conjunction of the lower bound 
                <literal>A</literal> on <literal>Q</literal> for <literal>T</literal> 
                with the lower bound <literal>A</literal> on <literal>R</literal> 
                for <literal>T</literal>.</para>
            </listitem>
            <listitem>
                <para>If <literal>A</literal> is a union type <literal>B|C</literal>, 
                the lower bound <literal>A</literal> on <literal>P</literal> for 
                <literal>T</literal> is the conjunction of the lower bound <literal>B</literal> 
                on <literal>P</literal> for <literal>T</literal> with the lower bound 
                <literal>C</literal> on <literal>P</literal> for <literal>T</literal>.</para>
            </listitem>
            <listitem>
                <para>If <literal>A</literal> is an intersection type <literal>B&amp;C</literal>, 
                the lower bound <literal>A</literal> on <literal>P</literal> for 
                <literal>T</literal> is the disjunction of the lower bound <literal>B</literal> 
                on <literal>P</literal> for <literal>T</literal> with the lower bound 
                <literal>C</literal> on <literal>P</literal> for <literal>T</literal>.</para>
            </listitem>
            <listitem>
                <para>If <literal>P</literal> is a produced type <literal>Q&lt;P1,P2,...&gt;</literal> 
                of a parameterized type <literal>Q</literal>, and <literal>A</literal> 
                is a subtype of a produced type <literal>Q&lt;A1,A2,..&gt;</literal>, 
                the lower bound <literal>A</literal> on <literal>P</literal> for 
                <literal>T</literal> is the conjunction of all lower bounds <literal>Ai</literal> 
                on <literal>Pi</literal> for <literal>T</literal>.</para>
            </listitem>
            <listitem>
                <para>Otherwise, if <literal>A</literal> is not a union or intersection, 
                and if <literal>P</literal> is neither a produced type, a union, or an
                intersection, nor exactly <literal>T</literal>, the lower bound 
                <literal>A</literal> on <literal>P</literal> for <literal>T</literal>
                is <emphasis>null</emphasis>.</para>
            </listitem>
        </itemizedlist>
        
        <para>Where:</para>
        
        <itemizedlist>
            <listitem>
                <para>the conjunction a lower bound <literal>T abstracts A</literal>
                with a lower bound <literal>T abstracts B</literal> is the lower bound 
                <literal>T abstracts A|B</literal>,</para>
            </listitem>
            <listitem>
                <para>the disjunction a lower bound <literal>T abstracts A</literal>
                with a lower bound <literal>T abstracts B</literal> is the lower bound 
                <literal>T abstracts A&amp;B</literal>,</para>
            </listitem>
            <listitem>
                <para>the conjunction or disjunction of a lower bound <literal>T abstracts A</literal>
                with a null lower bound is <literal>T abstracts A</literal>, and</para>
            </listitem>
            <listitem>
                <para>the conjunction or disjunction of two null lower bounds is null.</para>
            </listitem>
        </itemizedlist>
        
        <!--
        <comment><para>Note that the basis for this algorithm is:</para>
<programlisting>T abstracts A &amp;&amp; T abstracts B => T abstracts A|B</programlisting>
<programlisting>T abstracts A || T abstracts B => T abstracts A&amp;B</programlisting></comment>
        -->
        
        <!--        
        <comment><para>TODO: This incorrectly describes the algorithm used by the 
        actual compiler for union and intersection types. Actually what happens is 
        that the compiler always reduces any union or intersection type to a simplest 
        canonical form. This affects the result of the algorithm in some very rare 
        cases, due to the weirdness of the fourth and fifth rules. (In which case 
        the compiler's approach is better!)</para></comment>
        -->
        
        <comment><para>TODO: This does not do justice the the compiler's handling 
        of type parameters which have upper bounds involving other type parameters.
        In fact, the compiler is also able to infer a type for the type parameter 
        that appears in the upper bound.</para></comment>
        
        <comment><para>TODO: Actually the compiler is even cleverer than this.
        The algorithm described above works great for type parameters that appear 
        covariantly in the "output" types, and even okay for type parameters that 
        appear invariantly. It doesn't really work very well for type parameters 
        that appear contravariantly, where the constraints are really of form 
        <literal>A satisfies T</literal>, and they should be combined using 
        intersection, not union, and where the default should be
        <literal>Anything</literal> not <literal>Nothing</literal>. Therefore,
        the compiler's algorithm is engineered to make the following work, where 
        both <literal>Consumer</literal> and <literal>Delegate</literal> are 
        contravariant types:</para>
        <programlisting><![CDATA[Delegate<String> delegate1 = ... ;
Delegate<Object> delegate2 = ... ; 
Consumer<String> consumer = Consumer(delegate1, delegate2);]]></programlisting>
        <!--para>Note also that there is something a bit conceptually funny about 
        a type parameter that appears covariantly in a parameter type, and 
        contravariantly in the return type (or vice-versa), so we probably don't 
        really need to bother about the case where a type parameter appears both 
        covariantly <emphasis>and</emphasis> contravariantly.</para-->
        </comment>
        
        <!--
        <para>The <emphasis>full lower bound for an inferred type parameter</emphasis> 
        <literal>T</literal> of the generic declaration is the union of the lower 
        bound for <literal>T</literal> with the lower bound specified by each
        type constraint on <literal>T</literal> of form <literal>T abstracts X</literal> 
        for every lower bound <literal>X</literal> on <literal>T</literal> in the 
        generic type constraints on <literal>T</literal> (after substitution of 
        type arguments into <literal>X</literal>).</para>
        -->
        
        <para>The inferred type argument to a type parameter <literal>T</literal> 
        of the generic declaration is:</para>
        
        <itemizedlist>
            <listitem>
                <para><literal>Nothing</literal>, if the inferred lower bound for 
                <literal>T</literal> is null, or, otherwise,</para>
            </listitem>
            <listitem>
                <para>the type <literal>A</literal>, where the inferred lower bound for 
                <literal>T</literal> is <literal>T abstracts A</literal>.</para>
            </listitem>
        </itemizedlist>
        
        <para>If the inferred type argument does not satisfy the generic type 
        constraints on <literal>T</literal>, a compilation error results.</para>
        
        <para>Consider the following invocation:</para>
        
        <programlisting><![CDATA[[Element+] prepend<Element>(Element head, Element[] sequence) { ... }
value result = prepend(null, {"hello", "world"});]]></programlisting>

        <!--
        <para>The constraint set for <literal>Element</literal> comprises two 
        constraints:</para>
        
        <itemizedlist>
            <listitem>
                <para><literal>Element abstracts Nothing</literal>, and</para>
            </listitem>
            <listitem>
                <para><literal>Element abstracts String</literal>.</para>
            </listitem>
        </itemizedlist>
        -->
        
        <para>The inferred type of <literal>Element</literal> is the union type 
        <literal>String?</literal>.</para>
        
        <para>Now consider:</para>
        
        <programlisting><![CDATA[class Bag<out Element>(Element* elements) {
    shared Bag<ExtraElement> with<ExtraElement>(ExtraElement* elements) 
            given ExtraElement abstracts Element { ... }
}
Bag<String> bag = Bag("hello", "world");
value biggerBag = bag.with(1, 2, 5.0);]]></programlisting>
        
        <!--
        <para>The constraint set for <literal>ExtraElement</literal> comprises 
        three constraints:</para>
        
        <itemizedlist>
            <listitem>
                <para><literal>ExtraElement abstracts Integer</literal>,</para>
            </listitem>
            <listitem>
                <para><literal>ExtraElement abstracts Float</literal>, and</para>
            </listitem>
            <listitem>
                <para><literal>ExtraElement abstracts String</literal> (formed by
                substituting <literal>String</literal> for <literal>Element</literal>
                in the schema of <literal>Bag</literal>).</para>
            </listitem>
        </itemizedlist>
        -->
        
        <para>The inferred type of <literal>ExtraElement</literal> is the union 
        type <literal>Integer|Float|String</literal>.</para>
        
        <comment><para>TODO: What about upper bounds in which the type parameter 
        itself appears (the infamous self-type problem with
        <literal>Comparable</literal> and <literal>Numeric</literal>) or in which 
        another type parameter appears?</para></comment>
        
        </section>
        
    </section>
    
    <!--
    <section id="metatype">
        <title>Metatypes</title>
        
        <para>For every type <literal>X</literal>, the <emphasis>metatype</emphasis> 
        <literal>MX</literal> of the type defines a typesafe metamodel of the members of 
        the type.</para>
        
        <itemizedlist>
            <listitem>
                <para>For each non-<literal>variable</literal> attribute of <literal>X</literal> 
                with type <literal>T</literal>, <literal>MX</literal> has an attribute with 
                the same name and type <literal>Attribute&lt;X,T&gt;</literal>.</para>
            </listitem>
            <listitem>
                <para>For each <literal>variable</literal> attribute of <literal>X</literal> 
                with type <literal>T</literal>, <literal>MX</literal> has an attribute with 
                the same name and type <literal>MutableAttribute&lt;X,T&gt;</literal>.</para>
            </listitem>
            <listitem>
                <para>For each method of <literal>X</literal> with return type <literal>R</literal> 
                and parameter types <literal>P...</literal>, <literal>MX</literal> has an 
                attribute with the same name and type <literal>Method&lt;X,R,P...&gt;</literal>.</para>
            </listitem>
            <listitem>
                <para>For each <literal>abstract</literal> member class <literal>Y</literal> 
                of <literal>X</literal>, <literal>MX</literal> has an attribute with the same 
                name and type <literal>MemberClass&lt;X,Y&gt;</literal>.</para>
            </listitem>
            <listitem>
                <para>For each non-<literal>abstract</literal> member class <literal>Y</literal> 
                of <literal>X</literal> with initializer parameter types <literal>P...</literal>, 
                <literal>MX</literal> has an attribute with the same name and type 
                <literal>MemberConcreteClass&lt;X,Y,P...&gt;</literal>.</para>
            </listitem>
        </itemizedlist>
        
    </section>
    -->
        
</chapter>
